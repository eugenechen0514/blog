[{"categories":null,"content":"WIP\n","date":"2022-06-23","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/about/","series":null,"smallImg":"","tags":null,"title":"About"},{"categories":["心得"],"content":"AlphaCamp Data \u0026amp; AI - 推薦系統 RecSys 資料人才種子計畫上課心得。\n起源及目地 看到 AC 推出推薦系統的課就很好奇，推薦系統是要怎麼教？很久以前有碰過一點點深度學習的課，一直搞不懂它和推薦系統的關係，到底是用在哪？又感覺推薦系統是更遙不可及的技術/概念。同時，可以找個實作機會練習一下 pandas 這熱門的套件，真是一舉兩得。\n一收到開課消息，就立刻和家人討論是否可以參加，隔一天就立刻繳費了。之後就收到了「資料人才種子計畫」改為保証金制度（條件性免費）的消息和兩次的開課前測驗。「開課前測驗」聽起來很可怕，但其實是為了讓學生可以提前學習到必要的語法(因為課程內容不會涵蓋)，順便讓已報名的學生確認自己適不適合。「保証金制度」機制還挺不錯的，在確保工作坊的參與率下，也可以一同要求學生實作練習。若有完成所有的任務，就會在結業後退費。個人覺得，那些任務對於想要學習的人來說應該就會做到的，所以對我沒有造成很大的壓力。\n課程與工作坊 開課前就說明了會教什麼、不會教什麼。課程內容的主軸安排十分明確，以一個推薦案例，分別示範 rule-base/content-base/collaborative-filtering 如何實作，最後實作 iCook 專案，打造食譜推薦系統。\n工作坊也是課程的重點之一，也是除了線上課程之外，學習內容更多的地方，類似研討會(seminar) 但不同是更著重分享和討論。討論的內容包含復習和預習課程內容，也會有作業表現不錯的同學經驗分享。只要是線上的所有人都可以參加討論分享，不是只有單一個講者，任何人都可以透過開語音或是打字發言皆可以。\n學習經歷 開課的設計是一步步帶領學生邊看邊做，分解的很詳細。最後在來寫作業，自己練習思考。寫作業的過程也是一種學習，學習 pandas 套件的使用和它的哲學、matplotlib/seaborn 制圖套件。\n助教資源也是課程的價值之一，感謝 Angie、Youngmi、Jeffery 的助教作業批改回饋，提供的個人經驗讓我了解到從來沒想到的思考方向。\n工作坊是往常和我的學習經驗完全不同的地方，讓學生的學習從被動到主動，大家針對商業問題提出個人見解和討論，討論氣氛十分熱絡。對我個人來說，學到更多的東西。因為我的工作主要是服務應用的開發，沒有什麼商業思維。在工作坊中，觀摩到許多高手的想法和經驗，像是：\n資料的特性的事前分析，EDA (Exploratory Data Analysis)，就可以更容易做出有效的推薦 熟不熟語言不是重點，重要的是想法 不是多深的技術就會有很好的表現 rule-base 雖然單純，但有用 沒有標準的答案 很多 pandas 的語法和製圖方式 結語 在結束一個月沒有假日的學習後，回頭看發現真的學了不少東西。身為本科系是應用數學系的人來說，可以看到所學可以被應用出來是很高興的事。雖然我的作業結果沒有很好，也看到自己在商業思維上的不足，但我想已經達到我本來設定的目標了。\n相關連結 資料人才種子計畫\n作業練習\n","date":"2022-02-06","img":"https://eugenechen0514.github.io/blog/posts/reviews/2022-02-06-alphacamp%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E4%B8%8A%E8%AA%B2%E5%BF%83%E5%BE%97/images/cover.png","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/posts/reviews/2022-02-06-alphacamp%E6%8E%A8%E8%96%A6%E7%B3%BB%E7%B5%B1%E4%B8%8A%E8%AA%B2%E5%BF%83%E5%BE%97/","series":null,"smallImg":"","tags":["AlphaCamp","推薦系統","pandas","python"],"title":"AlphaCamp 推薦系統上課心得"},{"categories":["隨手筆記"],"content":"從 Kafka 內部儲存資料來看 Kafka 的基本概念是很合適的，因為怎麼存就會了解它的架構和限制。\nKafka 本質上是 Distributed, Replicated Messaging Queue ，在微服務和分散式計算的經常會被提及。要最大化效能就要對資料的存放有些了解。\nKafka 的基本概念如下圖：\n下圖是概念和內部儲存資料的關係圖：\n注意：上圖的 index/timeIndex 檔案只是示意圖，它們不是一個每筆 message 都有一筆 index 資料，見下面的實測。\n窺視一個 partition 的資料夾 1$ ll /data/kafka/kafka-logs/test.eugene.test-7 1total 8.0K 2-rw-r--r-- 1 root root 10M Aug 22 18:31 00000000000000000000.index 3-rw-r--r-- 1 root root 88 Aug 22 18:35 00000000000000000000.log 4-rw-r--r-- 1 root root 10M Aug 22 18:31 00000000000000000000.timeindex 5-rw-r--r-- 1 root root 8 Aug 22 18:31 leader-epoch-checkpoint 用工具 DumpLogSegments 可以一窺內容\nOffsetIndex - Index Of Offsets Of Log Segment 1$ bin/kafka-run-class.sh kafka.tools.DumpLogSegments --deep-iteration --print-data-log --files /data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.index 1Dumping /data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.index 2offset: 0 position: 0 TimeIndex - Index Of Timestamp And Offsets Of Log Segment 1$ bin/kafka-run-class.sh kafka.tools.DumpLogSegments --deep-iteration --print-data-log --files /data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.timeindex 1Found timestamp mismatch in :/data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.timeindex 2 Index timestamp: 0, log timestamp: 1629628512555 Log File 1$ bin/kafka-run-class.sh kafka.tools.DumpLogSegments --deep-iteration --print-data-log --files /data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.log 1Dumping /data/kafka/kafka-logs/test.eugene.test-7/00000000000000000000.log 2Starting offset: 0 3baseOffset: 0 lastOffset: 0 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 0 CreateTime: 1629628512555 size: 88 magic: 2 compresscodec: NONE crc: 1254090055 isvalid: true 4| offset: 0 CreateTime: 1629628512555 keysize: 0 valuesize: 18 sequence: -1 headerKeys: [] key: 12 payload: { 5 \u0026#34;data\u0026#34;: 12 6} 7baseOffset: 1 lastOffset: 1 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 88 CreateTime: 1629628976272 size: 90 magic: 2 compresscodec: NONE crc: 2535940961 isvalid: true 8| offset: 1 CreateTime: 1629628976272 keysize: 2 valuesize: 18 sequence: -1 headerKeys: [] key: 13 payload: { 9 \u0026#34;data\u0026#34;: 13 10} 相關連結 A Practical Introduction to the Internals of Kafka Storage | Medium\n","date":"2021-08-22","img":"https://eugenechen0514.github.io/blog/posts/notes/2021-08-22-%E4%B8%80%E7%AA%BAkafka%E5%85%A7%E9%83%A8%E5%84%B2%E5%AD%98%E8%B3%87%E6%96%99/images/cover.png","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/posts/notes/2021-08-22-%E4%B8%80%E7%AA%BAkafka%E5%85%A7%E9%83%A8%E5%84%B2%E5%AD%98%E8%B3%87%E6%96%99/","series":null,"smallImg":"","tags":["Kafka"],"title":"一窺 Kafka 內部儲存資料"},{"categories":["隨手筆記"],"content":"MongoDB 於 7月13日釋出了 5.0 版，這次除了更新 mongosh shell，也針對 Time Series 資料的支援。\n完整的更新列表請參考 Release Notes for MongoDB 5.0。\nmongosh shell mongo shell 在 5.0 版被棄用了，取而代之是 mongosh shell，它是一個 Node.js 14.x REPL 互動環境，你甚至可以 require() 其它 npm module，見：Write Scripts for mongosh。另外，它還支援 GCP 和 Azure 的 Key Management Service (KMS)。\n雖然 mongo 被棄用，它的指令目前都可以運行在 mongosh 上，完整的指令見 MongoDB Shell Methods。\nmongosh 的改變很大，其中是語法高亮(syntax highlighting)，它讓許多「查詢狀態」指令類的結果好讀了許多，如：db.collection.getShardDistribution()\n時間序列資料集 (Time Series Collection) 5.0 版引進時間序列資料集(Time Series Collection)，它優化儲存空間和查詢效能。\n使用者要顯示地用 db.createCollection() 建立資料集：\n1db.createCollection(\u0026#34;weather\u0026#34;, { timeseries: { timeField: \u0026#34;timestamp\u0026#34; } } ) 2 3db.createCollection( 4 \u0026#34;weather24h\u0026#34;, 5 { 6 timeseries: { 7 timeField: \u0026#34;timestamp\u0026#34;, 8 metaField: \u0026#34;metadata\u0026#34;, 9 granularity: \u0026#34;hours\u0026#34; 10 }, 11 expireAfterSeconds: 86400 12 } 13) MongoDB 雖然會在內部建立 timeField 指定欄位的 index，使用者還是可以對 metaField 和 timeFiel 指定欄位建立次索引(二級索引) Secondary Index 來改善查詢效能。\n注意：二級索引的設定有些限制， 目前只能設定在 metadata(如果有設定) 和 timestamp 指定的欄位中，如：\n1db.weather24h.createIndex({ \u0026#34;metadata.sensorId\u0026#34;: 1, \u0026#34;timestamp\u0026#34;: 1 }) 注意：目前 Time Series 還不能在 sharding 環境中，據說會在接下來的版本持續釋出。\nAggregation 使用 MongoDB 一定要學習的就是 Aggregation Pipeline，它幫助我們以流水線的方式處理/分析整個資料集(collection)。\n$setWindowFields stage 從 MongoDB 4.2 引入 $merge stage 讓我們可以把聚合結果寫回並合併到指定的資料集(collection)。這次引入新的 $setWindowFields stage，我們可以在一個排序的資料集中，以及自定義的 window，對每個 document 的 window 所涵蓋的資料聚合計算，並儲存於 document 的 field 上。\n以上圖為例，就是對每筆訂單計算前十個月的訂單紀錄 recentOrders，完整例子見：Use a Time Range Window with a Positive Upper Bound。\n股票技術分析中的「移動平均線(Moving Average)」也可以用這個來實現。\n聚合算子(Aggregation Operators) 同時增加分析 Time Series 資料可能會用到的算子。\n時間日期操作(Date operation)：$dateAdd，$dateDiff，$dateSubtract，$dateTrunc\n$group 的聚合累積算子(aggregation accumulator)中新增 $count，來計算各分群的數量。另外，此算子也可以用在 $setWindowFields 中。\n針對含有錢字 ($) 或句號 (.) 欄位名(field)的設定和取出: $getField / $setField\n機率抽樣指定比率的文件(document)量 $sampleRate。(這在 4.4.2 版已釋出)\ndb.collection.aggregate() 增加 let Option db.collection.aggregate(pipeline,options) 可以用 let option 改善 pipeline 的可讀性。\n1db.cakeSales.aggregate( 2 [ 3 { $match: { 4 $expr: { $gt: [ \u0026#34;$salesTotal\u0026#34;, \u0026#34;$$targetTotal\u0026#34; ] } 5 } } 6 ], 7 {let: { targetTotal: 3000 } } 8) let 定義 targetTotal 變數，然後在 pipeline 中用 $$targetTotal 引用變數。這表示我們可讓 pipeline 可以更乾淨一點，也可以拿來分離非 pipeline 的程式碼。\n接下來，在分片叢集架構上，也加入了維運用的 refineCollectionShardKey 和 reshardCollection。\nShared Cluster 雖然在 4.4 版加入了 refineCollectionShardKey 來處理 jumbo chunks 的議題 - 可能由於基數(cardinality) 不足引起而無法切分(split)的巨大 chunk。但還是沒有搔到癢處，因為除非很有經驗或是很確定查詢資料的方式或資料結構，否則不太容易第一次取的 shard key 就會很準確。這次 5.0 版終於可以用 reshardCollection 來修改 shard key。\n不過別高興的太早，因為會把一個資料集分散在個各分片，通常那資料集就是很大的資料量，所以要把大量的資料重新分配，可想而知是很巨大的挑戰，使用前請詳讀 Reshard a Collection。\n另外，renameCollection 在 5.0 版也可以用在 sharded collection 上了。\n","date":"2021-08-01","img":"https://eugenechen0514.github.io/blog/posts/notes/2021-08-01-mongodb-5-%E4%BE%86%E4%BA%86%E6%9C%89%E4%BB%80%E9%BA%BC%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%9B%B4%E6%96%B0/images/205E1EDC91FA1B5BAF557D3E052EC920.jpg","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/posts/notes/2021-08-01-mongodb-5-%E4%BE%86%E4%BA%86%E6%9C%89%E4%BB%80%E9%BA%BC%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%9B%B4%E6%96%B0/","series":null,"smallImg":"","tags":["MongoDB"],"title":"MongoDb 5 來了，有什麼值得注意的更新呢?"},{"categories":[],"content":"介紹 Docker Network mode 和三十天的回顧\n回憶 昨天我們用 Compose file 一次描述三個容器， Compose file 如下：\n1// docker-compose-bridge.yml 2version: \u0026#39;2\u0026#39; 3services: 4 database: 5 image: mongo:4.1 6 container_name: mongo4 7 ports: 8 - \u0026#34;27017:27017\u0026#34; 9 volumes: 10 - \u0026#34;./data/mongo/data:/data/db\u0026#34; 11 frontend: 12 image: ithelp/frontend:1.0.0 13 container_name: ithelp.frontend 14 ports: 15 - \u0026#34;80:80\u0026#34; 16 volumes: 17 - \u0026#34;./data/nginx/log:/var/log/nginx\u0026#34; 18 backend: 19 image: ithelp/backend:1.0.0 20 container_name: ithelp.backend 21 ports: 22 - \u0026#34;3001:3001\u0026#34; 23 command: \u0026gt; 24 /bin/bash -c \u0026#34; 25 sleep 15; 26 npm run start;\u0026#34; 27 environment: 28 PORT: 3001 29 NODE_ENV: \u0026#34;development\u0026#34; 30 MONGODB_URL: \u0026#34;mongodb://database:27017\u0026#34; 在用指令 docker-compose 建立並執行它們： 仔細看有一行：Creating network \u0026quot;ithelp-30dayfullstack-day30_default\u0026quot; with the default driver。這是什麼呢？ 這就是今天要討論的內容：network 。 network 很重要，因為關係它各服務間的通信。\n目標 我們會重心放在如何使用，而不是放在解析 docker network。先學會使用，再去深究其原理。有興趣的人可以挑戰看看這篇 Docker Reference Architecture: Designing Scalable, Portable Docker Container Networks。\n今天的內容全是指在單一主機用 Docker Compose 可能會發生的 network 情況。在還沒進到叢集的世界之前，不同主機的連線，用 IP 連就可以了。光是用 Docker Compose 你就能感受到 docker 的威力。\n在開始前，我們開一個 ithelp-30dayfullstack-Day30 資料夾，所有的 Compose file 都會放在裡面。\n完整的專案，請點我\nDocker Network mode Bridge mode 這是 Docker Compose 預設的網路模式，所有有 service 預設 network_mode: 都是 bridge (見 network_mode)。當我們 docker-compose up 時，會建立一個名為 \u0026lt;dir_name\u0026gt;_default 的 network 出來，所有 bridge mode 的 container 會自己配網路卡並接上那個預設的 network。\n我們在回憶中的 Compose file，用圖解如下： 圖片重繪自：Networking for Docker Containers (a Primer) Part I\n172.28.0.0/16 是指一網路的網段從 172.28.0.1 ~ 172.28.255.255，子網路的主機可以互相通訊。 16 是指 16 bits 的子網路遮罩 255.255.0.0。\n你可以用 docker network ls 列出所有 network\nContainer 間如何通訊： Container \u003c-\u003e Container Container 間的通訊有幾個方法：\n用 service/container name：直接寫 serivce name/container。 就如同前面寫的 1backend: 2 …略 3 environment: 4 PORT: 3001 5 NODE_ENV: \u0026#34;development\u0026#34; 6 MONGODB_URL: \u0026#34;mongodb://database:27017\u0026#34; backend 可以訪問 database。 用 IP: 我們也可以直接指定 IP。 指令 docker network inspect ithelp-30dayfullstack-day30_default 可以查詢「接上此 network 的 container 資訊」 ithelp-30dayfullstack-day30_default 有三個容器及它們配置的 IP。另外還有 gateway 和 subnet。 外界(NET-0)如何存取 container： 外界(NET-0) -\u003e Container 若外界 192.168.0.5 要訪問我們的主機 192.168.0.2:80 的 ithelp.front 服務，我們要設定 --publish/-p。就是我們在 Docker file 中的 ports: 或 docker run -p 設定 publish。同時， Network Address Translation(NAT) 也會自動設定內外部 network 的轉換。\n從外界來看，邏輯上就像： 外界不會發現內部的網路。\n存取 host/外界 ： Container -\u003e 外界(NET-0)/HOST 若 container 要與外界通訊，可以跟往常一樣用 hostname / ip。除非你刻意去調整 dns/host 之類的設定，不然正常使用就可以了，我們不打算深究。\n反而， Container 存取 HOST 是有可能發生的，因為在還沒完全引入 docker 前，我們可能在 HOST 已架好 MongoDB / MySQL 之類的服務。接下來考慮兩種可能的情況。\n非固定 IP 情況 container 建立時會配置網路設定，沒重建立的話 IP 是不會變的。 在 bridge mode 下，NAT 那單元可以直接看成是 HOST，所以 HOST 的 IP 在 DOCKER0 BRIDGET network 中的位置就是 gateway IP 。因此，在容器中，要訪問到 HOST 是 DOCKER0 BRIDGET 下的 gateway IP 而不是 127.0.0.1 (127.0.0.1 是指容器本身)。\n你可以登入 container (docker run -it \u0026lt;id/container_name\u0026gt; bash) 試打看看(ex: telenet/ping/wget/curl)，就可以知道有沒有通。\n指令 docker network inspect ithelp-30dayfullstack-day30_default 就可以查到 gateway IP。 固定 IP 情況 練習時，你可能要 docker-compose -f docker-compose-bridge.yml down 刪除之前的容器、網路。\n容器內的環境有時需要 hard code 寫 HOST 的 IP，像是 Nginx 要導轉到 HOST 的舊網址、Nginx 要導轉轉到某個 Container 或 MonoDB 連線網址寫死在 Compose file。這時候每次重建 containers 網路就會變了。因此，我們可以客製化 bridge 的設定固定 IP，一方面可以固定 Container IP 又可以固定 HOST IP。\n為了固定 IP，我們要建立一個 network ithelp_application 設定裡面的 subnet: 和 gateway:，接著，每個容器使用 ithelp_application network 並指定固定 IP。 如下：\n1version: \u0026#39;2\u0026#39; 2services: 3 database: 4 image: mongo:4.1 5 container_name: mongo4 6 networks: 7 ithelp_application: 8 ipv4_address: 172.28.0.2 9 ports: 10 - \u0026#34;27017:27017\u0026#34; 11 volumes: 12 - \u0026#34;./data/mongo/data:/data/db\u0026#34; 13 frontend: 14 image: ithelp/frontend:1.0.0 15 container_name: ithelp.frontend 16 networks: 17 ithelp_application: 18 ipv4_address: 172.28.0.3 19 ports: 20 - \u0026#34;80:80\u0026#34; 21 volumes: 22 - \u0026#34;./data/nginx/log:/var/log/nginx\u0026#34; 23 backend: 24 image: ithelp/backend:1.0.0 25 container_name: ithelp.backend 26 networks: 27 ithelp_application: 28 ipv4_address: 172.28.0.4 29 ports: 30 - \u0026#34;3001:3001\u0026#34; 31 command: \u0026gt; 32 /bin/bash -c \u0026#34; 33 sleep 15; 34 npm run start;\u0026#34; 35 environment: 36 PORT: 3001 37 NODE_ENV: \u0026#34;development\u0026#34; 38 MONGODB_URL: \u0026#34;mongodb://database:27017\u0026#34; 39networks: 40 ithelp_application: 41 driver: bridge 42 ipam: 43 driver: default 44 config: 45 - subnet: 172.28.0.0/16 46 gateway: 172.28.0.1 執行 docker-compose -f docker-compose-bridge-static.yml up，完成後去看看 docker network inspect ithelp-30dayfullstack-day30_ithelp_application，就是我們固定的 IP Host mode 練習時，你可能要 docker-compose -f docker-compose-bridge-static.yml down 刪除之前的容器、網路。\n這是最簡單的模式，直接想成 container 執行在 HOST 的 process，它監聽什麼 port ， HOST 什麼 port 就會被使用，連 --publish/-p 都不用了。\n這模式的通訊比較簡單，不像 bridge mode 複雜。127.0.0.1 就是指 HOST，所以每個容器可以用 127.0.0.1:\u0026lt;port\u0026gt; 通訊，與其它的 HOST 服務也是一樣；外界就是用 192.168.0.2。\n1version: \u0026#39;2\u0026#39; 2services: 3 database: 4 image: mongo:4.1 5 container_name: mongo4 6 network_mode: \u0026#34;host\u0026#34; 7 volumes: 8 - \u0026#34;./data/mongo/data:/data/db\u0026#34; 9 frontend: 10 image: ithelp/frontend:1.0.0 11 container_name: ithelp.frontend 12 network_mode: \u0026#34;host\u0026#34; 13 volumes: 14 - \u0026#34;./data/nginx/log:/var/log/nginx\u0026#34; 15 backend: 16 image: ithelp/backend:1.0.0 17 container_name: ithelp.backend 18 network_mode: \u0026#34;host\u0026#34; 19 command: \u0026gt; 20 /bin/bash -c \u0026#34; 21 sleep 15; 22 npm run start;\u0026#34; 23 environment: 24 PORT: 3001 25 NODE_ENV: \u0026#34;development\u0026#34; 26 MONGODB_URL: \u0026#34;mongodb://127.0.0.1:27017\u0026#34; 圖片重繪自：Networking for Docker Containers (a Primer) Part I\nDocker Network mode 小總結 我們介紹了 Bridge mode、Host mode，它們有各自的特色：\nbridge mode:\n高彈性的網路設定 不同容器間的 port 號可以一樣，因為容器有自己的 IP 可以降低 HOST port 相衝的可能 用起來設定複雜 容器、 HOST 、外界不容易通訊 Host mode：\n容易與 HOST port 、容器 port 的相衝、 用起來設定簡單 容器、 HOST 、外界容易通訊 到這裡為止，我打算就結束今天的內容。今天的最後我們來回顧一下，我們做了什麼事、什麼事沒做？\n三十天的回顧 先恭喜看到這的你，熬過三十天的疲勞轟炸。我們歷經了三個周目：\n一周目 - 一次串完所有的服務 在本地端建立前端和後端並把它們串接起來 二周目 - 深入了解前後端 我分別從前後端挑選了重要的概念或是工具作為二周目的主題。 三周目 - 發佈、維運 以 Docker 為基礎，製作、發佈自己的前端和後端程式。 在 Day 1 - 前言／開發環境準備 曾提過我們三十天要涵盖的內容如下，若有提到我們就把它們劃掉\n前言 一輩子受用的工具 shell常用指令 markdown - 打筆記 draw.io - 畫圖 一周目 - 一次串完所有的服務 js/nodejs project js 速成 - es6語法、模組化 eslint - 程式碼品質工具 quick backend Postman - api 測式工具 quick frontend 二周目 開發流程 後端 基本知識 awilix - 依賴注入 process.env middleware / router / request / response 建立與連線 MongoDB 後端多工/ 叢集/child process Auth: token - JWT 常用庫: lodash, monent, mongoose 可研究方向: GraphQL, websocket, redis, server-side rending, Oauth 測試 基本知識 - 依賴注入 單元測試、整合測試 替身 常用庫 sinon.createFakeServer() unexpected/ unexpected react 前端 基本知識 - 打包, sass, rwd(mdiea query, boostrip) tooles: chrome extension google devtools snadbox - codesandbox React - pure/container, Fragments, lifecycle, Context, loop/condition expression, lifecycle sandbox, loop key strategy Redux - flux RxJs - 非同步action material-ui - UI元件庫 可研究方向: PWA, functional programing 串連前後端 串接api 單元測試、整合測試(puppeteer) nginx, single page application(spa) 設定 三周目 - 發佈、維運 發佈 Docker, Docker-compose: volumn, ps, image, network 打包 image, shell script verdaccio - 建立自己的私有庫 維運 ELK Zabbix - email, slask vegeta - 壓測工具 MongoDB 備份 我想達成率只有 65% 左右，有些內容還被我刪減，離我想寫完整的東西還有一段路。每天的內容一直調整，很多時候因為時間不夠、篇幅有限、考慮到完整性、可讀性，我只能做刪減。但是，不論我怎麼調整，目標只有一個： 帶讀者瀏覽從前端到後端再到 DevOps 的歷程。\n本主題只是打開你在各個技術的大門，能否或需不需要踏入就要由你自行決定了。我相信一定有很多專門的主題或文章可以說的更好，希望我能作為你看那些文章的墊腳石。\n因為寫的很趕，寫完後，只能校稿一次，也許會有不通順的地方請見諒。內容不完整或缺少的部分，我目前在計畫找時間補上。未來的文章，有可能會在 Medium 或 iT邦幫忙 同時發佈，喜歡的話可以 Follow，謝謝各位。\n","date":"2018-10-30","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-30-%E4%B8%89%E5%91%A8%E7%9B%AE-docker-network-%E6%9A%A8%E5%AE%8C%E8%B3%BD%E5%9B%9E%E9%A1%A7/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 30- 三周目 - Docker Network 暨完賽回顧"},{"categories":[],"content":"用 Docker Compose 一次管理多個容器\n回憶 昨天學了打包前後端映像檔，也完成了串接，但還缺了 MongoDB。一次要控制三個容器運作，很不方便。透過 Docker Copmose 可以輕鬆地一次管理多個容器，\n目標 學習寫 docker compose 組態檔 發佈在單一主機 Docker Compose 很適合用在單一主機的發佈、開發或測試(見Common use cases)，它也是建立叢集(cluster)的基本工具之一(見：Deploy a stack to a swarm\n完整的專案，請點我\nDocker Compose Docker Compose 可以讓我們用一個描述檔(預設名稱是 docker-compose.yml )管理多個容器， 同時管理、操作它們，甚至分開管理。描述檔是用 YAML 格式撰寫的。\nDocker Compose 描述檔目前有三個版本 version 1、 version 2、 version 3。 Docker Engine 對它們有不同的支援度(Compose and Docker compatibility matrix，而且不同版支援的功能可能會不一樣，像是：ipam-gateway 這個目前只在 version 2 支援，version 3 不支援，所以使用前可能要查一下能不能用。\n用 Docker Compose 串接前後端 配置前後端 service 記得先把之前的建立的容器：ithelp.backend、ithelp.frontend 刪除\n昨天我們使用下面的指令建立並執行容器\n1# 後端 2docker run --rm -p 3001:3001 --name ithelp.backend ithelp/backend:1.0.0 npm run start 3 4# 前端 5docker run --rm -p 80:80 --name ithelp.frontend ithelp/frontend:1.0.0 全部的參數可以寫成 docker compose 描述檔：\n1// docker-compose.yml 2version: \u0026#39;2\u0026#39; 3services: 4 frontend: 5 image: ithelp/frontend:1.0.0 6 container_name: ithelp.frontend 7 ports: 8 - \u0026#34;80:80\u0026#34; 9 backend: 10 image: ithelp/backend:1.0.0 11 container_name: ithelp.backend 12 ports: 13 - \u0026#34;3001:3001\u0026#34; 14 command: \u0026#34;npm run start\u0026#34; 15 environment: 16 PORT: 3001 17 NODE_ENV: \u0026#34;development\u0026#34; 在 Compose 世界裡，application 是由一群 service 組成的，每個 service 就像是容器一樣，可以設定它的 image, container 相關參數。當要建立容器時，就會以 service 當樣版產生容器。我們要注意，因為容器名只能唯一的，所以當發佈在swarm mode時，container_name 可能會被忽略或出錯。目前我們假設每個 service 只會產生一個容器，所以就放心使用。\n雖然前後端的容器設定好了，我們還缺 MongoDB。\n加入 MongoDB service 1// docker-compose-with-db.yml 2version: \u0026#39;2\u0026#39; 3services: 4 database: 5 image: mongo:4.1 6 container_name: mongo4 7 ports: 8 - \u0026#34;27017:27017\u0026#34; 9 volumes: 10 - \u0026#34;./data/mongo/data:/data/db\u0026#34; 11 frontend: 12 image: ithelp/frontend:1.0.0 13 container_name: ithelp.frontend 14 ports: 15 - \u0026#34;80:80\u0026#34; 16 volumes: 17 - \u0026#34;./data/nginx/log:/var/log/nginx\u0026#34; 18 backend: 19 image: ithelp/backend:1.0.0 20 container_name: ithelp.backend 21 ports: 22 - \u0026#34;3001:3001\u0026#34; 23 command: \u0026gt; 24 /bin/bash -c \u0026#34; 25 sleep 15; 26 npm run start;\u0026#34; 27 environment: 28 PORT: 3001 29 NODE_ENV: \u0026#34;development\u0026#34; 30 MONGODB_URL: \u0026#34;mongodb://database:27017\u0026#34; database 做了以下的調整:\ndatabase 使用 volumes：把 ./data/mongo/data 掛載到容器 /data/db，它是 MongoDB 的資料位置。 frontend 做了以下的調整:\nfrontend 使用 volumes：把 ./data/nginx/log 掛載到容器 /var/log/nginx，它是 Nginx 的 log 資料夾。 backend 做了以下的調整：\ncommand ： 之前的容建立完立刻執行 npm run start；現在改成 sleep 10 秒才執行npm run start。 我們這樣做是因為 MongoDB 不是一執行就可以連線，要等到 MonoDB 「ready」，後端才可以執行並連線。 有人可能會發現 depends_on 這個設定，但它是指 service 的執行順序，不是指資料庫 「ready」可以連線的設定。因此，只能延遲後端的執行。\n加入 MONGODB_URL 環境變數：在 hello-mongo 後端專案中的 configs/config.js 設定檔： 1// configs/config.js 2const config = { 3 mongodb: { 4 url: process.env.MONGODB_URL || \u0026#39;mongodb://localhost:27017\u0026#39;, 5 dbName: process.env.MONGODB_DB_NAME || \u0026#39;myproject\u0026#39;, 6 } 7} 這是我們為了可以由外部設定後端的參數之一 (若process.env.XXX 需要幫助，請看 Day 17 的 環境變數 process.env)。 MONGODB_URL 的值：Compose 允許我們 直接用 service name，所以我們可以不用知道 database 被配置的 ip。 docker-compose 執行 application 準備階段： 建一個 ithelp-30dayfullstack-Day29 資料夾，再用 VSCode 開啟 建立 data/mongo 資料夾，把之前的 mongo4 的 data 放到 data/mongo 裡 建立 data/nginx 資料夾 最後如下圖： 執行階段： 建立並執行容器\n1docker-compose -f docker-compose-with-db.yml up 這裡用 -f 指定使用的組態檔。\n這樣就執行成功了，一次開了三個容器。\n若要停止容器，只要 ctrl + c。 若要再次執行，可以直接：\ndocker-compose -f docker-compose-with-db.yml up ：重新執行且 attach 到前景。 docker-compose -f docker-compose-with-db.yml start ：重新執行且放到背景。 docker 和 docker-compose 有很多相似之處，運作模式、參數也差不多，只是變成一次控制一群容器。常用指令如下：\n用途 指令 常用可選參數 類似指令 建立並前景執行容器 docker-compose up -d、-f docker run 查看容器運作 docker-compose ps -f docker ps 執行容器 docker-compose start -f docker start 停止容器 docker-compose stop -f docker stop 刪除容器 docker-compose down -f docker rm 印出log docker-compose logs -f docker logs 進入容器 docker-compose exec \u0026lt;service\u0026gt; bash -f docker exec -it \u0026lt;id or container-name\u0026gt; bash docker-compose 也可以針對某個 service 控制，大概都是 docker-compose up \u0026lt;service\u0026gt; 這類的格式，更多細請自己節查 --help，如：docker-compose up --help\n發佈你的 application 發佈前，你必需有以下東西\nimage docker-compose file 映像檔的輸出/輸入 映像檔雖然由 docker 統一管理，但它可以用 docker save / docker load 輸出/輸入映像檔。\n1# 建立映像檔資料夾 2mkdir images 3 4# 輸出：mongo:4.1、ithelp/backend:1.0.0 和 ithelp/frontend:1.0.0 打包成 ithelp.tar 5docker save -o images/ithelp.tar mongo:4.1 ithelp/backend:1.0.0 ithelp/frontend:1.0.0 6 7# 輸入：從 ithelp.tar 一次輸入三個映像檔 8docker load -i images/ithelp.tar 發佈 只要拷貝\nimages 資料夾 : ithelp.tar docker-compose file: docker-compose-with-db.yml 其它初始化腳本或其它組態檔：可能要用腳本產生預設資料夾或其它組態檔(nginx 組態檔之類的) 再放到發佈的主機，就可以在任何有 Docker Engine 的環境執行、運作。\n你可以用 shell script 或 npm script 譔寫屬於自己的腳本，減少打指令，像是建置時立刻輸出映像檔、用 shell variable 設定版號、腳本化讀入映像檔。\n總結 今天使用 Docker Compose 組態檔述描容器，隨後就可以用 docker-compose 指令一次管理一批容器。我們還使用 docker save/load 輸出/輸入映像檔。因此，有了映像檔和 Compose 組態檔就可以發佈在任何 Docker Engine 環境執行。\n另外，別忘了開主機防火牆讓別人連進來\n1firewall-cmd --add-port=80/tcp --permanent ","date":"2018-10-29","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-29-%E4%B8%89%E5%91%A8%E7%9B%AE-docker-compose%E4%B8%80%E6%AC%A1%E7%AE%A1%E7%90%86%E5%A4%9A%E5%80%8B%E5%AE%B9%E5%99%A8/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 29- 三周目 - Docker Compose：一次管理多個容器"},{"categories":[],"content":"製作自己的映像檔：包打前後端映像檔\n回憶 昨天學了如何利用 verdaccio 建立自己的私有庫，今天要自己做映像檔。\n目標 可能很多人會遇到以下問題：\n怎麼在無對外網路的環境下發佈程式 相依套件太多怎麼辨 怎麼隨時切換版本 以上問題，在 Docker 的世界可以容易克服：把你的程式打包成 映像檔\n今夾就要來學習打包我們的前後端專案 hello-mongo、hello-react。\n請分別拷貝\nhello-mongo：見 Day 19 - 二周目 - 帳密認証與JWT (JSON Web Token)傳遞 hello-react： 見 Day 25 - 二周目 - React component 套件 Material-UI： Google Material Design 的實作套件 過程請參考 commit log： 1. ithelp-30dayfullstack-Day28-backend 2. ithelp-30dayfullstack-Day28-frontend\nDocker image 打包映像檔需要一個 Dockfile 來描述打包過程，之後再執行 docker build 就可以進行製作映像檔。\nDockfile 就像是在 terminal 中打指令一樣，Docker 使用一行一行的操作(instruction)來建立映像檔。每個操作用大寫命名。\n我們用到的操作不多，全部操作見Dockerfile reference\n你可以想像現在有一個容器的File System 且 進入它，你想放什麼檔案？執行什麼指令？\n製作後端映像檔 建置操作檔 Dockerfile 和 建置忽略檔.dockerignore 在根目錄下建立一個名為 Dockerfile 的檔案\n1FROM node:10 2 3# Localtime 4ENV TZ=Asia/Taipei 5RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; echo $TZ \u0026gt; /etc/timezone 6 7# Create app directory 8WORKDIR /usr/src/app 9 10# Install app dependencies 11COPY package*.json ./ 12 13# Use private registry 14RUN npm set registry http://127.0.0.1:4873 15 16RUN npm install 17# If you are building your code for production 18# RUN npm install --only=production 19 20# Bundle app source 21COPY . . 22 23# Main server 24EXPOSE 3001 25 26# Default command for executing container 27#CMD [ \u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34; ] Dockerfile 設定了基底映像檔(FROM)、系統時區(RUN ln...)、工作目錄(WORKDIR)、把本機端檔案拷貝到映像檔裡面(COPY)、執行指令(RUN)、容器欲監聽的port (EXPOSE)、容器執行時欲執行的指令(CMD)。因為都很直接，我就不多說了\n這 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;start\u0026quot; ] 被我註解了，因為我想用另一種方法執行後端伺服器\n加入 .dockerignore：建置時忽略的檔案清單\n1node_modules 2.git 3.vscode COPY . . 會拷貝所有檔案，但 node_modules、.git和.vscode/ 不用拷貝進入，所以要加入到 .dockerignore 中忽略檔案。\nnode_modules 不應該放進映像檔，因為某些套件可能會跟作業系統有關。取而代之，我們要在建置映像檔時才安裝(RUN npm install)。\n有幾點注意：\n若基底映像檔(FROM)不存在，docker 會自動去 docker hub 下載。 RUN 可以分行 \\ (backslash)： 1RUN /bin/bash -c \u0026#39;source $HOME/.bashrc; \\ 2echo $HOME\u0026#39; RUN 是獨立地單一執行，不是像 terminal 可以一直下指令 1RUN TEST=hi 2RUN echo $TEST # 抓不到值 要併成一行 1RUN TEST=hi; echo $TEST 系統時區一定要記得設，不然你看到的日期會是 UTC +0:00，跟我們的 UTC +8:00 差八小時。 COPY . . 是指拷貝本機端「當前目錄的所有檔案」到 映像檔的「WORKDIR 的當前目錄」(即 /usr/src/app)。 若希望進容器後可以有更多指令，你可以安裝環境套件，如 RUN apt-get install -y vim。 EXPOSE 只是註明映像檔可能要暴露的 port，用來做文件使用，沒有實質的作用。因為 -p 會覆寫 port 設定。 若你有用私有 NPM，記得 RUN npm set registry http://127.0.0.1:4873 設定套件庫來源，且在 docker build 時可能要指定建置時的網路 (見下一節)。 執行建置映像檔 只要簡單下指令： docker build --network host -f=\u0026quot;Dockerfile\u0026quot; -t=\u0026quot;ithelp/backend:1.0.0\u0026quot; .\n這裡的\n--network host：使用私有 NPM 時要小心。設定建置時的網路為 host。 時，http://127.0.0.1:4873 才能訪問到 host 的私有庫。不然， http://127.0.0.1 會是建置時的沙盒環境。 -f：指要讀入的操作檔。當檔名是預設 Dockerfile ， -f 才可省。 -t：是映像檔的 tag。格式是 \u0026lt;repository name\u0026gt;:tag。 . 是指本機端當前的目錄。 用 docker images 查看是否有建立 測試是否可以執行後端映像檔 跟之前一樣， 用 docker run 建立並執行容器：\n1docker run --rm -p 3001:3001 --name ithelp.backend ithelp/backend:1.0.0 npm run start 然後就用瀏覽器開 http://localhost:3001，即可以訪問到後端。\n若你需要 detach 在背景運作，請自行加 -d 參數\n我們建立容器並執行，帶以下參數\n--rm ： 容器停止後自動刪除 -p : 外部 port 是 3001，容器內是 3001。這裡因為 npm run start 我們有設定 PORT=3001，所以後端會監聽 3001。 --name ：容器名 ithelp.backend。 npm run start ：這個緊接在映像檔 ithelp/backend:1.0.0 後，容器建立完後「執行容器」時要執行的指令(command)。 docker run 的格式如下： 1Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 因此，「COMMAND」 是 npm，「ARG\u0026hellip;」 是 run start。這就是我們不寫死 CMD [ \u0026quot;npm\u0026quot;, \u0026quot;start\u0026quot; ]的原因，希望可以保留執行指令的彈性。 下面指令也可以執行後端：\n1docker run --rm -p 3001:4000 --env PORT=4000 --name ithelp.backend ithelp/backend:1.0.0 node bin/www 這裡我們用 --env 參數設定環境變數 PORT，把後端的監聽port改成 4000，但因為對外 port 還是 3001，所以從瀏覽器還是用 http://localhost:3001 訪問後端，外界察覺不到容器內 4000 port 的存在。\n另外，你可能會想知道： bin/www 是從哪個目錄開始算的？ 這問題的答案就在建立映像檔時的 WORKDIR /usr/src/app，我們指定了當前目錄。 不過，當前目錄也可以在 docker run 用 --workdir 覆寫指定當前目錄。\n製作前端映像檔 製作方法大同小異，但這次我們程式碼不是前端的原始碼，而是 npm run build 打包後的檔案。\n打包前端程式，建立 Dockerfile 前端的打包後的檔案也要放在網頁伺服器，別人才能從瀏覽器訪問。我們使用 Nginx 網頁伺服器基底，它也要包入我們的前端映像檔。\n先進行打包 npm run build 它產生了一個 build 的資料夾，裡面放著打包後的所有檔案，所以這就是前端要發佈的所有檔案。 在根目錄建立 Dockerfile 1FROM nginx:1.15 2 3# Localtime 4ENV TZ=Asia/Taipei 5RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; echo $TZ \u0026gt; /etc/timezone 6 7# Nginx default public folder 8WORKDIR /usr/share/nginx/html 9 10# Copy public files 11COPY ./build . 12 13# Package (options) 14# RUN apt-get update 15# RUN apt-get install -y vim 16# RUN apt-get install -y curl 17# RUN apt-get install -y wget 建置前端映像檔 下指令： docker build -f=\u0026quot;Dockerfile\u0026quot; -t=\u0026quot;ithelp/frontend:1.0.0\u0026quot; . 建立並執行 跟之前一樣\n1docker run --rm -p 80:80 --name ithelp.frontend ithelp/frontend:1.0.0 若你需要 detach 在背景運作，請自行加 -d 參數\n小技巧：腳本化你的工作 每次製作映像檔都要先把前端打包，才能製作映像檔，可以將這些步驟寫在shell script 中。\n根目錄建立一個檔案 images.sh\n1npm run build 2docker build -f=\u0026#34;Dockerfile\u0026#34; -t=\u0026#34;ithelp/frontend:1.0.0\u0026#34; . 然後，在 package.json 的 scripts 加入 image 腳本\n1scripts: { 2 ...略 3 \u0026#34;image\u0026#34;: \u0026#34;sh images.sh\u0026#34; 4} 以後，只要 npm run image 就可以製作映像檔\n完成串接前後端 同時開啟前後端，即完成我們在 Day 11 - 一周目- 開始玩轉前端(二) 做的事：串接前後端。\n1# 後端 2docker run --rm -p 3001:3001 --name ithelp.backend ithelp/backend:1.0.0 npm run start 3 4# 前端 5docker run --rm -p 80:80 --name ithelp.frontend ithelp/frontend:1.0.0 POST /api/echo 是回應 500 耶？ 別怕，那是我們曾在 Day 19 - 二周目 - 帳密認証與JWT (JSON Web Token)傳遞 加入的 JWT 驗証。 總結 今天我們學會了打包屬於自己的前後端映像檔，並且執行它們完成前後端串接。\n雖然完成了前後端串接，但我們的後端其實還需要 mongoDB 才算是完整的服務。因此，明天將引入 docker-compose 這工具來組織我們的容器：ithelp.frontend 、ithelp.backend、mongo4\n","date":"2018-10-28","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-28-%E4%B8%89%E5%91%A8%E7%9B%AE-%E8%A3%BD%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%98%A0%E5%83%8F%E6%AA%94%E5%8C%85%E6%89%93%E5%89%8D%E5%BE%8C%E7%AB%AF%E6%98%A0%E5%83%8F%E6%AA%94/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 28 - 三周目 - 製作自己的映像檔：包打前後端映像檔"},{"categories":[],"content":"五分鐘建立私有 NPM: verdaccio\n回憶 昨天介紹 Docker 的基本使用，那些內容已足夠你下載映像檔並建立容器執行它們。\n目標 今天要使用 Docker 基本操作，安裝使用私有 NPM：verdaccio\nverdaccio 是一個輕量級的私有NPM proxy registry，你可以：\n發佈自己的私有套件，不用上傳到 npmjs 跟往常一樣下載 npm registry (https://registry.npmjs.org) 的套件，而不用刻意切換 registry 不同的專案可以使用同一個套件，以後更新只要重發佈套件，使用的專案只要 npm upgrade 就可以更新套件。 你的套件就有版本號管理 架設 verdaccio 伺服器並建立一個帳號 安裝 verdaccio 映像檔\n1docker pull verdaccio/verdaccio 執行 verdaccio 伺服器\n1docker run -d --name verdaccio -p 4873:4873 verdaccio/verdaccio 若不懂參數請見 Day 26 - 三周目 - Docker 基本使用：看完就會架 docker 化的服務\n用瀏覽器打開 http://localhost:4873，看到畫面就安裝完成了 之後的 npm 操作需要帳號登入，所以為 verdaccio 伺服器加入一個帳號\n1npm adduser --registry http://localhost:4873 接下來按照指示建立一個帳號就可以了 有了一個帳號才可以做登入網站、發佈的動作。\n我們接下來 npm 指令的動作都會加 --registry http://localhost:4873，這因為要指定使用我們 verdaccio 伺服器，不加的話就是預設的 https://registry.npmjs.org\n發佈套件 建立一個套件 mylog 我們隨便開一個 Node.js 專案叫 mylog\n開一個資料夾 mylog 並初始化 1npm init package.json 的內容如下： 1{ 2 \u0026#34;name\u0026#34;: \u0026#34;mylog\u0026#34;, 3 \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, 4 \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, 5 \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, 6 \u0026#34;scripts\u0026#34;: { 7 \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; 8 }, 9 \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, 10 \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; 11} 注意看 \u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;， 這行是指：當我們 const mylog = require('mylog') 的入口檔就是根目錄的 index.js。 建立兩個檔案，當作套件實作：lib 資料夾放實作的檔案 mylog.js， index.js 負責做對外的接口 lib/mylog.js 1function mylog() { 2 console.log(\u0026#39;mylog: \u0026#39;, ...arguments); 3} 4 5module.exports = mylog; index.js 1const mylog = require(\u0026#39;./lib/mylog\u0026#39;); 2 3module.exports = {mylog}; 發佈 接下來我們要登入帳號後才能發佈到 verdaccio 伺服器。只要登入過一次以後就不用了，除非你 npm logout 登出。\n登入 verdaccio 伺服器\n1npm login --registry http://localhost:4873 npm whoami --registry http://localhost:4873 可以確入登入帳號\n發佈\n1npm publish --registry http://localhost:4873 這樣就發佈完成了，刷新網站就會出現了 別人只要 npm install mylog --registry http://localhost:4873 就可以安裝私有套件。\n更新版號 當套件要更新，需要更新版號後，再發佈一次。\nnpm 使用 Semantic Versioning (版號是有語義的)。 見下表：\n程式碼狀態 階段(Stage) 規則 範例 用途 第一次釋出 New product 從 1.0.0 開始 1.0.0 第一次釋出套件 bug 修正且向後相容 Patch release 增加第三碼 1.0.1 微小的修正或更改 新功能增加且向後相容 Minor release 增加第二碼且第三碼重設成 0 1.1.0 新的功能出現或修正 可能會有無法向後相容 Major release 增加第一碼且第二、三碼重設成 0 2.0.0 可能有巨大的改變，可能無法向後相容 你可以手動改版號(改 package.json 的 version)，也可以用 npm version 指令：\n1`npm version [\u0026lt;newversion\u0026gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]` 例如：原來是 1.0.0，用 npm version minor 後就變成 1.1.0\n請注意，若你有用 git， npm version 除了改 package.json 的 version 還會 git commit\n改成版號後，請記得重新發佈 npm publish --registry http://localhost:4873。之後使用套件的人 npm upgrade \u0026lt;package\u0026gt; 就可以升級套件。\n發佈要注意 你可以加入 README.md 檔說明套件 不能重覆發佈同樣的版號，你的版號一般要遞增，雖然可以 unpublish 但還往上加比較單純。 好好決定你的版號，這會影響到用你套件的人，如何進行更新。 使用你套件的人若版號是從 1.0.4 開始，他可以在 package.json 中 dependencies 設定更新套件版號的範圍，例如： 1.0 或 1.0.x or ~1.0.4 : 表示只可以做 Patch releases 。如：1.0.5, 1.0.6 可更新， 1.1.0 不更新。 1 or 1.x or ^1.0.4：表示只可以做 Minor releases。如：1.0.5, 1.1.0 可更新， 2.0.0 不更新。 * or x：表示可以做 Major releases。任何版號都可以更新。 全域修改 registry 每次都要手動加 --registry http://localhost:4873，有點煩的話可以改成全局的。\n1npm set registry http://localhost:4873/ 原來 https://registry.npmjs.org/ 改成是 http://localhost:4873/。\n因為 verdaccio proxy registry，找到不的套件會自動去 npmjs 下載，你一樣可以下載到 npmjs 裡的套件。\n你也可以用 npm 組態檔，見 npmrc\n留下資料 因為是用容器執行，所以要留下資料要保留 verdaccio 容器的 storage 和 conf 資料夾，文件中沒有明寫在哪，我發現在容器中的：\n/verdaccio/conf /verdaccio/storage 請用 Day 26 - 三周目 - Docker 基本使用：看完就會架 docker 化的服務 的掛載 volume 的方法留下它們。\n總結 今天練習 Docker 的操作，實戰安裝私有 NPM registry。你可以重構你的程式，抽出可以重覆使用的套件，供自己或別人使用。\n參考資料 How to use Semantic Versioning ","date":"2018-10-27","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-27-%E4%B8%89%E5%91%A8%E7%9B%AE-%E4%BA%94%E5%88%86%E9%90%98%E5%BB%BA%E7%AB%8B%E7%A7%81%E6%9C%89-npm-verdaccio/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 27 - 三周目 - 五分鐘建立私有 NPM: Verdaccio"},{"categories":[],"content":"快速入門 Docker 的操作\n回憶 昨天介紹完了 Material-UI 後，整個二周目深入前後端也告一段落了，接下來我們要進到第三周目：發佈、維運篇。\n目標 今天的文章看完後我預期你就會：在本機端安裝並執行任何映像檔，可以架任何 dockerize (docker 化) 的服務，像 mysql, mongodb, nginx, apache …等。\n我們曾在 Day 15 - 二周目 - 用 Docker 玩轉 MongoDB 簡單的介紹 docker 及用它來架設 MongoDB。開始前我們假設你已經安裝 Docer Desktop，它的功能比較多。\n今天就來深入 Docker 的操作。\n下列的問題是我在學習 docker 時想問的問題，它們有順序性，由淺入深。\n怎麼執行執映像檔？ 怎麼開啟 port？ 怎麼留下資料？ 怎麼做自己的映像檔？ 怎麼同時啟動多個服務？ 多個服務之間怎麼通訊？它們的 IP 是什麼？ 你可以先想一下，我馬上就給出簡單的回答\n怎麼執行執映像檔？ docker run 怎麼開啟 port？ Compose file: port:, Container: -p XXXX:XXXX 怎麼留下資料？ Compose file: volumes:, Container: -v 怎麼做自己的映像檔？ Dockerfile 怎麼同時啟動多個服務？docker-compose 多個服務之間怎麼通訊？它們的 IP 是什麼？Compose file: networks:, Container: --network 完整的 docker 文件真的很龐大又難讀，所以我們只能介紹常用的東西。有了基本的認識和操作，再來自己深入研究。這也符合邊做邊學的原則。\nDocker 是什麼 Docker 的架構圖如下： 上圖截取自 Docker Reference Architecture: Designing Scalable, Portable Docker Container Networks\n容器(container) Docker 關鍵的技術是 容器(container)。 容器像是個沒有硬體環境的輕量虛擬機器，但與虛擬機器不同，它就像是執行在 host 的行程(process)，可能獨立網路、共享單一/多個網路或活在 host 的網路空間。容器的運作跟作業系統無關，因為它是運作在 Docker Engine上，不同的作業系統都有對應的 Docker Engine。 容器是映像檔的實際執行單位，它可以 run(建立並執行)/start(執行)/restart(重新執行)/stop(停止)/rm(移除)。\n當容器建立時，它會執行在一個沙箱環境，可以想像他有自己的檔案系統。另外，我們還可以為它裝上 network, volume。\nnetwork 是讓我們從此容器外部存取容器內的服務，可能是從 host (我們執行 docker engine 的環境，一般直接開 ternimal 的環境就是 host)，也可能是來自別的 container。\nvolume 是容器與別人共享的資料區，我們可以把資料放在裡面，可以：\n供在 host 存取 供其它 container 掛載(mount)使用，共享同樣的資料區 它是獨立於 container，當 container 移除時，volume 裡的資料一樣留下來。 映像檔(image) 映像檔打包著相關程式碼、函式庫、環境配置檔。總之，就是一群檔案集合。\n當要建立並執行 container 時一定要指定「唯一」的一個映像檔，如下格式\n1docker run \u0026lt;IMAGE\u0026gt; 其它的設定全部是可選，而有些本來就預設值，像 network 預設是 bridge。\ndocker run --help 可以看到一堆嚇人的設定 所以最基本的 Docker 有什麼單元? 由執行 container 出發，跟它有關的單元(包含自己)如下：\ncontainer image network volume 用 class diagram 來表達如下： 每個單元都可以獨立管理，一但被 container 關連就無法輕易刪除。你可以 docker --help 查看 Management Commands 有哪此單元可以管理。 若你要管理 container，鍵入 docker container --help 查看有哪些指令 更進一步，假如要建立 container， docker container create --help 查看指令怎麼使用 一般而言，不同的單元(針對實體)都有以下指令：ls、create、rm、prune、inspect。\nls：列出所有單元實體 create：建立單元實體 rm：刪除單元實體 prune：刪除未被(容器)使用的單元實體 inspect：這個很推薦用看看，查看單元實體的描述，例如用在容器就可以看到，它用的 network, volume之類的資訊 下載映像檔(image): nginx nginx 是用來架設網頁伺服器，我們以它為例子。\n在使用容器前一定要有映像檔(image)，你有以下方法可以取得：\nDocker Hub下載： 你可以想像它和 NPM 類似，它就是個公開(public)的 Repository 的集合，所有人都可以上傳下載某個 Repository 裡面的映像檔。假如你在 docker hub 找到 nginx repository，想要下載它們的映像檔，只要下指令 docker pull nginx (等於 docker pull nginx:latest) 就會下載 nginx 的映像檔。 完整個映像檔的格式是 \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; ，你可以指定下載的版本號 docker pull nginx:1.15。若沒有指定映像檔版本號就會下載最新版本 nginx:latest ，但要小心每個人的 latest 都不一樣，所以能的話還是指定一下版本號。\n自己做：這個 Day 28 再說\n我們實際下載 nginx:1.15 看看：\n1docker pull nginx:1.15 就完成了\n下載完的映像檔是由 docker 統一管理，要用 docker 指令才能管理\n常用映像檔管理 查看 docker 中所有映像檔： docker images ，它是 docker image ls 短語。可以用它查看是否下載映像檔。 刪除不要用的映像檔：docker rmi \u0026lt;id or image_name\u0026gt;，它是 docker image rm 短語 建立並執行容器: nginx_1 建立並執行容器指令: docker run 我們已經下載了 nginx:1.15 映像檔，接來來要建立容器並執行它。只要 docker run nginx:1.15 即可，但建立起來的容器名稱是 docker 亂數取名的，所以我們要加入 --name 參數(參數值用 \u0026ldquo;=\u0026rdquo; 或空白區隔)：docker run --name nginx_1 nginx:1.15，指令是指：\n1用 nginx:1.15 映像檔建立名為 nginx_1 的容器 建議容器要取名字，讓自己辨別\n但我們還是沒辨法訪問它，因為目前網路結構： 我們沒連入容器的方法，就像是沒辨法訪問監聽某個 port 的 process，因此要指定 port 號 (建立一個連通的 EndPoint)。因此，\n1docker run --name nginx_1 -p 8080:80 nginx:1.15 8080:80 就好像把 8080 port 放到 network(host) 中，當外部流量來的時後就從 8080 port 流到容器內的 80 port，所以外界不會察覺 容器 80 port 的存在。 接下來，打開瀏覽器，訪問 http://localhost:8080/，就會看到以下畫面： 訪問後，會看到 terminal 出現： 這是 nginex 的 console log。\n先等等，我怎麼會知道 nginx_1 容器內是開 80 port，每個映像檔的實現方法 (Dockerfile 內會寫 EXPOSE \u0026lt;port\u0026gt;)不一樣，使用方法也不一樣，要看映像檔的 docker hub repository 說明。\n到目前為止，我們建立了一個 nginx container，並執行它啟動網頁伺服器。\n移除容器 只需要把 ternimal 關掉(ctrl + c)後，http://localhost:8080/ 就訪問不到了。\n你可以用 docker ps(它是 docker container ls 短語)查看正在執行的容器，會發現 nginx_1 不在執行中的 container 中。若也要列出停止執行的容器，要加 --all (-a)，如 docker ps --all 或 docker container ls --all，才會看到它。\n當你不要 nginx_1 時，輸入\n1docker rm nginx_1 就可以刪除(它要先停止它才能移除)。\n讓容器在背景執行 若你已經建立好容器且假設它已經停止，如： STATUS 欄位中說他已經 exited 了。\n若你要讓容器再次執行 docker start \u0026lt;id or container_name\u0026gt;，\n1docker start nginx_1 之後再 docker ps，就會看到它 Up (running)。 容器的生命周期和指令關係如下圖(來自Lifecycle of Docker Container) 這時的容器就會在背景執行。可是這樣很麻煩阿!\n我們還有其它辨法，可以在建立並執行容器時脫離(detach) console log，只要加入 -d (--detach) 參數：\n1docker run --name nginx_1 -d -p 8080:80 -d nginx:1.15 因此我們有兩個方法可以讓容器在背景執行：\n建立好容器後，再次執行容器 docker start \u0026lt;id or container_name\u0026gt;。 建立並執行容器時立刻脫離。 若你希望在停止容器後自動刪除容器要加入 --rm 參數，如：docker run --name nginx_1 -d --rm -p 8080:80 nginx:1.15，就會在停止後自己刪除。\n常用容器管理 我們整理一下常用容器管理指令：\n用途 指令 常用可選參數 建立並執行容器 docker run --name, -d, -rm, -p 查看容器 docker ps --all 執行容器 docker start 停止容器 docker stop 刪除容器 docker rm Volume：獨立於容器的檔案空間 我們有時會希望：\n容器移除時檔案可以留下 - 資料庫類型的容器常會需要 host 的檔案可以在容器存取到 - 常用於共享 host 和 容器檔案 同個檔案可以在不同容器間共享 - 容器間可以用共用的組態檔 總之就是為了 「共用」和「留下」的目地，此時就要想到 : Volume\nvolume 在容器內要指定要掛入目標(target)，然後就可以在容器內使用。\nDocker 提供三種掛載類型(mount types)：\nbind mount：掛入現有的 host filesystem，用在容器 與 host 共享資料夾或檔案 volume：掛入 volume 實體 tmpfs mount：從 memory 掛載 上圖來自 Manage data in Docker 我們只提 bind mount 和 volume。\n與 host 共享(bind mount) 這是比較常用的，例如， nginx_1 要在根目錄多出一個資料夾 /mydata。在 建立容器 時，用 -v (--volume)參數指定要掛入的 host 資料夾(或檔案)及掛入在容器中哪個目標(位置)。直接看例子：\n1docker run --name nginx_1 -d -p 8080:80 -v /Users/eugenechen/mydata:/mydata nginx:1.15 這裡 /Users/eugenechen/mydata 是主機來源(可能是資料夾/檔案)，/mydata 是容器內要掛入的目標。\n一般情形下，容器必需重新建立，雖然有別的方法，但很麻煩。\n若要更多 volume 就多寫幾個 -v，如： -v /Users/eugenechen/mydata1:/mydata1 -v /Users/eugenechen/mydata2:/mydata2\n你可以放一些檔案在主機資料夾中，然後去看容器內的 /mydata 看有沒有檔案。\n\u0026ldquo;ternimal\u0026rdquo; 進入容器： docker exec 進入容器我們需要用到 docker exec 指令，它是在容器中執行指令，例如\n1docker exec -it nginx_1 bash 就是在 nginx_1 容器中執行 bash 指令。-it 分別是兩個參數 --interactiv 和 --tty，有興趣自己查。\n指令 docker exec -it \u0026lt;id or container_name\u0026gt; bash 用起來就像是在容器開一個 ternimal。\n驗証主機資料夾中檔案，出現在容器中 因此，我們就可以查看 /mydata 資料夾 若要離開就打 exit 指令。\n你可以自行驗証容器移除後，檔案還在\n掛載 Volume 實體 (volume) 前面是直接把 host 的來源(source)掛載到容器的目標(target)，另一個方法是建立一個 volume，再掛載到容器的目標。\n建立一個 volume 1docker volume create mydata2 在 建立容器 時，一樣用 -v，只是來源(source)改成用 volume name 1docker run --name nginx_1 -d -p 8080:80 -v /Users/eugenechen/mydata:/mydata -v mydata2:/mydata2 nginx:1.15 驗証容器移除後，檔案還在 進入容器，建立 hi_container.txt，離開 1# in host 2docker exec -it nginx_1 bash 3 4# in nginx_1 5cd mydata2/ 6touch hi_container.txt 7exit 刪除容器，再重新建立 1docker stop nginx_1 2docker rm nginx_1 3docker run --name nginx_1 -d -p 8080:80 -v /Users/eugenechen/mydata:/mydata -v mydata2:/mydata2 nginx:1.15 進入容器，會發現檔案還在 1# in host 2docker exec -it nginx_1 bash 3 4# in nginx_1 5ls /mydata2/ volume 小總結 -v 參數的格式是：-v \u0026lt;source\u0026gt;:\u0026lt;target\u0026gt;，source 可以來自 host 或 volume，不管來自哪都不會因為容器刪除而消失，並且 來自 host ：容器與 host 就可以共享檔案/資料夾， 來自 volume ：容器與 其它容器 就可以共享資料夾\n最後，重新整理常用容器管理表格，加入 -v：\n用途 指令 常用可選參數 建立並執行容器 docker run --name, -d, -rm, -p, -v 查看容器 docker ps --all 執行容器 docker start 停止容器 docker stop 刪除容器 docker rm 總結 常用指令如下：\n用途 指令 常用可選參數 下載映像檔 docker pull 刪除映像檔 docker rmi 建立並執行容器 docker run --name, -d, -rm, -p, -v 查看容器 docker ps --all 執行容器 docker start 停止容器 docker stop 刪除容器 docker rm 進入容器 docker exec -it \u0026lt;id or container_name\u0026gt; bash 建立 volume docker volume create 今天介紹了 docker 的基本元件：image, container, volumn，以及常用的指令。到目前為止，你應該會在本機端架任何 dockerize (docker 化) 的服務。\n未來我們在來談 network，它可以只讓特定容器放在某網路中，不需要限定安裝在本機端。\n","date":"2018-10-26","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-26-%E4%B8%89%E5%91%A8%E7%9B%AE-docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%9C%8B%E5%AE%8C%E5%B0%B1%E6%9C%83%E6%9E%B6-docker-%E5%8C%96%E7%9A%84%E6%9C%8D%E5%8B%99/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 26 - 三周目 - Docker 基本使用：看完就會架 Docker 化的服務"},{"categories":[],"content":"使用 Material-UI 的 component\n回憶 前面三天都是在談 Redux 關於前端的資料流，今天要談一個「非必要」的 react component 套件：Material-UI。它是Material Design 的 react 實作套件，它用來提供畫面的組件 (component)，像是 Button, Input, Dialog…等，充分地體現出 React component 讓我們以組件的概念組裝畫面。\n我們曾在Day 12 - 二周目 - 準備起程深入後端 中提到設計師做完設計稿後，會由一個前端工程師，做「切版」的工作，一般會寫出 HTML + CSS + Javascript。若前端框架採用 React，我們會把他們割一割封裝在各個 component，最後用 component 組裝畫面。\n然而，不是每家公司都有「切版」的工程師。若只是單純的做後台網站，沒有對廣大的用戶，就不會講求畫面多絢麗、使用者體驗多利害，所以就有這種已經做好的畫面樣式的 component 可以直接使用，像是：Material-UI(Google)，Ant Design (螞蟻金服)…等。\n目標 過程請見 github commit log\n使用 Material-UI 的 component 如何對為 component 加入css 樣式 如何用 Material-UI Grid 排版 使用 Material-UI Material-UI 功能特色：\n大量的基本 component 樣式(css style)注入系統：withStyles 這個 HOC(high order component)，可以注入/覆寫樣式 排版 component： Grid 安裝 Material-UI Material-UI 歷經多次的 API 改版，現在的套件變的比較有組識了，基本元件全放到 @material-ui/core 中\n複制 Day 23 - 二周目 - Redux 串接 React 與 Redux DevTools 的專案 hello-react 安裝 material-ui/core： 安裝 npm install @material-ui/core --save 安裝 material-ui/icons(可選)： 安裝 npm install @material-ui/icons --save, 這套件提供一些svg(Scalable Vector Graphics) icon 大量的基本 component 體驗一下 Material-UI 我們之前在 hello-react 中加入了一個 button 來發出一個 action，如圖 現在我們來換成 Material-UI Button。修改前試想一下，我們要改的是畫面，所以應該改哪個資料夾的檔案呢？actions/stores/reducers/components/containers 哪一個？ 若你之前有跟上文章的內容應該可以想到，答應就是\n1components 它是掌管畫面的資料夾，所以改 components/LoginBox.js\n1// components/LoginBox.js 2import React, { Component } from \u0026#39;react\u0026#39;; 3import Button from \u0026#39;@material-ui/core/Button\u0026#39;; 4 5class LoginBox extends Component { 6 render() { 7 return ( 8 \u0026lt;div\u0026gt; 9 message: {this.props.message} 10 \u0026lt;Button onClick={this.props.onClickSubmit}\u0026gt;Submit\u0026lt;/Button\u0026gt; 11 \u0026lt;/div \u0026gt; 12 ); 13 } 14} 我們把 html tag button，換成是 Material-UI component Button。存檔後就完成了，看結果 如何？很容易吧! 有沒有體驗到下面的感覺呢？\nFlux framework 資料夾結構的分類 React component 可以重構、組裝畫面 JSX 語法方便替換 html tag 這麼多 component, 要怎麼用 Material-UI？ 一打開 Component API 有沒有嚇一跳呢？要怎麼把它們組起來？ 其實，可以不用一個個查，常用的 Demo 都有人整理好了，只要開 Component Demos 選你要的畫面 Demo，然後找到 Show the source 按鈕 就可以查到原始碼了，再貼到自己的專案中，就可以用了。\n每個 Demo 頁面最下面還很貼心的附上相關的 API 連結，就可以進去看更多 component 用法。 樣式(css style)注入系統：「封裝 sytle」 或 「修改/替換樣式」 幾乎所有的 Demo code 最後面都會看到 withStyles 這個 HOC，如下圖： 這是那來封裝 sytle 或 overwrite style 用的，它的簽章如下：\n1styles =\u0026gt; component =\u0026gt; component 當 withStyles(styles) 時就是函數：\n1component =\u0026gt; component 它把 component (class) 送入，產生新的 component (class)。不僅如此，它還把注入的 styles，放在 classes prop 中，你就可以在 component 使用注入的 style。\n因為 withStyles 會把樣式注入 classes prop 中，所以 component 的 prop 定義 (propTypes) 要有 classes: PropTypes.object.isRequired。沒加入的話， Material-UI 也會警告你。\n封裝 sytle 注意看到 styles 是巢狀物件，屬性名是 css class name，屬性值是 CSS 物件 (見 CSS Object Model)。 透過 withStyles(styles)(Component) 後，它會把 css class name 也當做 classes prop 的屬性名但是 值是字串，也就是：\n1const styles = { 2 myRoot: { 3 backgroundColor: \u0026#39;red\u0026#39;, 4 } 5} 變成\n1this.props.classes.myRoot = \u0026#39;某個含有 myRoot 的字串的 css class name\u0026#39; 舉個使用 withStyles 例子：\n1const styles = { 2 myRoot: { 3 backgroundColor: \u0026#39;red\u0026#39;, 4 } 5} 6 7const Box = (props) =\u0026gt; ( 8 \u0026lt;div className={props.classes.myRoot}\u0026gt; \u0026lt;------ this.props.classes.myRoot 是字串，不是　styles.myRoot (CSS 物件) 9 hi 10 \u0026lt;/div\u0026gt; 11); 12 13const withStyleBox = withStyles(styles)(Box); 14 15// uasge: \u0026lt;withStyleBox /\u0026gt; 加載多個 style / 加載多個 class name 當你知道事實\n1this.props.classes.\u0026lt;style anme\u0026gt; = \u0026lt;string\u0026gt; 你會知道 component 如何加載多個 style：\n1const styles = { 2 myRoot: { 3 backgroundColor: \u0026#39;red\u0026#39;, 4 }, 5 myLayout: { 6 text: \u0026#39;center\u0026#39;, 7 } 8} 9 10const Box = (props) =\u0026gt; ( 11 \u0026lt;div className={props.classes.myRoot + \u0026#39; \u0026#39; + props.classes.myLayout}\u0026gt; \u0026lt;------ 就和加載多個 class name 一樣 12 hi 13 \u0026lt;/div\u0026gt; 14); 15 16const withStyleBox = withStyles(styles)(Box); 17 18// uasge: \u0026lt;withStyleBox /\u0026gt; 若你希望 props.classes.myRoot + ' ' + props.classes.myLayout 是動態的，可以使用 classnames 套件，有條件的控制名稱是否出現，如：\n1classNames({ [props.classes.myRoot]: true, [props.classes.myLayout]: true }); // =\u0026gt; props.classes.myRoot + \u0026#39; \u0026#39; + props.classes.myLayout 2classNames({ [props.classes.myRoot]: true, [props.classes.myLayout]: false }); // =\u0026gt; props.classes.myRoot 覆寫(overwrite) style: 修改/替換樣式 假如我們打開 Button，往下看到 CSS API 這就是你可以覆寫原始 component 樣式的 API。\n直接舉個官網例子：\n1const StyledButton = withStyles({ 2 root: { 3 background: \u0026#39;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)\u0026#39;, 4 borderRadius: 3, 5 border: 0, 6 color: \u0026#39;white\u0026#39;, 7 height: 48, 8 padding: \u0026#39;0 30px\u0026#39;, 9 boxShadow: \u0026#39;0 3px 5px 2px rgba(255, 105, 135, .3)\u0026#39;, 10 }, 11 label: { 12 textTransform: \u0026#39;capitalize\u0026#39;, 13 }, 14})(Button); 用 withStyles 就可以替換 root 和 label 原來的樣式。\n最後一個功能是：排版(layout)。\n排版 component：回應/響應式網頁(responsive web) Material-UI 和 bootstrap 一樣，它提供 Responsive API，只不過是 component 版本的。\nGrid 就是拿來做 responsive layout。它和 bootstrap 一樣採用 12-column grid layout(12欄網格系統)。\n不管螢幕大小，一個 row 就是被切成 12 欄，你要設定排版怎麼分配欄位數。直接看例子：\n1\u0026lt;Grid container className={classes.root} spacing={16}\u0026gt; 2 \u0026lt;Grid item xs={6} sm={4}\u0026gt; 3 A 4 \u0026lt;/Grid\u0026gt; 5 \u0026lt;Grid item xs={6} sm={4}\u0026gt; 6 B 7 \u0026lt;/Grid\u0026gt; 8 \u0026lt;Grid item xs={6} sm={4}\u0026gt; 9 C 10 \u0026lt;/Grid\u0026gt; 11\u0026lt;/Grid\u0026gt; 你就知道怎麼用了，更多例子見 Grid Demos。\n我們的心力還要花在設定 Breakpoints，每個 breakpoint 有固定的螢幕大小\n1xs, extra-small: 0px or larger 2sm, small: 600px or larger 3md, medium: 960px or larger 4lg, large: 1280px or larger 5xl, extra-large: 1920px or larger 以上面例子來說：\nxs 指的是當螢幕大於等於 0px 時要採用的「分配欄位數」，所以上面的結果是： 1A B 2C 因為 A 和 B 的 Grid 各佔了6欄，它們剛好就是一個 row，所以 C 的 Grid 就會在下一 row。 sm 指的是當螢幕大於等於 600px 時，結果是： 1A B C 因為 A 、 B 和 C 可以剛好放滿一個 row 共 12 欄。 Hidden component 有時你會需要只有特定的螢幕大小，component 才會要出現/隱藏，這時候可以用 Hidden component。\n文件中給個例子：\n1innerWidth |xs sm md lg xl 2 |--------|--------|--------|--------|--------\u0026gt; 3width | xs | sm | md | lg | xl 4 5smUp | show | hide 6mdDown | hide | show 若\n1\u0026lt;Hidden smUp\u0026gt; 2 ...may hidden dependent on screen size 3\u0026lt;/Hidden\u0026gt; 你的螢幕大小若大於等於 600px ，Hidden 內的東西就會隱藏。反之，小於 600px 時會顯示。\n若\n1\u0026lt;Hidden mdDown\u0026gt; 2 ...may hidden dependent on screen size 3\u0026lt;/Hidden\u0026gt; 你的螢幕大小若小於 1280px ，Hidden 內的東西就會隱藏。反之，大於等於 1280px 時會顯示。\n總結 今天介紹了 Material-UI 的常用功能\n基本 component 的使用 使用 withStyles 樣式注入 使用 Grid 操作12欄網格系統 當沒有人寫做切版時，Material-UI 是一個可選方案。若你想做的畫面很絢麗、酷炫或太過客製化的 component，請花時間在 HTML + CS + Javascript中。若你願意包成 component 提供別人使用(如：React Date Picker)，會有人感謝你的，\n參考資料 Material-UI 覆寫 Material-UI component CSS ","date":"2018-10-25","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-25-%E4%BA%8C%E5%91%A8%E7%9B%AE-react-component-%E5%A5%97%E4%BB%B6-material-ui-google-material-design-%E7%9A%84%E5%AF%A6%E4%BD%9C%E5%A5%97%E4%BB%B6/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 25 - 二周目 - React Component 套件 Material-UI： Google Material Design 的實作套件"},{"categories":[],"content":"介紹 Redux Middleware，實作同步/非同步 middleware\n回憶 前天我們介紹了Flux framework 套件 Redux，昨天實作 Redux 和 React 做串接，裡面提到不少概念：\nreducer： Redux 中實際存放 state 的單元 React Context: 任何地方的 subcomponent 中可以存取到的資料(store)，利用 react-redux 就可以方便把 Redux 和 React 串接 今天要談的是最後也最重要的東西： Redux Middleware\n目標 所有的範例程式放在 ithelp-30dayfullstack-hello-redux，有需要的請自取。\n學習完 middleware，我想當你在套用 Redux 相關套件 react-router-redux, connected-react-router、redux-thunk、redux-observable、redux-saga…等會有很大的信心和理解在做什麼。\nRedux Middleware 概念：本篇講的 middleware 都是指 Redux Middleware，除非有出現 express middleware 會特別指明是誰的 middleware。 實作同步 middleware logger 並學習套用 redux middleware 實作非同步 middleware PromiseMiddleware，讓你可以延伸 action 的結構、派分出非同步 action Redux Middleware Redux 也有 middleware，它類似 express middleware，我不得不說他更能難讓人理解，因為它是 higher-order function。不管理解到什麼程度，只要記得一件事：\nRedux middleware 內的實作要把 action 送到 next(action) 中\nRedux 在沒有引入 middleware 前的運作都是同步的，引入非同步的 middleware 就可以派分出非同步的 action。Redux Middleware 的威力很強，讓第三方的程式嵌入 Redux 的運作中。\nRedux Middleware 和 Express Middleware 有一點相似之處：\nExpress Middleware：處理 「request」 的 middleware， middleware 從 res, req, next 換到下一個 res, req, next middleware ，res、req 都是物件，呼叫 next() 換下一個 middleware 執行。 Redux Middleware：處理 「dispatch」 的 middleware, middleware 把 dispatch 產生一個新的 dispatch，dispatch 是(處理 action)函數，在它的實作中要把 action 送到 next(action) 中， next 是內層的 dispatch function。 文件是用 Flow notation定義，我也列出 JSDoc 定義，選你習慣的看\nFlow notation 1type Action = Object 2type AsyncAction = any 3type MiddlewareAPI = { dispatch: Dispatch, getState: () =\u0026gt; State } 4 5type BaseDispatch = (a: Action) =\u0026gt; Action 6type Dispatch = (a: Action | AsyncAction) =\u0026gt; any 7 8type Middleware = (api: MiddlewareAPI) =\u0026gt; (next: Dispatch) =\u0026gt; Dispatch JSDoc 1Action: object (含有 type 屬性) 2AsyncAction: any 3MiddlewareAPI: { dispatch: Dispatch, getState: () =\u0026gt; State } 4 5function BaseDispatch(a: Action): Action 6function Dispatch(a: Action | AsyncAction): any 7 8function Middleware(api: MiddlewareAPI): function(next: Dispatch): Dispatch 上面的 BaseDispatch 一般是指最內層的 dispatch function，會把 action 送到 reducer 中。由 Redux 提供，就是之前提的 store.dispatch。然而，一個 middleware 的作用，會在 store.dispatch 外層在套一個 dispatch function，類似：\n1const oldDispatch = store.dispatch // 留下舊的 dispatch function 2const newDispatch = action =\u0026gt; { 3 return oldDispatch(action); 4} 5store.dispatch = newDispatch; // 替換成新的 dispatch function 用 middleware 來演示就像：\n1const oldDispatch = store.dispatch // 留下舊的 dispatch function 2const middleware = dispatch =\u0026gt; { 3 const newDispatch = action =\u0026gt; { 4 return oldDispatch(action); 5 } 6 return newDispatch; 7} 8 9store.dispatch = middleware(oldDispatch); // 替換成新的 dispatch function 以上就是 redux middleware 期望要做的事。\n接下來，我們仔細的看 redux middleware 的簽章。 Middleware 會輸入一個 api 參數，回傳一個函數。 分別看它們的型態：\n「api」 是 MiddlewareAPI。它是一個物件，有 dispatch, getState 屬性。原始碼 表示只為了把做出包含 api 的閉包。 「回傳函數」 是function(next: Dispatch): Dispatch，送入 Dispatch 回傳 Dispatch，所以用箭頭函數寫實作就要出現型如： 1next =\u0026gt; { 2 return \u0026lt;Dispatch\u0026gt; 3} 主要是這個才是 middleware 的本體。若再把 \u0026lt;Deispatch\u0026gt; 打開 1next =\u0026gt; { 2 return (action) =\u0026gt; { 3 return \u0026lt;any\u0026gt; 4 } 5} 這才是我們真的要實作的 middleware。此時的 next 其實就是內層的 dispatch function。 為了方便理解 middleware 我們先不要管 api，就直接看真的要實作的 middleware(即作用完 api 的回傳函數)。\n簡化版 middleware 考慮兩個 middleware F,G 和 印出資料的 baseDispatch，這裡 F,G的簽章都是 function(next: Dispatch): Dispatch 所以它們可以串接，有兩種串法 F ● G 或 G ● F，我們只考慮 F ● G 合成，我可以得到最後的 dispatch function：\n1dispatchFG = F(G(baseDispatch)); 若把 action 送到 dispatchFG，就是\n1dispatchFG(action) = F(G(baseDispatch))(action) 令 dispatchF = F(G(baseDispatch))\n1F(G(baseDispatch))(action) = dispatchF(action) 就是說 action 會先被 dispatchF 作用。\n令dispatchG = G(baseDispatch)\n得到\n1F(G(baseDispatch))(action) = F(dispatchG)(action) Redux 要求：F 內的實作也要把 action 送到 dispatchG(action) 中 。\n若把 dispatchG 改叫 next 重寫上面一句話： F 內的實作也要把 action 送到 next(action) 中 。 因此，就得到重要的規則： Redux middleware 內的實作要把 action 送到 next(action) 中 這就和 express middleware 要求： Express middleware 內的實作一定要呼叫 next() 一樣\n1// mimicBasic.js 2/** 3 * 4 * @callback Dispatch 5 * @param {Action} action 6 * @returns {any} 7 */ 8 9/** 10 * 11 * @param {Dispatch} next 12 * @returns {Dispatch} 13 */ 14function F(next) { 15 return function dispatchF(action) { 16 console.log(\u0026#39;dispatchF\u0026#39;); 17 action = action + ` -\u0026gt; F`; 18 next(action); // next = dispatchG = G(baseDispatch) 19 }; 20} 21 22/** 23 * 24 * @param {Dispatch} next 25 * @returns {Dispatch} 26 */ 27function G(next) { 28 return function dispatchG(action) { 29 console.log(\u0026#39;dispatchG\u0026#39;); 30 // action 31 action = action + ` -\u0026gt; G`; 32 next(action); // next = baseDispatch 33 }; 34} 35 36/** 37 * 38 * @type {Dispatch} 39 */ 40function baseDispatch(action) { 41 console.log(action); 42} 43 44/** 45 * 合成 middleware F, G 46 * @type {Dispatch} 47 */ 48const dispatchFG = F(G(baseDispatch)); 49 50dispatchFG(\u0026#39;action\u0026#39;); 51console.log(\u0026#39;done\u0026#39;); 結果：\n1dispatchF 2dispatchG 3action -\u0026gt; F -\u0026gt; G 4done 圖解就是如下： (C) 是才是範例的圖，(B) 是只看 G 的作用，(A) 是沒有任何 middleware 的圖。(你可能需要花時間自己想圖的作用)\nRedux 原版 middleware 還原成 Redux 原來的定義，把 api 弄進來，最後再寫成箭頭函數，就是 Redux middleware 最完整的簽章。\n1// mimic.js 2const f = (api) =\u0026gt; next =\u0026gt; action =\u0026gt; { 3 console.log(\u0026#39;dispatchF\u0026#39;); 4 action = action + ` -\u0026gt; F`; 5 next(action); // next = g(api)(baseDispatch) 6}; 7const g = (api) =\u0026gt; next =\u0026gt; action =\u0026gt; { 8 console.log(\u0026#39;dispatchG\u0026#39;); 9 action = action + ` -\u0026gt; G`; 10 next(action); // next = baseDispatch 11}; 12const baseDispatch = (action) =\u0026gt; console.log(action); 13 14function applayMiddleware(f, g) { 15 const api = {}; 16 const G = g(api); 17 const F = f(api); 18 19 const dispatchG = G(baseDispatch); 20 const dispatchFG = F(dispatchG); 21 return dispatchFG; // F(G(baseDispatch)) = f(api)(g(api)(baseDispatch)) 22} 23 24const dispatchFG = applayMiddleware(f, g); 25 26dispatchFG(\u0026#39;action\u0026#39;); 27console.log(\u0026#39;done\u0026#39;); Redux middleware 小總結 Redux middleware 一定長成 (api: MiddlewareAPI) =\u0026gt; (next: Dispatch) =\u0026gt; Dispatch，才可以做合成 F ● G。\n我們觀察到：\nnext 是指內層的 dispatch function，因為 (F ● G(BaseDispatch))(action) = F(dispatchG)(action) = F(next)(action) Redux middleware 實作規定，一定要呼叫 next(action)，action 才能一直往內層送，不然就會斷掉，reducer 就收不到 action 了。 最後一個把 action 送到 reducer 的 dispatch 就叫做 BaseDispatch，它的一定是 action =\u0026gt; action，其它中間過程是 action 被改成長什麼樣子都可以，所以你才會看到 AsyncAction: any 這特別的定義。 middleware 的目地是把 dispatch function 合併成新的 dispatch function。 return next(action) 在非同步的 middleware 比較少用。 使用 Redux middleware: 同步 middleware logger 前面我們分析了 redux middleware，看不懂沒關係可能是我寫的不好 \u0026gt;\u0026lt;。\n只要記得一件事： Redux middleware 內的實作要把 action 送到 next(action) 中 這樣才能引起一連串的內部 dispatch function 運作。剩下的只要知道 middleware 簽章，你也可以寫出自己的 middleware。\n接下來，我們來套用 redux middleware 到 store 中，只需要 createStore() 中使用 applyMiddleware()。\n當沒有用任何 middleware 時，像\n1const store = createStore(reducer, initState); 此時的 store 的 dispatch function store.dispatch 是「某個 BaseDispatch 的實體」(我們暫時稱為 aBaseDispatch)，這是最內層的 dispatch function，內部會把 action 送入 reducer 中。\n假如，套用 logger middleware，\n1function logger({ getState }) { 2 return next =\u0026gt; action =\u0026gt; { 3 console.log(\u0026#39;will dispatch: \u0026#39; + JSON.stringify(action)); 4 5 // 送 action 到內層 dispatch function 6 const returnValue = next(action); 7 8 console.log(\u0026#39;state after dispatch: \u0026#39; + JSON.stringify( getState())); 9 10 // 在同步的 middleware 才有用 11 return returnValue; 12 } 13} 1const { createStore, applyMiddleware } = require(\u0026#39;redux\u0026#39;); 2const store = createStore(reducer, initState, applyMiddleware(logger)); 把 middleware 用到 store dispatch function 中，要用 applyMiddleware 這函數。 applyMiddleware(...middleware) 會回傳 enhancer，給 createStore 使用 (就是 enhancer(createStore) 變成新的 store)。 此時 store 的 dispatch function store.dispatch 的真實身份是 logger(aBaseDispatch)，\n若送出一個 action,\n1const action = { 2 type: identityChangeMessage, 3 payload: { 4 message: \u0026#39;change\u0026#39;, 5 }, 6} action 經過 logger middleare 會印出\n1will dispatch: {\u0026#34;type\u0026#34;:\u0026#34;CHANGE_MESSAGE\u0026#34;,\u0026#34;payload\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;change\u0026#34;}} 2state after dispatch: {\u0026#34;message\u0026#34;:\u0026#34;change\u0026#34;} 完整的程式見 middlewareSync.js\n寫自己的非同步 middleware：發出非同步 action 這裡雖然是自己做非同步 middleware 但只是學習用，除非你有獨到的見解或其它考量，否則還是建議使用 middleware 套件：redux-thunk、redux-observable、redux-saga。\npromise action : 帶有 promise 的 action 假設我們可以發出一個帶有 promise 的 action，例如：\n1const promiseAction = { 2 type: \u0026#39;CHANGE_MESSAGE\u0026#39;, 3 promise: Promise.resolve({message: \u0026#39;changed\u0026#39;}) 4} 5 6store.dispatch(promiseAction); PromiseMiddleware: 可以處理 pomise 的 middleware 我們需一個 middleware，它要做以下的事\n它可以判斷 action 是否是 promise action 若不是 promise action，不要做任何事，傳 action 到內層 middleware 做事 (即 return next(action)) 若是 promise action，它會為 action 加入三種狀態 (_TRIGGER, _SUCCESS, _FAIL) 觸發 action: CHANGE_MESSAGE_TRIGGER promise resolve: CHANGE_MESSAGE_SUCCESS，且 resolve data 放在 action.payload promise reject: CHANGE_MESSAGE_FAIL，且 reject error 放在 action.error 除了第一次的 trigger action，Promise 得到結果後也要引起 next(action) 讓內層 dispatch fuction 作用 把上述寫成程式\n1// PromiseMiddleware 2function PromiseMiddleware(action) { 3 return next =\u0026gt; { 4 return function dispatchAsync(action) { 5 if (action.promise instanceof Promise) { 6 console.log(\u0026#39;Promise action\u0026#39;); 7 const { type, promise, ...others } = action; 8 promise 9 .then(data =\u0026gt; { 10 next({ 11 type: success(type), 12 payload: data, 13 promise, 14 ...others 15 }); 16 }) 17 .catch(error =\u0026gt; { 18 next({ 19 type: fail(type), 20 error: error, 21 promise, 22 ...others 23 }); 24 }); 25 return next({ 26 type: trigger(type), 27 promise, 28 ...others 29 }); 30 } else { 31 console.log(\u0026#39;Not promise action\u0026#39;); 32 return next(action); 33 } 34 } 35 } 36} 修改一下之面的 logger 方便我們觀察 action\n1function logger({ getState }) { 2 return next =\u0026gt; action =\u0026gt; { 3 console.log(\u0026#39;========== action dispatching(start) ===============\u0026#39;); 4 console.log(\u0026#39;will dispatch: \u0026#39; + JSON.stringify(action)); 5 const returnValue = next(action); 6 console.log(\u0026#39;state after dispatch: \u0026#39; + JSON.stringify(getState())); 7 console.log(\u0026#39;========== action dispatching(end) ===============\u0026#39;); 8 return returnValue; 9 } 10} 使用 PromiseMiddleware 和 logger middlewares 接下來，使用 PromiseMiddleware 和 logger\n1const store = createStore(reducer, initState, applyMiddleware(PromiseMiddleware, logger)); 要小心，middleware 順序不能換，因為 promise action 要先進到　PromiseMiddleware　的 dispatch function（dispatchAsync） 作用， action 才能進到內層的 logger 中 dispatch function 印出。\n你也可以試試看順序倒過來會怎麼樣。\n發出一個 promise action 定義一個 promise action\n1const identityChangeMessage 2// Case 1: 建立一個 resolve action 3const resolvePromiseAction = { 4 type: identityChangeMessage, 5 promise: Promise.resolve({ 6 message: \u0026#39;changed\u0026#39;, 7 }) 8}; 派分 promise action\n1store.dispatch(resolvePromiseAction); 結果如下：\n1========== action dispatching(start) =============== 2will dispatch: {\u0026#34;type\u0026#34;:\u0026#34;CHANGE_MESSAGE_TRIGGER\u0026#34;,\u0026#34;promise\u0026#34;:{}} 3state after dispatch: {\u0026#34;message\u0026#34;:\u0026#34;identityChangeMessage trigger\u0026#34;} 4========== action dispatching(end) =============== 5waiting... 6========== action dispatching(start) =============== 7will dispatch: {\u0026#34;type\u0026#34;:\u0026#34;CHANGE_MESSAGE_SUCCESS\u0026#34;,\u0026#34;payload\u0026#34;:{\u0026#34;message\u0026#34;:\u0026#34;changed\u0026#34;},\u0026#34;promise\u0026#34;:{}} 8state after dispatch: {\u0026#34;message\u0026#34;:\u0026#34;changed\u0026#34;} 9========== action dispatching(end) =============== 我們發現產生了兩個 action，action type 分別是 CHANGE_MESSAGE_TRIGGER, CHANGE_MESSAGE_SUCCESS，這也符合 Promise 的運作過程，就像是我們模擬 Redux 版本的 fetch() request。當派分 promise action 後，在 reducer 就要收到一個 _TRIGGER 的 action，然後取回資料後，reducer 就要收到一個 _SUCCESS 的 action。\nreject promise action 和 normal action 的完整的範例見 middlewareAsync.js\n總結非同步的 middleware：PromiseMiddleware 非同步的 middleware 有下列的特性：\n新形態的 action：它讓我們可以派分 promise action 這種新形態的 action，例如：在 PromiseMiddleware 中解讀 promise action, 就可以產生其它 action 來模擬 Promise 的運作過程。 派分任意次 action：我們可以派分任意多次的 next(action)，就像我們發出了二個 actions 實務上，在發出 某 action 後可能又要發出其它 action，如下圖 雖然這大量產生的 action 讓人有點詬病，但使用良好的非同步 action 套件，可以一定程度控制我們的程式碼，避免程式碼混亂。\naction 自由性：next(action) 中的 action 可以在 middleware 中任意建立、修改、更換，例如：我們建立新的 action {type: success(type), payload: data, promise, ...others} ( action type 加入後綴詞) Redux 生態系 Redux 是很小的套件，以它為核心已經發展出大量的相關套件，當然你想要什麼功能除了自己實作，也可以用別人的套件。\n我的學習方法是先自己試寫看看體驗一下痛苦，再套用大神們的套件，因為自己臨時寫的 API 我不覺得會比大神們經過時間粹煉的套件好用、穩定。\nRedux 生態系列表如下：\nRedux exosystem(offical)：裡面可以看到套件程式碼火力展示 Redux 生態系(中文)：當功能的英文關鍵字都不知道就可以查看看 我還是可以小小的註解一下：\n非同步 middleware 套件：用來發出非同步 action 的套件 redux-thunk：我第一個用的非同步 middleware 套件。它的原始碼很簡單，把 action 結構改成一個函數(物件)，然後派分函數 action。我覺得 action 連發、維護不太好處理，我就轉為 redux-observable。 redux-observable：要用 reactive programming 的概念，RxJS 是 javascript 的 reactive programming 實現套件。 redux-observable 把它們引入 Redux 中。 redux-saga：使用 ES6 的生成器函式(generator function)/ yield 語法不用學新的語法。\nRouting：頁面切換 react-router 是 react compoent 套件，用來依照網址選擇要渲染的 component。它是 React 相關套件，它與 redux 沒關西。\n因為篇福有限，我只點出一件很重要的事： 使用 react-router 要小心版本號\n若你要用 react-router 4.x 請用以下組合：\nhistory： react-router 4.x connected-react-router 若你要用 react-router 2.x and 3.x 請用以下組合：\nreact-router 2.x and 3.x react-router-redux 總結 今天主要介紹 Redux Middleware，並分別給出了同步和非同步的 middleware 的範例 logger 和 PromiseMiddleware，並在建立 store 時使用 middleware，最後以Redux 生態系為結尾。\n","date":"2018-10-24","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-24-%E4%BA%8C%E5%91%A8%E7%9B%AE-redux-%E5%A6%82%E4%BD%95%E7%99%BC%E5%87%BA%E9%9D%9E%E5%90%8C%E6%AD%A5-action%E5%BC%95%E5%85%A5%E9%9D%9E%E5%90%8C%E6%AD%A5-middleware/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 24 - 二周目 - Redux 如何發出非同步 Action：引入非同步 Middleware"},{"categories":[],"content":"實作 Redux 與 React 的串接\n回憶 昨天介紹了 Flux 架構和它的實作套件 Redux。最後我們寫了簡單的 Redux 程式，體驗 Redux 如何運作。以 Flux 架構圖來說， 昨天的內容是 今天我們要專注在與 React 的串接 目標 實作 Redux 與 React 的串接 安裝 Chrome extension Redux DevTools 確認 Redux 有運作 過程請見 github commit log\nRedux 與 React 的串接 我們實際引入 Redux 到之前的 hello-react 專案中\n安裝 redux： 建立 Reducer, Store 複制 Day 11 - 一周目- 開始玩轉前端(二) 的專案 hello-react\n安裝 Redux： npm install redux --save\n建立 RootReducer.js，放在 reducers/RootReducer.js\n1// reducers/RootReducer.js 2const initState = {}; 3const reducer = (state = initState, action) =\u0026gt; { 4 const {type} = action; 5 switch (type) { 6 default: 7 return state; 8 } 9}; 10 11export default reducer; 這裡我們建立了一個 RootReducer，不打算合併其它的 reducer。若你需要更有結構的 state，你可以用 combineReducers 合併多個 reducer。以 const rootReducer = combineReducers({ login: LoginReducer, account: AccountReducer,}) 來說， state 是巢狀物件，它有 login、account 分別可以索引到 LoginReducer、AccountReducer 裡面的 state。\n開一個 stores 資料夾，建三個檔案 configureStore.js、configureStore.prod.js、configureStore.dev.js\n1// stores/configureStore.js 2if (process.env.NODE_ENV === \u0026#39;production\u0026#39;) { 3 module.exports = require(\u0026#39;./configureStore.prod\u0026#39;); 4} else { 5 module.exports = require(\u0026#39;./configureStore.dev\u0026#39;); 6} 7 8// stores/configureStore.prod.js 和 stores/configureStore.dev.js 9import { createStore } from \u0026#39;redux\u0026#39;; 10import RootReducer from \u0026#39;../reducers/RootReducer\u0026#39;; 11 12export function configureStore(initialState) { 13 const store = createStore( 14 RootReducer, 15 initialState, 16 ); 17 return store; 18} 我們未來只要 import {configureStore} from 'stores/configureStore' 就可以依照環境變數 NODE_ENV，選用 store。因為是同樣的程式碼，當 Redux DevTools 引入時就會不一樣。\n安裝 react-redux：把 Store 送入 View 中 之前只安裝了 Redux 的 Reducer　和 Store，但最後我們要把 Store 送到 Controller-View 中，這樣 Controller-View 才可以用 store 拿出 state (store.getState()) 和 dispatch action (store.dispatch(action))。\nReact Context：component tree 中任何地方都可以拿到的值 為了完成這件事要用到 React Context，這是由 React 提供的，它的功用是在 component tree 中的上層把值送入後，底下的所有 subcomponent 任何一層都可以拿的到這值，而不用一個個傳遞下去。\n舉官方例子： (A)圖是本來的 component tree, 假設有個 theme value 要從 App 送 到 ThemedButton 中，用 Context API 後邏輯上就是 (B) 圖，實際使用Contenx API 就是 (C)圖。\n1// 建立一個 Context 2const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); 3 4class App extends React.Component { 5 render() { 6 // 使用 ThemeContext.Provider 把值送入 7 return ( 8 \u0026lt;ThemeContext.Provider value=\u0026#34;dark\u0026#34;\u0026gt; 9 \u0026lt;Toolbar /\u0026gt; 10 \u0026lt;/ThemeContext.Provider\u0026gt; 11 ); 12 } 13} 14 15// 這是中間層的元件，不用把值送到 \u0026lt;ThemedButton/\u0026gt; 中 16function Toolbar(props) { 17 return ( 18 \u0026lt;div\u0026gt; 19 \u0026lt;ThemedButton /\u0026gt; 20 \u0026lt;/div\u0026gt; 21 ); 22} 23 24// 這是下層的元件，只要用 ThemeContext.Consumer，就可以取出值 25function ThemedButton(props) { 26 return ( 27 \u0026lt;ThemeContext.Consumer\u0026gt; 28 {theme =\u0026gt; \u0026lt;Button {...props} theme={theme} /\u0026gt;} 29 \u0026lt;/ThemeContext.Consumer\u0026gt; 30 ); 31} 回到 Redux，一般來說我們也要做類似的事情，但有大神們開發了 react-redux 套件幫我們把 Store 送入 View 中，我們甚至不會察覺到 context 的存在。\nreact-redux： 串連 redux 和 react react-redux 提供兩個好用的函數：\nProvider：我們再也不用建立 Context，直接用庫提供的Provider \u0026lt;Provider store={store}\u0026gt; 送入 store connect(mapStateToProps, mapDispatchToProps)(component)：連接 state 到 component props 和連接 「dispatch行為」 到 component props (指事件的 callback props, ex: onClickButton，要執行派發 action)。 更明確地說，這 API 結果就是回傳 \u0026lt;component {...mapStateToProps()} {...mapDispatchToProps()} /\u0026gt; 其實， connect 是 high-order component (HOC)，它輸入 component 送出 component。見重構 React component 邁向 Prue/Container component 和 HOC\n開始套用吧~\n把 store 注入 component tree 安裝 react-redux：npm install react-redux --save 找到 Component 的入口 ./index.js，建立 store，放入　\u0026lt;Provider store={store}\u0026gt; 1// index.js 2import { Provider } from \u0026#39;react-redux\u0026#39;; 3 4ReactDOM.render(( 5 \u0026lt;Provider store={store}\u0026gt; 6 \u0026lt;App /\u0026gt; 7 \u0026lt;/Provider\u0026gt; 8), document.getElementById(\u0026#39;root\u0026#39;)); 建立第一組 Container/ Pure component: LoginBox Controller-View (component) 雖然沒有存 state，但它與 store 串連，所以它邏輯上來看就好像有自己 state，所以也可以稱為 Container。反之，完全沒有 state 的 component，被稱為 Pure component。\n建立 components/LoginBox.js 1import React, { Component } from \u0026#39;react\u0026#39;; 2class LoginBox extends Component { 3 render() { 4 return ( 5 \u0026lt;div\u0026gt; 6 message: {this.props.message} 7 \u0026lt;/div \u0026gt; 8 ); 9 } 10} 11export default LoginBox; 建立 containers/LoginBox.js 1import { connect } from \u0026#39;react-redux\u0026#39;; 2import LobinBox from \u0026#39;../components/LoginBox\u0026#39; 3const mapStateToProps = (state) =\u0026gt; { 4 return {}; 5}; 6 7const mapDispatchToProps = (dispatch) =\u0026gt; { 8}; 9 10export default connect( 11 mapStateToProps, 12 mapDispatchToProps 13)(LobinBox); 在 App.js 中使用 LoginBox Container 1import LoginBox from \u0026#39;./containers/LoginBox\u0026#39; 2class App extends Component { 3 render() { 4 return ( 5 \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; 6 Hello React: {this.state.name} 7 \u0026lt;LoginBox /\u0026gt; 8 \u0026lt;/div \u0026gt; 9 ); 10 } 11} 加入 message state：配置空間和設定預設值 因為 LoginBox container 的 message 的值我們還沒有設定，所以你打開 npm run start，只會看到 在 RootReducer 中設定 message state 變數和它初始的值 1// reducers/RootReducer.js 2const initState = { 3 message: \u0026#39;init message\u0026#39;, 4}; 5...略 在 LoginBox container 指定要使用這 state 1// containers/LoginBox.js 2const mapStateToProps = (state) =\u0026gt; { 3 return { 4 message: state.message, 5 }; 6}; 7...略 這裡的 state 就是 store 中全部的 state，就是 RootReducer 中定義的 state。 connect(...)(LoginBox) 就好像把 message 送入 LoginBox pure component, ex: \u0026lt;LoginBox message={state.message} /\u0026gt; 結果如下： 加入行為 假如我們按一個 Button 就要改變 message 的值。\n在 LoginBox 加入一個 Button 和定義一個 onClickSubmit callback\n1class LoginBox extends Component { 2 render() { 3 return ( 4 \u0026lt;div\u0026gt; 5 message: {this.props.message} 6 \u0026lt;button onClick={this.props.onClickSubmit}\u0026gt;Submit\u0026lt;/button\u0026gt; 7 \u0026lt;/div \u0026gt; 8 ); 9 } 10} 開一個 actions 資料夾，建立 LoginBoxActions.js\n1export const identityOnClickSubmit = \u0026#39;identityOnClickSubmit\u0026#39;; 2 3export function onClickSubmit(data) { 4 return { 5 type: identityOnClickSubmit, 6 payload: data, 7 }; 8}; 我們很刻意的把資料放到 playlod 中(叫 data 也可以)，這不是一定要這麼做，只是為了保留最外層是 action 的專用屬性，防止 data 內也有 type 屬性干擾 action 最外層屬性。另外也有個好處，data 是陣列時，就有通用屬性名 playlod 可以取出陣列。\n在 LoginBox container 指定要使用 onClickSubmit 來派分(dispatch)一個 action\n1...略 2const mapDispatchToProps = (dispatch) =\u0026gt; { 3 return { 4 onClickSubmit() { 5 dispatch(actions.onClickSubmit({message: \u0026#39;clicked\u0026#39;})); 6 } 7 } 8}; 9...略 RootReducer 要監控這個 action (即 identityOnClickSubmit)\n1import * as actions from \u0026#39;../actions/LoginBoxActions\u0026#39;; 2...略 3const reducer = (state = initState, action) =\u0026gt; { 4 const {type, payload} = action; 5 switch (type) { 6 case actions.identityOnClickSubmit: { 7 const {message} = payload; 8 return Object.assign({}, {message}); 9 } 10 default: 11 return state; 12 } 13}; 結果如下： 按下Submit，message 改變了 最後看一下我們做了什麼？我們建了 Sore/Action/Container/Components 資料夾，來附合 Flux 架構，大部分 Flux 架構的前端專案都有類似的資料夾 在網頁中如何確認 Redux 有運作 Redux DevTools 用來看 Redux 運作，更明確的說，它在監控「dispatcher 和 action 的運作」及「action 如何影響 state」。馬上來試試看：\n下載 Chrome extension Redux DevTools createStore() 中加入 store enhancer 1// stores/configureStore.dev.js 2import { compose, createStore } from \u0026#39;redux\u0026#39;; 3import RootReducer from \u0026#39;../reducers/RootReducer\u0026#39;; 4 5const composeEnhancer = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose 6 7export function configureStore(initialState) { 8 const store = createStore( 9 RootReducer, 10 initialState, 11 composeEnhancer() 12 ); 13 return store; 14} createStore(reducer, initialState, enhancer)第三個參數是 enhancer，拿來套用第三方的套件，修改 store creator，它是 hight-order function，它結合 store creator 成為另一新的 store creator。 store enhancer 簽章如下：\n1function StoreEnhancer(next: StoreCreator): StoreCreator createStore(reducer, initialState, enhancer) 就像是 enhancer(createStore)(reducer, initialState)，enhancer(createStore) 變成新的 store creator。(見原始碼)\ncompose() 是拿來以合併 store enhancer 用的。舉個例子：compose(Enhancer1, Enhancer2)(createStore) =\u0026gt; Enhancer1(Enhancer2(createStore))\n開啟 Chrome DevTools(空白處右鍵 Inspect)，Redux 頁籤 一開啟網站的狀態 按下 Submit 後發出 action (action type 是 identityOnClickSubmit) Redux DevTools 有三種模式\nLog monitor：用來看 action log Inspector：最完整的模式。能看 Action/State/Diff/Test，但這模式太大型的網站可能會很慢或當掉 Chart：state 的結構圖。 redux 的串接(combineReducers()) 會讓 state 是巢狀 object，這模式可以看 state 結構和各個 state 值。 每個模式都有它特別的地方，自己玩看看。\n總結 今天我們實際串接 Redux 和 React，利用 react-redux 套件，就不需要自己寫 React Context。為了確保有運行，我們還裝了 Chrome extension Redux DevTools，可以查看 Redux 的運作。\n","date":"2018-10-23","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-23-%E4%BA%8C%E5%91%A8%E7%9B%AE-redux-%E4%B8%B2%E6%8E%A5-react-%E8%88%87-redux-devtools/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 23 - 二周目 - Redux 串接 React 與 Redux DevTools"},{"categories":[],"content":"介紹 Flux framework 和 Redux\n回憶 昨天介紹了 React 的基本概念 state/prop，它們是控制畫面渲染的變數。然而 component 的 state/prop 混合使用會使渲染邏輯變的混亂。\n考慮登入畫面： 把 username 和 password 分成兩個 component後，關於 hide 值就有二種可能的 component tree 設計。\n(component tree 1) 放在 password component 中的 state (component tree 2) 放在最上層 component 中的 state，然後在送到 password component 的 prop 假如當使用者按下 SIGN IN 時，希望密碼是隱藏的也就是 hide 需要更動。因為 SIGN IN 是在最上層的 component， 在上面 component tree 1 就會有設定上的困難(因為 state 是在 password component 內部)，component tree 2 反而沒有。\n試想當你的 component tree 更大時，你應該怎麼管理那些 state 呢？ 目標 今天會介紹 Flux framework 和 Redux。\n我覺得不要一開始就想要馬上把 Redux 和 React 串起來，因為你會誤以為 Redux 很複雜。我在本篇未會給出一個直接運作 Redux 的 Node.js 專案，裡面只有一隻程式，執行過程就是 Redux api 的最簡單的範例。\n明天才會把 Redux 和 React 串起，你會看到 store, action 被拆到不同的檔案。\nFlux framework Facebook 提出了 Flux framework(或稱架構)，來處理 state 和 prop 的混亂。\nFlux 的核心思想 Flux 希望資料的流動是單一的 (單向資料流)，使用者行為會產生 Action 送入 Dispatcher，Dispatcher 會把 Action 派分到「有註冊要監聽Action的 Store」，然後 Store 依照 Action 的 識別字串 決定如何修改 state，當 Store 修改完 state，會發出 change 訊息。最後， 註冊 change 訊息的 View ，收到來自 Store 的通知，就會執行 setState() 更新畫面(更新內部的component)。\n它的流程如下： Action：一次修改 state 的行為 Dispatcher：分派 Action 到 Store 的單元 Store：實際存 state 的單元 View：接收 state 並渲染畫面 Flux 的特性 資料流動的框架：從 Flux 流程上看， Flux 和 React 其實是沒有關連性的，因為它是提出資料流動的框架，跟畫面渲染無關。 單向資料流：要修改 state 沒有其它方法，只能引起一個 Action 單元非指向性：每個區塊都是獨立運作的，像是： 一個 Dispatcher 能被多個 Store 註冊、不同 View 可以監聽不同的 Store，任一個單元想接誰就接誰，沒有限定某一個store 只能接某一個 view。 我們注意看到「註冊 Store 的(change)訊息的 View」，它是 state 值流入的第一個 view，被稱成 Controller-View 它負責連結 Store 取出 state 值和引起 setState()，然後送入裡面的 view (即內部 view 的 props)。最後的架構圖如下： Flux 的實現套件 以下三個都是 Flux 的實現套件，他們的 API 用法和特性有很大的差異\nFacebook Flux：因為保留了Flux「非指向性」的特性，要做比較多 Flux API 串接的操作，用起來不太方更。用法可以看 Flux 架構入門教程。 Alt：隱藏 Dispatcher 的概念，直接把 Action 綁定(bind) 在 Stroe 中，所以 Flux API 串接較方便。用法看官網5分鐘上手就可以了。 Redux：簡化 Flux 完整的概念，API 不多，是我們要用的 Redux 的特性 原本的 Flux Store 和 View 的關係下圖(截錄淺談 React、Flux 與 Redux) 然而 Redux 簡化 Flux 的概念，變成 (截錄修改淺談 React、Flux 與 Redux) 只有一個 Store：所有 state 放在一個全局的 store 中。這也是最大的差別，不同於 Flux Store 可以有多個 Store，它們各自為戰。 只有一個 Dispatcher：因為只有一個 Store ，所以全局也只需要有一個 dispatcher，它被隱藏在 store 中。只需 store.dispatch(action) 就可以引發分派 action。 引入 Reducer 概念： 實際存放 state 的地方 store 收到 action 時，reducer 會依照 action type 處理 state 的改變 reducer是純函數(pure function)：同樣的輸入會有同樣的輸出 1const initState = {}; 2const reducer = (state = initState, action) =\u0026gt; { 3 const {type, ...actionData} = action; 4 switch (type) { 5 default: 6 return state; 7 } 8}; 只有一個根 reducer 對應 controller-view，其它的 reducer 會被合併，一同管理整個 store。 1// Reducer configuration 2const rootReducer = combineReducers({ 3 login: LoginReducer, 4 account: AccountReducer, 5}); 注意：這裡不是說只能有一個 controller-view，subcomponent 也能是 controller-view\n所以 Reducer 簡化 Flux 完整的概念，更容易使用。\n體驗 Redux 的運作 Redux 是資料的流動，是改變 state 的框架，最後的 state 給誰用跟它沒有關係，View 是與它無關。因此，React 跟它的運作是沒有關係的。我們可以開一個 Node.js 來運作體驗 Redux。\n開一個空的 Node.js 專案，取名為 hello-redux 初使化專案 npm init後，安裝 redux npm install redux --save 建一個 hello-redux.js 檔案 初使化 Redux，建立 store。我們假設 store 有一個 message state。 建立 store 需要一個 root reducer，而 root reducer 當收到某個 action 後，會看 action type 修改 state 1const {createStore} = require(\u0026#39;redux\u0026#39;); 2 3// 定義 action type 4const identityChangeMessage = \u0026#39;CHANGE_MESSAGE\u0026#39;; 5 6// 建立一個 Reducer 7const initState = { 8 message: \u0026#39;init message\u0026#39;, 9}; 10const reducer = (state = initState, action) =\u0026gt; { 11 const {type, payload} = action; 12 switch (type) { 13 case identityChangeMessage: { 14 const {message} = payload; 15 return Object.assign({}, {message}); 16 } 17 default: 18 return state; 19 } 20}; 21 22// 建立一個 Store 23const store = createStore(reducer); 印出初始的 state：store.getState()可以取出目前的 state 1// 印出初始的 state 2console.log(store.getState()); 建立 action 1// 建立一個 action 2const action = { 3 type: identityChangeMessage, 4 payload: { 5 message: \u0026#39;change\u0026#39;, 6 }, 7} 這裡我們要強調，在 Redux 中： 一個 action 是一個 object，一般會帶有 type 屬性。 一個 action creator 是產生 action 的函數，如: 1function changeMessage(data) { 2 return { 3 type: identityChangeMessage, 4 payload: { 5 message: data, 6 }, 7 } 8} 分派(dispatch) action 1store.dispatch(action); 分派 action 出去後，reducer 會收到 action，然後依照 action type (identityChangeMessage) 修改 state 印出收到 action 後，被 reducer 修改的 state 1console.log(store.getState()); 執行 node hello-redux.js 的結果：\n1{ message: \u0026#39;init message\u0026#39; } 2{ message: \u0026#39;change\u0026#39; } 總結 今天介紹了 Flux 的基本概念和實現它的套件 Redux，也寫了簡單的程式體驗 Redux 的運作。明天就把 Redux 和 React 串接起來。\n附錄 完整的 hello-redux.js 1const {createStore} = require(\u0026#39;redux\u0026#39;); 2 3// 定義 action type 4const identityChangeMessage = \u0026#39;CHANGE_MESSAGE\u0026#39;; 5 6// 建立一個 Reducer 7const initState = { 8 message: \u0026#39;init message\u0026#39;, 9}; 10const reducer = (state = initState, action) =\u0026gt; { 11 const {type, payload} = action; 12 switch (type) { 13 case identityChangeMessage: { 14 const {message} = payload; 15 return Object.assign({}, {message}); 16 } 17 default: 18 return state; 19 } 20}; 21 22// 建立一個 Store 23const store = createStore(reducer); 24 25// 印出初始的 state 26console.log(store.getState()); 27 28// 建立一個 action 29const action = { 30 type: identityChangeMessage, 31 payload: { 32 message: \u0026#39;change\u0026#39;, 33 }, 34} 35 36// 分派(dispatch) action 37store.dispatch(action); 38 39// 印出收到 action 後，被 reducer 修改的 state 40console.log(store.getState()); ","date":"2018-10-22","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-22-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E8%A7%A3%E9%96%8B-stateprop-%E7%9A%84%E6%B7%B7%E4%BA%82flux-%E5%96%AE%E5%90%91%E8%B3%87%E6%96%99%E6%B5%81%E6%9A%A8-redux-%E9%AB%94%E9%A9%97/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 22 - 二周目 - 解開 State:prop 的混亂：Flux 單向資料流暨 Redux 體驗"},{"categories":[],"content":"React 快速入門\n回憶 昨天我們以非同步函數測試的例子說明單元測試/整合測試的差異，到目前為止後端的部分打算先到這。之後的幾天，我們開始進入研究前端。\n目標 在 Day 11 - 一周目- 開始玩轉前端(二) 中，我們用 create-react-app 建立了前端專案，並打出非同步的 request 向後端索取資料。\n如何找專案結構 React 必需知道的事 state 和 prop 的差異 React component lifecycle (生命周期) React 的效能議題 小心的在 render() 中用箭頭函數 key 屬性在動態的 react element array 應該要使用 如何找專案結構？ 我們用 create-react-app 建立了前端專案，它幫我們產生了專案，資料夾如下： 顯然只有基本的結構，我們未來要組織出自己的結構。\n除了自己組識，上網找別人做好的也是個不錯的選擇，很多人會把初始專案結構放在 github 之類的，不過你得先知道你想要的組合套餐\nBundle tool： webpack / gulp UI framework: React / Vue.js State container: Redux / Vue.js Asynchronous flow: redux-observable(rxjs) / redux-saga CSS extension: sass / less\n每個套件都有自己的特色、能不能搭配的問題、全部套件怎麼串起來、串起來的資料夾要怎麼組織…等問題，所以只能按照自己的需求查。\n例如，上 google 查 webpack react redux sass，會看到\n把它們下載看看，它們怎麼組織專案的 學習最快的方法就是模仿，從別人做好的專案架構學習、查文件資料，會學的很快的。\n不過我們目前還是用 create-react-app 建立前端專案，沒有要下載別人的，未來會慢慢的建立起自己的專案架構。\n網頁基本知識 HTML 和　CSS 基本知識可以自行上網查，但有點東西我覺得要了解才可以：\nHTML Tags： \u0026lt;div /\u0026gt;、\u0026lt;input\u0026gt; HTML Attributes：style, class HTML Event Attributes: onClick CSS: Box Model (圖來自CSS Box Model) 剩下的東西我覺得想要什麼再查就可以了。\n下接來，我們要回到 javascript 的部分：前端框架 React\nReact 必需知道的事 我們已經在 Day 10- 一周目- 開始玩轉前端(一)介紹過 React，之後會針對一些重要的概念說明。\n每個 React component class 都有 state. prop (props.children) 我們舉個例子：\n1class LoginBox extends React.Component { 2 render() { 3 return ( 4 \u0026lt;div\u0026gt; 5 \u0026lt;button onClick={this.props.onClickButton}\u0026gt;送出\u0026lt;/button\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ); 8 } 9} 10 11class App extends React.Component { 12 constructor(props) { 13 super(props); 14 this.handleClick = this.handleClick.bind(this); // 讓 handleClick() 裡的 this 是 App 自已 15 } 16 17 state = { 18 message: \u0026#39;\u0026#39;, 19 } 20 21 handleClick() { 22 this.setState({ 23 message: \u0026#39;hi\u0026#39;, 24 }); 25 } 26 27 render() { 28 return ( 29 \u0026lt;div\u0026gt; 30 {this.state.message} 31 \u0026lt;LoginBox onClickButton={this.handleClick} /\u0026gt; 32 \u0026lt;/div\u0026gt; 33 ) 34 } 35} Live Demo\n請特別注意 this.handleClick = this.handleClick.bind(this) 這行，它一定要寫，因為引起 this.props.onClickButton(或者說 this.handleClick) 執行的人不是 App，所以 handleClick 裡面的 this 不是指向 App。因此，在 constructor() 中用 bind(this)，可以把 this 綁定成 App，如此 this.setState() 才能使用。\nLobinBox 和 App 它們各自有兩個一定有的屬性：\nprops： 是由呼叫者(caller)所送入元件中。例如 LobinBox 的 onClickButton 的值是由 App 在 render()時送入。props 在 LoginBox 中不會改變，從 LoginBox 角度看，props 就像是常數。 state： 是元件本身的狀態，它會隨著時間或行為改變。例如 App 的 state.message 點擊 \u0026lt;button /\u0026gt; 後會執行 this.props.onClickButton，又因為其值是 App 中的 handleClick，所以 handleClick() 會執行，導致 setState()執行使 App 的 state.message 改變。 另外，props.children 這個很特別，它指向被 component 包著的內容，見下面\n1class LoginBox extends React.Component { 2 render() { 3 return ( 4 \u0026lt;div\u0026gt; 5 \u0026lt;h3\u0026gt;in LoginBox\u0026lt;/h3\u0026gt; 6 {this.props.children} 7 \u0026lt;button onClick={this.props.onClickButton}\u0026gt;送出\u0026lt;/button\u0026gt; 8 \u0026lt;/div\u0026gt; 9 ); 10 } 11} 12 13class App extends React.Component { 14 ...略 15 render() { 16 return ( 17 \u0026lt;div\u0026gt; 18 {this.state.message} 19 \u0026lt;LoginBox onClickButton={this.handleClick}\u0026gt; 20 \u0026lt;div\u0026gt;{this.state.message}\u0026lt;/div\u0026gt; 21 \u0026lt;/LoginBox\u0026gt; 22 \u0026lt;/div\u0026gt; 23 ) 24 } 25} Live Demo\nLoginBox 裡面的 this.props.children 等於在 App 中被 LoginBox 標籤包著的所有內容。因此，為了渲染被 LoginBox 包著的內容，必需在 LoginBox 的 render 中 {this.props.children} 渲染，不然就看不到裡面的東西。\nReact component lifecycle (生命周期) 它們是 component 的在建立和渲染的過程 (見官方文件：Component lifecycle)，以 component class 出發，react 會做以下的過程： 依照 component 被掛入 DOM 的過程分類，過程中會依序執行 component 的函數如下：\nMounting：component 被建立實體(即 react element)後，渲染到 DOM 的過程 constructor() static getDerivedStateFromProps() render() componentDidMount() Updating：當 component 收到新的 props 時，更新狀態(state)，再重渲染到 DOM 的過程 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() Unmounting：當 component 不被使用，從 DOM 移除的過程 componentWillUnmount() Error Handling：當 component 錯誤發生時 componentDidCatch() Live Demo - React lifecycle 範列中把所有的過程都印了出來，可以去看看 當你按下 toggle，就會看到 Updating 的過程 我們雖然不會一一解釋它們，但有東西要釐清一下：\ngetDerivedStateFromProps(props, state) 是指由使用者送入的 props(可能是Mounting 或 Updating 發生) 和目前 compoent 的 state 產生新的 state。我們之前過 state 是 compoent 本身的狀態，當有新 props 來到時自然需要改變。 render() 不單只能回傳一個 react element，它可以回傳更多型態(見render()。不過，比較常回傳一個 react element 或 react element array。 一般而言，render() 回傳的 react element，只能有最上層的標籤 1render() { 2 reutrn \u0026lt;root\u0026gt;{...}\u0026lt;/root\u0026gt; 3} 但 React.Fragment 可以讓你放更多 react element 1render() { 2 return ( 3 \u0026lt;React.Fragment\u0026gt; 4 \u0026lt;ChildA /\u0026gt; 5 \u0026lt;ChildB /\u0026gt; 6 \u0026lt;ChildC /\u0026gt; 7 \u0026lt;/React.Fragment\u0026gt; 8 ); 9} componentDidMount() 是react element 掛入 DOM 後才會被執行，適合拿來做為要求後端資料的觸發點 getSnapshotBeforeUpdate() 回傳的值，會在 componentDidUpdate(prevProps, prevState, snapshot) 的參數拿到。可以拿來保留畫面更新前的資料。 React 的效能議題 在 render() 中用箭頭函數：每次都有新的函數 以前面的例子：\n1\u0026lt;LoginBox onClickButton={this.handleClick}\u0026gt; 2 \u0026lt;div\u0026gt;{this.state.message}\u0026lt;/div\u0026gt; 3\u0026lt;/LoginBox\u0026gt; 你可以寫成\n1\u0026lt;LoginBox onClickButton={() =\u0026gt; { 2 this.setState({ 3 message: \u0026#39;hi\u0026#39;, 4 }); 5}}\u0026gt; 6 \u0026lt;div\u0026gt;{this.state.message}\u0026lt;/div\u0026gt; 7\u0026lt;/LoginBox\u0026gt; 是可以這樣做，也不用 .bind(this) 了，但要知道每次 render() 都會重新產生一個新的函數，有時對效能不是很好。因此，可以使用 this.handleClick 這個成員函數，這個就只有一個實體。記得! 若在this.handleClick實作中要用到 this，要記得 .bind(this)。\nKey Attribute 會用在 React Virtual DOM 比較：動態 react element array 要加 key 我們考慮 react element 放在 array 中，React Virtual DOM 在進行比較(新舊React Virtual DOM 比較)決定是否要更新 DOM 時，它可能會參考屬性 key，這東西很特別。\n沒有用 key 的 react element 1 if (this.props.toggle) { 2 return ( 3 \u0026lt;div\u0026gt; 4 \u0026lt;Child text=\u0026#34;3\u0026#34; /\u0026gt; 5 \u0026lt;Child text=\u0026#34;4\u0026#34; /\u0026gt; 6 \u0026lt;Child text=\u0026#34;5\u0026#34; /\u0026gt; 7 \u0026lt;/div\u0026gt; 8 ); 9 } else { 10 return ( 11 \u0026lt;div\u0026gt; 12 \u0026lt;Child text=\u0026#34;3\u0026#34; /\u0026gt; 13 \u0026lt;Child text=\u0026#34;5\u0026#34; /\u0026gt; 14 \u0026lt;/div\u0026gt; 15 ); 16 } React Virtual DOM比較時是按照順序，若 toggle 從 false 到 true：\nfalse -\u0026gt; true false true true -\u0026gt; false updating \u0026lt;Child text=\u0026quot;3\u0026quot; /\u0026gt; \u0026lt;Child text=\u0026quot;3\u0026quot; /\u0026gt; updating updating \u0026lt;Child text=\u0026quot;5\u0026quot; /\u0026gt; \u0026lt;Child text=\u0026quot;4\u0026quot; /\u0026gt; updating mounting null \u0026lt;Child text=\u0026quot;5\u0026quot; /\u0026gt; unmounting 一開始toggle = false\n1Child =\u0026gt; 3 constructor 2Child =\u0026gt; 3 getDerivedStateFromProps 3Child =\u0026gt; 3 render 4Child =\u0026gt; 5 constructor 5Child =\u0026gt; 5 getDerivedStateFromProps 6Child =\u0026gt; 5 render 7Child =\u0026gt; 3 componentDidMount 8Child =\u0026gt; 5 componentDidMount 由 false -\u0026gt; true\n1Child =\u0026gt; 3 getDerivedStateFromProps 2Child =\u0026gt; 3 shouldComponentUpdate 3Child =\u0026gt; 3 render 4Child =\u0026gt; 4 getDerivedStateFromProps 5Child =\u0026gt; 5 shouldComponentUpdate 6Child =\u0026gt; 4 render 7Child =\u0026gt; 5 constructor 8Child =\u0026gt; 5 getDerivedStateFromProps 9Child =\u0026gt; 5 render 10Child =\u0026gt; 3 getSnapshotBeforeUpdate prev =3 -\u0026gt; updating, 一樣留著 11Child =\u0026gt; 4 getSnapshotBeforeUpdate prev =5 -\u0026gt; updating, 之前是 5 12Child =\u0026gt; 3 componentDidUpdate 13Child =\u0026gt; 4 componentDidUpdate 14Child =\u0026gt; 5 componentDidMount -\u0026gt; mounting, 5 由 true -\u0026gt; false\n1Child =\u0026gt; 3 getDerivedStateFromProps 2Child =\u0026gt; 3 shouldComponentUpdate 3Child =\u0026gt; 3 render 4Child =\u0026gt; 5 getDerivedStateFromProps 5Child =\u0026gt; 4 shouldComponentUpdate 6Child =\u0026gt; 5 render 7Child =\u0026gt; 3 getSnapshotBeforeUpdate prev =3 -\u0026gt; updating, 一樣留著 8Child =\u0026gt; 5 getSnapshotBeforeUpdate prev =4 -\u0026gt; updating, 之前是 4 9Child =\u0026gt; 5 componentWillUnmount -\u0026gt; unmounting, 5 10Child =\u0026gt; 3 componentDidUpdate 11Child =\u0026gt; 5 componentDidUpdate 當有 key 的 react element 1 if (this.props.toggle) { 2 return ( 3 \u0026lt;div\u0026gt; 4 \u0026lt;Child key=\u0026#34;b3\u0026#34; text=\u0026#34;b3\u0026#34; /\u0026gt; 5 \u0026lt;Child key=\u0026#34;b4\u0026#34; text=\u0026#34;b4\u0026#34; /\u0026gt; 6 \u0026lt;Child key=\u0026#34;b5\u0026#34; text=\u0026#34;b5\u0026#34; /\u0026gt; 7 \u0026lt;/div\u0026gt; 8 ); 9 } else { 10 return ( 11 \u0026lt;div\u0026gt; 12 \u0026lt;Child key=\u0026#34;b3\u0026#34; text=\u0026#34;b3\u0026#34; /\u0026gt; 13 \u0026lt;Child key=\u0026#34;b5\u0026#34; text=\u0026#34;b5\u0026#34; /\u0026gt; 14 \u0026lt;/div\u0026gt; 15 ); 16 } 當 react element key 新舊 key 都一樣，表示 DOM element 存在，只要進行 DOM element 更新 當 react element key 新出現，表示要進行插入新的 DOM element。 當 react element key 在新的 React Virtual DOM 消失，表示移除 DOM element。\nfalse -\u0026gt; true false true true -\u0026gt; false updating \u0026lt;Child key=\u0026quot;b3\u0026quot;　text=\u0026quot;3\u0026quot; /\u0026gt; \u0026lt;Child key=\u0026quot;b3\u0026quot; text=\u0026quot;3\u0026quot; /\u0026gt; updating mounting null \u0026lt;Child key=\u0026quot;b4\u0026quot; text=\u0026quot;4\u0026quot; /\u0026gt; unmounting updating \u0026lt;Child key=\u0026quot;b5\u0026quot;　text=\u0026quot;5\u0026quot; /\u0026gt; \u0026lt;Child　key=\u0026quot;b5\u0026quot; text=\u0026quot;5\u0026quot; /\u0026gt; updating 一開始toggle = false\n1Child =\u0026gt; b3 constructor 2Child =\u0026gt; b3 getDerivedStateFromProps 3Child =\u0026gt; b3 render 4Child =\u0026gt; b5 constructor 5Child =\u0026gt; b5 getDerivedStateFromProps 6Child =\u0026gt; b5 render 7Child =\u0026gt; b3 componentDidMount 8Child =\u0026gt; b5 componentDidMount 由 false -\u0026gt; true\n1Child =\u0026gt; b3 getDerivedStateFromProps 2Child =\u0026gt; b3 shouldComponentUpdate 3Child =\u0026gt; b3 render 4Child =\u0026gt; b4 constructor 5Child =\u0026gt; b4 getDerivedStateFromProps 6Child =\u0026gt; b4 render 7Child =\u0026gt; b5 getDerivedStateFromProps 8Child =\u0026gt; b5 shouldComponentUpdate 9Child =\u0026gt; b5 render 10Child =\u0026gt; b3 getSnapshotBeforeUpdate prev =b3 -\u0026gt; updating, 一樣留著 11Child =\u0026gt; b5 getSnapshotBeforeUpdate prev =b5 -\u0026gt; updating, 一樣留著 12Child =\u0026gt; b3 componentDidUpdate 13Child =\u0026gt; b4 componentDidMount -\u0026gt; mounting, 4 14Child =\u0026gt; b5 componentDidUpdate 由 true -\u0026gt; false\n1Child =\u0026gt; b3 getDerivedStateFromProps 2Child =\u0026gt; b3 shouldComponentUpdate 3Child =\u0026gt; b3 render 4Child =\u0026gt; b5 getDerivedStateFromProps 5Child =\u0026gt; b5 shouldComponentUpdate 6Child =\u0026gt; b5 render 7Child =\u0026gt; b3 getSnapshotBeforeUpdate prev =b3 -\u0026gt; updating, 一樣留著 8Child =\u0026gt; b5 getSnapshotBeforeUpdate prev =b5 -\u0026gt; updating, 一樣留著 9Child =\u0026gt; b4 componentWillUnmount -\u0026gt; unmounting, 4 10Child =\u0026gt; b3 componentDidUpdate 11Child =\u0026gt; b5 componentDidUpdate 完整的程式見 Live Dome\nKey Attribute 小總結 一般我們不用刻意的設定 key 值，React 會儘量的重新使用 DOM element，但 若你的 react element array 是會動態改動的，最好加入 key。React 也會對沒加 key 的 react element array 發出警告，因為不加key可能會使舊的 react element 留下來，它可能會有殘留的 prop/state 導致畫面殘留。 總結 今天我們先談了如何找前端專案結構，再深入談 React 的 state 和 prop ，以及生命周期。最後以箭頭函數和 key 屬性的效能議題做為結尾。\n","date":"2018-10-21","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-21-%E4%BA%8C%E5%91%A8%E7%9B%AE-react-%E5%BF%85%E5%82%99%E7%9F%A5%E8%AD%98%E5%92%8C%E6%95%88%E8%83%BD%E8%AD%B0%E9%A1%8C/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 21 - 二周目 - React 必備知識和效能議題"},{"categories":[],"content":"Jest 寫單元測試/整合測試\n回憶 昨天我們談了如何做驗証和掛入 middleware 來驗証 token。今天要著重測試這塊\n想必大家一定常聽到 自動軟體測試、TDD 與 BDD這之類的名詞，這此觀念現在很流行，不過我們不是要講它們，有興趣的人可以看 91 - 30天快速上手TDD。\n目標 今天的目標是拿我們昨天的程式來寫測試：\n使用 Jest 進行測試 如何寫非同步程式的測試 怎麼寫單元測試/整合測試 寫測試嗎？ 為什麼要寫測試？ 寫測試的好處很多，上網可以查到一堆，但我說說我目前有體會到的好處\n提升自信心：當你寫好一後函數，你是怎麼測試有沒有正常運作呢？當然是執行看看。測試就是在執行你的函數，你可以輸入一堆參數來執行你的函數，有被執行過的函數會比較放心。 思考介面： 對於還沒寫實作(production code)的函數前，你會考慮這函數的介面(簽章)以釐清目地。 對於已寫實作的函數，引入測試時，你會重新省審視有沒有足夠的參數讓測試執行函數。 停止無止盡的規畫： 測試要求寫下預期的執行結果，所以你會針對目標寫出實作(production code)使測試通過，而不是陷在思考邏輯中。 引起函數的執行可能要很長的前置作業，像是先執行函數A，再執行函數B後，最後才是你的函數。這路徑太長，所以你會調整介面(簽章)使得函數可以直接執行。 保護程式碼：開發時是不是常出現「改東壞西」？已通過的測試會保護程式碼，每當你改完某程式，只要重新執行所有測試，就可以看以前通過的測試現在有沒有失敗，所以可以鎖定錯誤範圍、降低維謢成本。 更完備程式碼(強健程式碼)：有了直接執行的手段，就可以輸入不同的參數跑看看你的程式會不會壞掉，所以可以加入更多確保運作的程式碼，像是空參數的檢查…等。 結論是：\n1寫測試是以目地為導向，讓測試隨時執行監控程式碼 不寫，會不會怎麼樣？我真的需要寫嗎？ 其實我覺得也還好，就自己從重頭手動測試也可以。不過我為了前面提的好處，我會儘量寫，但速度和維謢性一直會互相拉扯。畢竟有些老闆要的是能跑的程式，不是能維謢的程式，但要讓他知道趕出來的程式通常有後續維謢的成本(像不容易加入新功能、程式碼太亂、命名過亂、程式架構混亂…之類的，常見的原因是「相依項太多」)。\n當目標不明確時，我也不太會寫測試，老闆要什麼他自己都不知道了你會知道嗎？但是我在開發時會儘量抽工具和套件，或做重構的準備(ex: 寫註解、命名故意寫的又長又精確)，也會儘量把工具類(utilities)、套件庫(package/libraries)的測試寫好。\n有時測試是不用寫或無法寫，像我之前文章的程式我也不會寫，因為是教學用。有時我要找什麼當範例我也不知道，能不能正常運作我也不知道，合不合適也不知道，都是要實作跑看看再改範例程式。\n比起測試，我覺得重構、除錯技巧和使用工具輔助它們反而更常使用。\nJest 測試框架 過程請見 github commit log ithelp-30dayfullstack-Day20\nJest 是 Facebook 底下的一個專案，提供：\n測試環境 API，如：test(name, fn, timeout) Expect/Assertions API，如：expect(actualData).beBe(expectData) 替身 Mock/Spy/Sub API，如： 1const mockFn = jest.fn(); 2mockFn(); 3expect(mockFn).toHaveBeenCalled(); // ture 除了從套件執行 Jest, 還提供 Jest CLI(command line intreface)，有 jest 指令 ，如：jest path/to/my-test.js 直接來個範例：\n一個簡單的 Jest 執行 我們選擇從專案本地執行，不想每次都安裝的話，就用 npm install jest -g 裝在全域\n安裝 Jest\n1npm install jest --save-dev 因為跟程式運作無關，jest 是屬於開發時才會運作，所以放 devDependencies 就可以了\n加入 npm 的腳本執行：加入名為 test 腳本執行 jest，因為是由 npm run 執行，所以會執行 ./node_modules/jest/bin/jest.js，不是全域的 jest。\n1// package.json 2{ 3 ...略 4 \u0026#34;scripts\u0026#34;: { 5 ...略 6 \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34;, 7 \u0026#34;jest-version\u0026#34;: \u0026#34;jest --version\u0026#34; 8 }, 9 ...略 10} 這裡我們只使用執行 jest 指令，它預設會從搜尋當前目錄下所所有的測試檔，檔案命名符合 **/__tests__/**/*.js?(x), **/?(*.)+(spec|test).js?(x) 比對的檔案進行測試。 Jest 有提供很多組態設定 Configuring Jest，一般會組態放在 package.json 中的 jest 屬性值中，或獨立出一個檔案執行時用 jest --config 引入。\n另外，npm run jest-version 可以看到現在 Jest 的執行版本。\n在專案根目錄，建一個 __tests__ 資料夾，後加入一個檔案 ./__tests__/hello-jest.test.js\n1function sum(a, b) { 2 return a + b; 3} 4 5test(\u0026#39;adds 1 + 2 to equal 3\u0026#39;, () =\u0026gt; { 6 expect(sum(1, 2)).toBe(3); 7}); 這是最簡單的測試。另外， Jest 也支援測試群組 describe/afterAll/afterEach/beforeAll/beforeEach 之類 Globals API。\n執行測試 npm run test 會看到它找到一個測試(tests)\n測試非同步函數： 測試 VerfiyJWT() 產生的 middleware 昨天我們用 VerfiyJWT() 產生的 middleware 來驗証 JWT 是否有效，我們也可以對 VerfiyJWT 寫測試。 開始前先開一個 ./middlewares/VerfiyJWT.test.js 檔案，我們把測試往這放。\n我們一步步看 VerfiyJWT 是什麼東西，請先不要看實作，實作會使你搞不清楚你的測試對象和目地\n回傳值測試 首先 VerfiyJWT 他用來產生 middleware，所以他的簽章是： VerfiyJWT() : function，所以\n1VerifyJWT() 要回傳一個 function 這就是第一個測試\n1const VerifyJWT = require(\u0026#39;../VerifyJWT\u0026#39;); 2 3describe(\u0026#39;VerifyJWT\u0026#39;, () =\u0026gt; { 4 test(\u0026#39;VerifyJWT() 要回傳一個 function\u0026#39;, () =\u0026gt; { 5 const middleware = VerifyJWT(); 6 const actual = typeof middleware; 7 const except = \u0026#39;object\u0026#39;; 8 expect(actual).toEqual(except); 9 }); 10}); 你可以刻意的把 except 改成值 object，就會測式不通過。\n我們可以看出幾點：\n測試對象： VerifyJWT 測試描述： VerifyJWT() 要回傳一個 function 實際輸出： 放在 actual 期望輸出： 放在 except 回傳 middleware 的測試 上面處理完回傳了，我們來看 middleware 預期的效果： middleware 會從 cookie 拿 token，檢查 token 是否有效。\n所以\n1當 request 的 cookie token 值為有效，就會換下一個 regular middleware 就是一個測試項目：\n1 test(\u0026#39;當 request 的 cookie token 值為有效，就會換下一個 regular middleware\u0026#39;, (done) =\u0026gt; { 2 const validJWT = \u0026#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJpbGx5IiwiZW1haWwiOiJiaWxseUBnbWFpbC5jb20iLCJpYXQiOjE1NDAwMTg2ODQsImV4cCI6MTU0MTAxODY4NH0.BHWWQbxWeaeCRLgjmT9xoAD_LXTGkmX6zcTKoncv_Uk\u0026#39;; 3 const middleware = VerifyJWT(); 4 5 const res = {}; 6 _.set(res, \u0026#39;cookie.token\u0026#39;, validJWT); // 用 lodash 的　set() 設定值，相當於 const res = {cookie: {token: validJWT}} 7 8 middleware(res, null, () =\u0026gt; { 9 done(); // 告訴 Jest 此測試正常結束 10 }); 11 }); 我們真的找一個有效的 token 放在 req.cookie.token 中，middleware 應該要叫起 next()。 這裡我們用到 done 這參數，這是 Jest 在非同步測時需要呼叫的，若執行 done() 就是跟 jest 說此測式正常結束了，若執行 done(error) 就是出問題了。假如你不叫 done() 或是 middleware 中 沒叫 next() 就會測試失敗。 除了這種 callback的版本，其它對於非同步的測試還有 Promise, async/await的版本Testing Asynchronous Code。\n反之，\n1當 request 的 cookie token 值為無效，就會換下一個 error-handling middleware 就是另一個測試：\n1 test(\u0026#39;當 request 的 cookie token 值為無效，就會換下一個 error-handling middleware\u0026#39;, (done) =\u0026gt; { 2 const invalidJWT = \u0026#39;invalidJWT.invalidJWT.invalidJWT\u0026#39;; 3 const middleware = VerifyJWT(); 4 5 const res = {}; 6 _.set(res, \u0026#39;cookies.token\u0026#39;, invalidJWT); // 用 lodash 的　set() 設定值，相當於 const res = {cookie: {token: validJWT}} 7 8 middleware(res, null, (error) =\u0026gt; { 9 expect(error).toBeInstanceOf(Error); // error 非空(即 next(error)), 測試通過 10 done(); // 告訴 Jest 此測試結束 11 }); 12 }); VerfiyJWT 測試的小總結 我們寫了三個測試：\nVerifyJWT() 要回傳一個 function 當 request 的 cookie token 值為有效，就會換下一個 regular middleware 當 request 的 cookie token 值為無效，就會換下一個 error-handling middleware 你可以任意的改動程式，看看各種錯誤訊息。\n但是上面的測試有一些問題：\n有效的 JWT，會因為到期失效：因為我們是 hard code 寫的 token，失效後測試就會失敗 secret 變的話就測試也會失敗 這是因為 VerifyJWT 對 jsonwebtoken 套件和 SECRET 常數有相依關係，所導致的問題，所以我們稱 (我們忽略 lodash 套件，把它當原生的)\n1當 request 的 cookie token 值為無效，就會換下一個 error-handling middleware 2當 request 的 cookie token 值為有效，就會換下一個 regular middleware 是 整合測試(integration test)。\n然而 VerifyJWT() 要回傳一個 function 不相依其它人，所以它是 單元測試(unit test)\n整合測試轉成單元測試 要把相依的問題解決，常用的方法就是 依賴注入(DI)。\n我們先把上面三個分成兩個檔案：整合測試的群叫 VerifyJWT.integration.test.js，單元測試的群叫 VerifyJWT.unit.test.js。\n處理 SECRET 相依：SECRET 改成外界送入 options 取出外界送入的 secret 屬性，預設值是原來的 SECRET 1const {tokenPath = \u0026#39;cookies.token\u0026#39;, secret = SECRET} = options; 送入 verifyJWT() 且修改它的簽章和使用 secret 1async function verifyJWT(jwt, {secret}) { 2 if (!jwt) { 3 return Promise.reject(new Error(\u0026#39;No JWT\u0026#39;)); 4 } 5 const decoded = jsonwebtoken.verify(jwt, secret); 6 return decoded; 7} 8 9verifyJWT(jwt, {secret}) 再執行一次測試，還是通過，表示沒有程式壞掉 處理 jsonwebtoken 相依：jsonwebtoken.verify 改成外界送入 類似上面的操作，options 取出外界送入的 verify 屬性，預設值是原來的 jsonwebtoken.verify 1const {tokenPath = \u0026#39;cookies.token\u0026#39;, secret = SECRET, verify = jsonwebtoken.verify} = options; verify 送入 verifyJWT() 並使用 1async function verifyJWT(jwt, {secret, verify}) { 2 if (!jwt) { 3 return Promise.reject(new Error(\u0026#39;No JWT\u0026#39;)); 4 } 5 const decoded = verify(jwt, secret); 6 return decoded; 7} 再執行一次測試，還是通過，表示沒有程式壞掉 修改成單元測試 複製二個整合測試 把依賴整改成在測試中注入 1 const jsonwebtoken = require(\u0026#39;jsonwebtoken\u0026#39;); 2 const MY_SECRET = \u0026#39;MY_SECRET\u0026#39;; 3 4 test(\u0026#39;當 request 的 cookie token 值為有效，就會換下一個 regular middleware\u0026#39;, (done) =\u0026gt; { 5 const validJWT = jsonwebtoken.sign({}, MY_SECRET); // 產生有效的 token 6 const middleware = VerifyJWT({secret: MY_SECRET, verify: jsonwebtoken.verify}); // 依賴注入 7 8 const res = {}; 9 _.set(res, \u0026#39;cookies.token\u0026#39;, validJWT); 10 11 middleware(res, null, (error) =\u0026gt; { 12 done(error); 13 }); 14 }); 15 16 test(\u0026#39;當 request 的 cookie token 值為無效，就會換下一個 error-handling middleware\u0026#39;, (done) =\u0026gt; { 17 const invalidJWT = \u0026#39;invalidJWT.invalidJWT.invalidJWT\u0026#39;; 18 const middleware = VerifyJWT({secret: MY_SECRET, verify: jsonwebtoken.verify}); // 依賴注入 19 20 const res = {}; 21 _.set(res, \u0026#39;cookies.token\u0026#39;, invalidJWT); 22 23 middleware(res, null, (error) =\u0026gt; { 24 expect(error).toBeInstanceOf(Error); 25 done(); 26 }); 27 }); 再執行一次測試，增加的兩個單元測試也會通過 轉成單元測試的小總結 我們成功透過依賴注入完成了 VerifyJWT 的單元測試，什麼時候執行都會有一樣的結果。同時，VerifyJWT(options) 也變的更有彈性，像是 verify 的實作再也不限定是 jsonwebtoken.verify，可以套用其它 JWT 的驗証套件。另外，別忘了之前的整合測試過了一段時間就會失敗。\n我們自然想問一個問題：\n我該寫整合測試還是單元測試？ 這問題應該是因人而異，我列出一些我的看法\n貼近終端目地：整合測試的測試目標比較能夠貼近終端使用者的目標，而單元測試比較碎片化。 程式完備性/健壯性：單元測試的程式一般比較小，所以比較能處理所有情況。 寫測試花費的時間：單元測試可能要處理更多的相依，所以可能比較花時間。 測試易碎：整合測試相對單元測試容易壞掉，因為他有較多的相依。 執行測試時間：單元測試比整合測試快。 在時間有限的情況下，我的原則是套件、工具類的程式最好寫測試。不然就是先寫整合測試，有時間才單元測試，或是針對重要、易錯的程式先寫單元測試。\n總結 今天主要用 VerifyJWT 為例子介紹：\nJest 如何使用 如何寫非同步的測試 單元測試和整合測試的區別：看相依關係強度 參考資料 以下資料提供有興趣的人研究\n按照功用分類： 框架：jest Mock/Spy/Sub 替身類：Sinon.js、jest Assert/Except: ：Sinon.js、chai.js, jest, unexpected 參考文章： Sinon.js 的 Spies, Stubs 和 Mocks 的最好實踐[譯文+筆記] 5 Questions Every Unit Test Must Answer Rethinking Unit Test Assertions JavaScript Testing: Unit vs Functional vs Integration Tests ","date":"2018-10-20","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-20-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6testing%E6%B8%AC%E8%A9%A6%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B8/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 20 - 二周目 - 軟體測試(Testing)：測試非同步函數"},{"categories":[],"content":"帳密認証與JWT、利用 middleware，認証 JWT middleware\n回憶 昨天完整的介紹了 router 路由，它幫助我們輕易的組裝出 API。完成此目的三個核心概念是 中間件(middleware)、路由(routing)、流(stream)，其中 middleware 是更加的重要。\n因為 middleware 可以做很多事，例如：\n任易串接在 router 中，想放哪都可以：因為 middleware 簽章都長的一樣，可以放在 router.use(middleware 、 router.METHOD(path, middleware)、 app.use(middleware 和 app.METHOD(path, middleware)中。 共用處理流程：放在較上層的路由中可以使下層所有路由都作用到。像是 app.use(express.json())放在越前面，可以使後面串進的 router 都可以被 express.json() 這 middleware 作用(req.body 解析成 JSON object)。 middleware 可以獨立出套件：當 middleware 的相依越少，越不會有 Side Effect，就可以獨立出來做成套件供別人使用。 middleware 命名直覺增加可讀性：像express.json()就是跟 JSON 有關，越直覺的命名可以增加程式碼可讀性。下面雖然串更多 middleware，但意思很明顯 1router.post(\u0026#39;/api/accounts\u0026#39;, LogMiddleware, AuthMiddleware, AddAccountMiddleware, WrappedDataEndpointMiddleware) 目標 基本帳密認証 什麼是JWT？ 利用 middleware，認証 JWT middleware 帳密認証 基本的帳密認証(token 版) 我們採用的模式是，認証完成後回應 token 給 client，client 自己留著，每當client要對後端操作時會帶著 token 一併給後端，而不是用在後端保留登入資訊(session)。 這樣做有個好處是後端是無狀態的(stateless)，任何一個台可以識別 token 的後端都可以服務 client，以提高後端的可擴展性(scalability)。\n基本的認証機制有幾個步驟(與上圖對應)\n使用者送出帳號、密碼 後端到資料庫比對 資料庫回傳用戶資料 回傳 token 雖然看起來很單純但在這些環節中有些資安注意事項\n使用者送出帳號、密碼： 儘量使用 https 連線，request message 會被加密傳送(包含網址)，攔截封包的人最多只能看到 hostname。 (其實，還有個人會知道，就是 Chrome，因為你是用它的瀏覽器) 儘量不要明碼儲存密碼，可以經過「不可反解」加密後(ex: sha256)才存或傳送，因為 Web Storage / cookie，是可以透過 javscript 存取查看的 能不儲密碼就不要存，就算是加密密碼它也是密碼阿! 若要持續性登入，可以用存 token 代替 後端到資料庫比對：拿到帳密，就去資料庫比對 依需求決定：後端與資料庫連線要不要加密連線或資料庫要不要設帳密 儘量不要明碼儲存密碼在資料庫中 資料庫回傳用戶資料： 用戶資料要確保把敏感資料過濾，也可以在後端一收到用戶資料立刻過濾敏感資料，減少敏感資料外洩的可能性 回傳 token token 可以存在 client cookie 中，並設定 httpOnly(Cookie只能被伺服端存取，client 無法用 javascript 讀取)、secure(只能透過https的方式傳輸) 若用上述存在 cookie 中，也不用刻意帶 token 到未來發出的 request 中(少寫一些程式)，瀏覽器會自動帶入 Token 像什麼？ token 是經過認証單位認証後，所簽發(sign)的字串。 client 拿到 token 後當要求後端服務時一併送出，後端就可以依 token 識別身份給與服務。\nJWT (JSON Web Token) 是什麼？ 我們要採用 JWT (JSON Web Token) 做為 token 的資料格式。\n它是由三個部分組成的\n1標頭(Header).內容(Payload).簽名(Signature) 標頭(Header)：Base64編碼的字串。一般內含兩個屬性：token 類型、雜湊(hashing)函數的名字(ex: HMAC SHA256 or RSA)，如：\n1{ 2 \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, 3 \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; 4} 再透過 Base64Url 編碼，一般在轉換前，會把不可見字元(ex: 空白, 換行)拿掉\n1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 就是 Header。\n內容(Payload)：Base64編碼的字串。內含一堆 Claims，像是：(截錄自JSON Web Token (JWT) 簡介)\niss: The issuer of the token，token 是給誰的 sub: The subject of the token，token 主題 exp: Expiration Time。 token 過期時間，Unix 時間戳記 iat: Issued At。 token 建立時間， Unix 時間戳記 jti: JWT ID。針對當前 token 的唯一標識 上面只列出一些 JTW 定義的 claims，其它見 IANA JSON Web Token Registry。你也可以自己放任何的資料。來個 Payload 可能資訊\n1{ 2 \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, 3 \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, 4 \u0026#34;iat\u0026#34;: 1516239022 5} 再透過 Base64Url 編碼，一般在轉換前，會把不可見字元(ex: 空白, 換行)拿掉\n1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ 就是 Payload。\n到目前為止的 Header 和 Payload 雖然是 Base64Url 編碼後，但它們 可以解碼，所以也算是明文資料，不應該放敏感資料。\n簽名(Signature)：拿 Header、Payload和一個密鑰(secret)當參數，經過不可反解的雜湊函數後得到。以 HMAC SHA256 來說\n1HMACSHA256( 2 base64UrlEncode(header) + \u0026#34;.\u0026#34; + 3 base64UrlEncode(payload), 4 secret) 這裡 header, payload是指未經過 Base64Url 編碼, secret 是 your-256-bit-secret，產生：\n1SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 最後的 JTW 就是\n1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c JWT首頁 有 JTW 加解密互動網頁可以玩玩看。\n要注意，這個 secret 要好好保存在後端，這是拿來判斷 JWT 是否有效的鑰匙。\nJWT 帶來什麼好處？ 自帶狀態：自帶JWT 中可以自帶狀態，不用把狀態存在後端，也不會增加後端負擔。適合運行在 無狀態 架構的後端。若是把 token 過期時間放在 payload 中，就可以為 token 加入效期特性。 自驗性：只要有同樣的 secret ，就可以判斷 JWT 是否有效，只要簡單在做一次 1HMACSHA256( 2 JWT.header + \u0026#34;.\u0026#34; + 3 JWT.payload, 4 secret) 看結果和 Signature 一不一樣，就可以判斷 JWT 是否有效。 易變性／完整性(integrality)：跟 hashing 函數一樣，只要 Header 或 Payload 的內容改一點點，Signature 的結果就有很大的改變，所以保証資料的完整性。 最後要注意一件是：\n1JWT 解決的是簽証(sign)安全，不是傳輸全安全，要配合加密通道(ex: https)才能安全地傳遞 JWT。 JWT 要自己寫嗎？ JWT首頁 有不同程式語言的實作套件，直接用就可以了。 Node.js 用的是 jsonwebtoken。\n實作自己的認証 過程請見 github commit log ithelp-30dayfullstack-Day19 執行前需要先開 mongodb (npm run startdb)，不用時可以關 mongodb (npm run stopdb)\n我們例用 JWT 來實作認証機制\nPOST /api/auth/login 這 api 是用來登入 POST /api/echo 這 api 需要有 token 才能運作，利用middleware 輕鬆掛入 實作 POST /api/auth/login 加入 ./routers/AuthRouter.js 專們處理受權相關\n1const express = require(\u0026#39;express\u0026#39;); 2 3/** 4 * 5 * @param {object} dependencies 6 */ 7function createRouter(dependencies) { 8 // Get dependencies 9 const { } = dependencies; 10 11 // Create a router 12 var router = express.Router(); 13 14 /* POST log */ 15 router.post(\u0026#39;/login\u0026#39;, function (req, res, next) { 16 next(new Error(\u0026#39;Not implement\u0026#39;)); 17 }); 18 return router; 19} 20 21module.exports = { 22 createRouter 23}; 串入 root router 串入root router (不懂的請見：Day 18 - 二周目 - 剖析 express 路由(router) 三概念：中間件(middleware)、路由(routing)、流(stream))\n1// routers/index.js 2router.use(\u0026#39;/api/auth\u0026#39;, authRouter); authRouter 物件設定 (不懂的請見：Day 17 - 二周目 - 依賴注入與組態化專案)\n1// app.js 2const { createRouter: createAuthRouter } = require(\u0026#39;./routes/AuthRouter\u0026#39;); 3 4container.register({ 5 ...略 6 authRouter: asFunction(createAuthRouter, { lifetime: Lifetime.SINGLETON }), 7}); Postman 打看看 帳密比對實作 我們假設 verifyUser() 會做資料庫查詢\n1// routers/AuthRouter.js 2async function verifyUser(data) { 3 const username = _.get(data, \u0026#39;username\u0026#39;); 4 const password = _.get(data, \u0026#39;password\u0026#39;); 5 6 if(username === \u0026#39;billy\u0026#39; \u0026amp;\u0026amp; password === \u0026#39;1234\u0026#39;) { // pass 7 return Promise.resolve({ 8 username, 9 email: \u0026#39;billy@gmail.com\u0026#39;, 10 }); 11 } 12 return Promise.reject(new Error(\u0026#39;Fail\u0026#39;)); 13} 套用帳密比對\n1// routers/AuthRouter.js 2router.post(\u0026#39;/login\u0026#39;, function (req, res, next) { 3 const data = req.body; 4 verifyUser(data) 5 .then(user =\u0026gt; { 6 res.json(user); 7 }) 8 .catch(next); 9}); 到目前我們做出簡單的帳密驗証。接下來，我們要為驗証成功的 client 回傳 JWT\n回傳 JWT 我們約定把 JWT 儲存在client 的 cookie中\n安裝 jsonwebtoken 1npm install jsonwebtoken --save 當帳密比對成功，就產生 JWT 並回傳 1// routers/AuthRouter.js 2const EXPIRES_IN = 10 * 1000; // 10 sec 3const SECRET = \u0026#39;YOUR_JWT_SECRET\u0026#39;; 4 5router.post(\u0026#39;/login\u0026#39;, function (req, res, next) { 6 console.log(JSON.stringify(req.cookies));　// 印出 cookies 7 const data = req.body; 8 verifyUser(data) 9 .then(user =\u0026gt; { 10 const token = jwt.sign(user, SECRET, { expiresIn: EXPIRES_IN }); 11 res.json({ 12 token 13 }); 14 }) 15 .catch(next); 16 }); 這裡用 expiresIn 選項可以方便地指定簽發的 JWT 多久到期，像我們設 10 秒。 試打看看 我們就可以得到 JWT 強化安全性 加入這行，後端要求 client 設定 cookie 1res.cookie(\u0026#39;token\u0026#39;, token, { maxAge: EXPIRES_IN, httpOnly: true}); // 回應 client ，把 token 存在名為 token 的 cookie 並設定相關屬性 再試打一下，查看 client(Postman) 收到回應的 headers HttpOnly 設定時，cookie token 不能用 javascript 取出。但你可以在 Postman 的 Cookies，可以查看所有 cookies，你會看到 token 被設定 另外，觀察到：\n因為我們設定 cookie 10 秒到期(EXPIRES_IN)，所以時間到後再看一次就會消失。 之後的 request 會一直帶著 cookies 一併送給後端 第一次打，沒有 cookies 所以印出 {}，第二次打，因為前一次登入成功並設定cookies，所以就會有 cookies。 為 POST /api/echo 加入 token 驗証 假設 client 會把 JWT 放在 名為 token 的 cookie 中，所以後端可以由\n1req.cookies.token 得到來自 client 的 token。因此，我們只要驗証此 token 就可以知道，request 是否有授權。\n我們利用 middleware 來做 JWT 的驗証\n加入 VerifyJWT，當 VerifyJWT() 動態產生 middelware 1// middlewares/VerifyJWT.js 2const _ = require(\u0026#39;lodash\u0026#39;); 3const jsonwebtoken = require(\u0026#39;jsonwebtoken\u0026#39;); 4 5const SECRET = \u0026#39;YOUR_JWT_SECRET\u0026#39;; // 要和簽發時一樣，所以可以放在 ./configs/config.js 中 6 7async function verifyJWT(jwt) { 8 if (!jwt) { 9 return Promise.reject(new Error(\u0026#39;No JWT\u0026#39;)); 10 } 11 const decoded = jsonwebtoken.verify(jwt, SECRET); 12 return decoded; 13} 14 15 16module.exports = function (options = {}) { 17 const {tokenPath = \u0026#39;cookies.token\u0026#39;} = options; // tokenPath 是取出 token 的路徑 18 return function (req, res, next) { 19 const jwt = _.get(req, tokenPath); 20 verifyJWT(jwt) 21 .then(decoded =\u0026gt; { 22 console.log(decoded); 23 next(); // next middleware 24 }) 25 .catch(next); 26 }; 27} 我們很刻意的利用閉包技巧，輸入 tokenPath 來動態產生 middelware。使用時，VerifyJWT() 才是 middelware 的簽章。 POST /api/echo 掛入 JWT 驗証 1router.post(\u0026#39;/api/echo\u0026#39;, VerifyJWT(), function (req, res, next) { 2 ...略 3} 這樣就完成對POST /api/echo 掛入 JWT 驗証，要有 JWT 才能執行這支API。\n總結 今天介紹基本認証的機制，還利用 JWT 來傳遞驗証結果。最後，利用 middleware 可以方便的掛入需要驗証的 APIs.\n未來有機會在來談 passport.js、OAuth、Time-based One-Time Password(TOTP)二階段驗証。\n","date":"2018-10-19","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-19-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E5%B8%B3%E5%AF%86%E8%AA%8D%E8%A8%BC%E8%88%87jwt-json-web-token%E5%82%B3%E9%81%9E/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 19 - 二周目 - 帳密認証與JWT (JSON Web Token)傳遞"},{"categories":[],"content":"剖析 express 路由(router) 三概念：中間件(middleware)、路由(routing)、流(stream)\n回憶 昨天介紹 awilix 來依賴注入， awilix 幫我們把 mongoService 建立好，並注入 ./routers/index.js 這個根路由物件中，使我們可以在 router.METHOD() 中調用 mongoService 的方法。\n今天要看 router.METHOD() 、router.use()這些神秘的東西，是怎麼幫我們組合出各式各樣的 API。\n目標 過程請見 github commit log ithelp-30dayfullstack-Day18\nexpress 的核心技術之一就是 router，它之所以複雜是因為他同時包含三個重要的概念：\n中間件(middleware) 路由(routing) 流(stream) 我們一一來了解它們\n剖析 router / app 首先看 app.METHOD(path, callback [, callback ...]) 和 router.METHOD(path, [callback, ...] callback) 的簽章，path 是我們要比對的網址片斷，callback 是我們要做的事，你會發現簽章中你可以「串」很多個 callback，express 「預期」每一個 callback 可以一個個被呼叫。這種特別的目地的 callback，被稱作中間件(middleware)，未來在前端的 redux 也會看到。\n中間件(middleware)：串接處理流程 express 中的兩種 middleware：\nRegular middleware function (req, res, next)：處理正常流程 Error-handling middleware function (err, req, res, next)：處理錯誤流程 不論是哪種 middleware，它們的簽章一定是長成那樣。並且，當 middleware 作完事， 一定要呼叫 next() 引發下一個 middleware 做事，除非是送出回應的最後一個 middleware，可以不用呼叫 next()。例如：\n1function middleware1(req, res, next) { 2 // 錯誤發生(一) 3 // throw new Error(\u0026#39;fake error by throw\u0026#39;); 4 5 // 錯誤發生(二) 6 // next(new Error(\u0026#39;fake error by next()\u0026#39;)); 7 // return; 8 9 console.log(\u0026#39;middleware1\u0026#39;); 10 // res.send(\u0026#39;搶先送出回應\u0026#39;); // 這會引起錯誤，但不中斷： Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client 11 next(); // 引發下一個 middleware 12 } 13 function middleware2(req, res, next) { 14 console.log(\u0026#39;middleware2\u0026#39;); 15 next(); // 引發下一個 middleware 16 } 17 router.get(\u0026#39;/api/middleware\u0026#39;, middleware1, middleware2, function (res, res, next) { 18 res.send(\u0026#39;done\u0026#39;); 19 }); 打 GET /api/middleware 的後在 console 結果是\n1middleware1 2middleware2 當沒有錯誤發生，所有「有呼叫 next() 的 regular middleware」 會依序處理，直到最後一個「沒有呼叫 next() regular middleware」執行完。因此，你一定要在後面一個 regular middleware 回應 request，不然 request 就會一直卡著，直到 timeout。\n當有錯誤發生，在某個 middleware 呼叫 next(err) 或被 throw error，就會略過所有 regular middleware 直到找到 error-handling middleware，來處理。\n雖然 regular middleware 和 error-handling middleware 可以交錯著串起來（就像 Promise 的 then()...catch()），但我薦議不要這麼做，這樣會讓處理邏輯混亂。\n試看看： 1. 你可以解開上例中 \u0026ldquo;錯誤發生\u0026rdquo; 的註解看看 2. 把 next() 註解，會使下一個 middleware 無法運作 3. 搶先送出回應看看\n路由(routing)：網址片斷串接 app.METHOD(path, callback [, callback ...]) 和 router.METHOD(path, [callback, ...] callback) 規定：\nrequest 的 method(GET/POST/DELETE/\u0026hellip;) 要附合，並且 網址片斷(path)附合 才會執行參數中的 callback (middleware)\n此外，app.usr([path, ]callbackOrRouter) 和 router.use([path,] callbackOrRouter) (path 預設是 /) 就是不管所有 method ，只比對附合片斷就可以執行：\n參數中的 callback 或 往下一個 router 執行 直接舉例比較快，見下面：\n1// app.js 2app.use(\u0026#39;/\u0026#39;, indexRouter); 1// routers/index.js 2const UserRouter = require(\u0026#39;./users\u0026#39;); 3 4function createRouter(dependencies) { 5 router.get(\u0026#39;/api/middleware\u0026#39;, middleware1, middleware2, function (res, res, next) { 6 res.send(\u0026#39;done\u0026#39;); 7 }); 8 router.use(\u0026#39;/user\u0026#39;, UserRouter); 9 return router; 10} 1// routers/users.js 2router.get(\u0026#39;/\u0026#39;, function(req, res, next) { 3 res.send(\u0026#39;respond with a resource\u0026#39;); 4}); 有三個 router，app, indexRouter, UserRouter，串接圖如下：\n上述串接後，只能搭配出\nGET /api/middleware GET /user/ 這兩個路徑，它們需要我們們自行回應 request(ex: res.send()、res.json())。\n關於網址片斷比對 網址片斷(path)，不是只能有定值，可以是下列任一種：\npath: Path Pattern Regular Expression Array 我覺得直接看文件範例就可以了，見 Path examples，或 Route paths 更詳細。\n不過有一點我一定要提，path 是可以抽取出 parameter 的，結果會放在 req.param 中，像是：\n1router.get(\u0026#39;/user/:userId\u0026#39;, function(req, res, next) { 2 const userId = req.param.userId; 3 ...略 4}) 這在 RESTful API 的設計很常使用。\n若是沒比對到的怎麼辨？ 在 express-generator 幫我們產生的 express 專案就幫我們寫好一些 middleware。\n預設的 middleware express-generator 在生成 express 專案時，有幫我們產生預設的 middleware。\nexpress-generator 預先產生的 middleware 在 app.js中最下面，有以下的程式碼…\n1// app.js 2 3// 若 1. 前面的 middleware 都沒人處理 或 2. 沒有比對到路徑片斷，就會到這裡。 4// catch 404 and forward to error handler 5app.use(function (req, res, next) { 6 next(createError(404)); // 引起 Error, 實際上是 HttpError，它繼承 Error。 給下一個 error-handling middleware　處理。 7}); 8 9// 最後的 error-handling middleware 10// error handler 11app.use(function (err, req, res, next) { 12 // set locals, only providing error in development 13 res.locals.message = err.message; 14 res.locals.error = req.app.get(\u0026#39;env\u0026#39;) === \u0026#39;development\u0026#39; ? err : {}; 15 16 // render the error page 17 res.status(err.status || 500); 18 res.render(\u0026#39;error\u0026#39;); 19}); 這個兩個 middleware 依序是\nregular middleware：當 1. 前面的 middleware 都沒人處理 或 2. 沒有比對到路徑片斷，就會執行。它在內部 next(createError(404))，把 error 送到下一個 error-handling middleware。 error-handling middleware：當之前的 error-handling middleware 沒有人處理回應 request，就會執行。res.render('error') 會讀入名為 error 的樣板檔案(即./view/error.hbs)，樣板帶入參數(預設是 res.locals)後，傳 html 文字給 request。 這裡的 res.locals 有兩個屬性，因為 1res.locals.message = err.message; 2res.locals.error = req.app.get(\u0026#39;env\u0026#39;) === \u0026#39;development\u0026#39; ? err : {}; 如果把上面 express-generator 預先產生的 middleware，註解掉會怎麼樣呢？　…什麼事都不會發生，因為…\nexpress 內建的 middleware express 有內建(built-in)的 middleware。\n這是寫在套件中，你改不了的。\n流(stream)：送出回應 request 流(stream) 的基本概念 stream 在 Node.js 是很常見的，其實我們常用的檔案存取都可以用 stream 來操作\n在資料傳遞的模型中，有兩個角色 producer：產生資料的人 consumer：消耗資料的人 站在 producer 的角度來看，它拿著的 stream 叫做 write stream，它透過 writeStream.write(data) 送出資料。當沒資料的時候送出 writeStream.end() 通知 consumer 已經沒資料了。\n反之，站在consumer 的角度來看，它拿著的 stream 叫做 read stream，它透過 readStream.read() 讀出資料。更仔細的說，在 read stream 中內部有一個 buffer 區塊， producer 會把資料送到 consumer 的 buffer 中，滿的時候就會叫送出 data 事件，若 readStream 有註冊事件(即 readStream.on('data', callback)) ，就會被叫起處理資料。\n我們只需了解到這，更細的說明有機會再說。\n舉個 fs 模組常用的 stream 為例子：\nfs.createWriteStream(path[, options])：建立一個 write stream，拿來寫檔 圖解 write stream 就是 fs.createReadStream(path[, options])：建立一個 read stream，拿來讀檔 圖解 read stream 就是 最後， stream 的迷人之處在於 readStream.pipe(writeStream)，就好像透過程式把兩個端點接起來，例如：copy 的 stream 版本 1// copyFile.js 2const fs = require(\u0026#39;fs\u0026#39;); 3const readStream = fs.createReadStream(\u0026#39;README.md\u0026#39;); 4const writeStream = fs.createWriteStream(\u0026#39;README.log\u0026#39;); 5readStream.pipe(writeStream); request(req), response(res) 其實分別就是 read stream 和 write steam 了解 stream 基本概念後，回來看 express 的 middleware 中 req, res，它們的真身就是：\nreq：read stream res：write steam 只不過它幫我們設定和處理 http message，像 state code, headers…之類的。\n之前說過，在 middleware中 「回應 request」 是指什麼呢？\n1res.send() 2res.file() 3res.download() 4res.json() 5res.render() 以上都是拿來回應 request， 都會引起 write steam 送出 end() 而斷掉。\n不使用 app.use(express.json()) 的後果及修正 我們曾在 Day 9 - 一周目- 開始玩轉後端(二) 中提到\n把 app.js 中的 app.use(express.json()); 註解掉會讓 req.body 讀不到 JSON 資料，這是因為 express.json() middleware 幫我們讀資料和轉換成 JSON Object。不過，我們還是可以自己處理，利用 req 這個 read stream 就可以讀出資料(使用 flowing mode，可以監聽收事件)。過程如下：\n收集所有 raw 資料(Buffer array) 用解碼 Buffer array 成 String 轉換成 JSON Object 1router.post(\u0026#39;/api/echo\u0026#39;, function (req, res, next) { 2 // decode: Buffer -\u0026gt; String 3 const { StringDecoder } = require(\u0026#39;string_decoder\u0026#39;); 4 const decoder = new StringDecoder(\u0026#39;utf8\u0026#39;); 5 6 let rawData = []; 7 req.on(\u0026#39;data\u0026#39;, (data) =\u0026gt; { // read chunk 8 rawData = rawData.concat(data); 9 }) 10 req.on(\u0026#39;end\u0026#39;, () =\u0026gt; { 11 const decodeData = decoder.end(rawData); // to String 12 console.log(decodeData); 13 14 const body = JSON.parse(decodeData); // to Object 15 mongoService.insertEcho(body) 16 .then(() =\u0026gt; { 17 res.json(body); 18 }) 19 .catch(next); // 發生 error 的話，next() 交給之後的 middleware 處理，express 有預設的處理方法 20 }); 21 }); 這樣就可以了。是不是超麻煩的？感謝 express.json() 這方便的 middleware 的存在。\n我修改過的檔案放在分支 no_express_json中，有興趣可以下載來跑看看。\n總結 今天解析了三個概念：\n中間件(middleware)：串接處理流程 路由(routing)：網址片斷串接 流(stream)：送出回應 request 他們在 express 的運作極為重要。學習時可以用 debug 模式，多下一些中斷點觀察他們跑流程，可以有很大的收穫。\n最後，我們提一些要點做為本篇的總結：\nrouter, middleware 的串接是有順序性的 每個 middleware 都要呼叫 next()，除非它是送出回應的最後 middleware 回應 request 的方法(ex: res.json()) 很多，它們會讓 res(write steam) 斷掉，重送它們會印出 Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client，但不會中斷程式和進 error-handling middleware 測驗：請自己寫一個 middleware 可以印出所有 request 的網址。解答放在 github commit\n題外話：有人把「送出回應的最後 middleware」稱作端點(endpoint)，也有人說一個 API 網址 GET /api/sayHi 是 endpoint。我想都可以，方便溝通就好。\n附錄：express middleware 運作原始碼 我把 express middleware 運作原始碼截錄下來，有興趣可以自己看一下，就會發現巧妙之處。\n1// lib/router/index.js 2proto.use = function use(fn) { 3 var offset = 0; 4 var path = \u0026#39;/\u0026#39;; 5 6 // default path to \u0026#39;/\u0026#39; 7 // disambiguate router.use([fn]) 8 if (typeof fn !== \u0026#39;function\u0026#39;) { 9 var arg = fn; 10 11 while (Array.isArray(arg) \u0026amp;\u0026amp; arg.length !== 0) { 12 arg = arg[0]; 13 } 14 15 // first arg is the path 16 if (typeof arg !== \u0026#39;function\u0026#39;) { 17 offset = 1; 18 path = fn; 19 } 20 } 21 22 var callbacks = flatten(slice.call(arguments, offset)); 23 24 if (callbacks.length === 0) { 25 throw new TypeError(\u0026#39;Router.use() requires a middleware function\u0026#39;) 26 } 27 28 for (var i = 0; i \u0026lt; callbacks.length; i++) { 29 var fn = callbacks[i]; 30 31 if (typeof fn !== \u0026#39;function\u0026#39;) { 32 throw new TypeError(\u0026#39;Router.use() requires a middleware function but got a \u0026#39; + gettype(fn)) 33 } 34 35 // add the middleware 36 debug(\u0026#39;use %o %s\u0026#39;, path, fn.name || \u0026#39;\u0026lt;anonymous\u0026gt;\u0026#39;) 37 38 var layer = new Layer(path, { 39 sensitive: this.caseSensitive, 40 strict: false, 41 end: false 42 }, fn); 43 44 layer.route = undefined; 45 46 this.stack.push(layer); 47 } 48 49 return this; 50}; 1// lib/router/route.js 2Route.prototype.dispatch = function dispatch(req, res, done) { 3 var idx = 0; 4 var stack = this.stack; 5 if (stack.length === 0) { 6 return done(); 7 } 8 9 var method = req.method.toLowerCase(); 10 if (method === \u0026#39;head\u0026#39; \u0026amp;\u0026amp; !this.methods[\u0026#39;head\u0026#39;]) { 11 method = \u0026#39;get\u0026#39;; 12 } 13 14 req.route = this; 15 16 next(); 17 18 function next(err) { 19 // signal to exit route 20 if (err \u0026amp;\u0026amp; err === \u0026#39;route\u0026#39;) { 21 return done(); 22 } 23 24 // signal to exit router 25 if (err \u0026amp;\u0026amp; err === \u0026#39;router\u0026#39;) { 26 return done(err) 27 } 28 29 var layer = stack[idx++]; 30 if (!layer) { 31 return done(err); 32 } 33 34 if (layer.method \u0026amp;\u0026amp; layer.method !== method) { 35 return next(err); 36 } 37 38 if (err) { 39 layer.handle_error(err, req, res, next); 40 } else { 41 layer.handle_request(req, res, next); 42 } 43 } 44}; ","date":"2018-10-18","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-18-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E5%89%96%E6%9E%90-express-%E8%B7%AF%E7%94%B1router-%E4%B8%89%E6%A6%82%E5%BF%B5%E4%B8%AD%E9%96%93%E4%BB%B6middleware%E8%B7%AF%E7%94%B1routing%E6%B5%81stream/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 18 - 二周目 - 剖析 Express 路由(router) 三概念：中間件(middleware)、路由(routing)、流(stream)"},{"categories":[],"content":"依賴注入套件、組態化\n回憶 昨天我們強化了後端專案結構，加入了services、daos的資料夾，這有助於切割商業邏輯，強化維護性。\n觀察一下，我們將大部分的物件建立移到 app.js 中，方便控制物件相依\n1const echoDao = new EchoDao({mongoClient: client}); 2const mongoService = new MongoService({mongoClient: client, echoDao}); 3const {createRouter: createRootRouter} = require(\u0026#39;./routes/index\u0026#39;); 4const indexRouter = createRootRouter({mongoService}); 這延申出幾個問題：\n新的 service、dao 出現的時候會越來越長 相依關係要自己串連，很不方便 太多的相依可能會忘記 不小心循環引用 目標 我們要使用依賴注入套件awilix解決上面問題。\n使用 awilix 組態化 ./configs/config.js 環境變數 process.env 過程請見 github commit log ithelp-30dayfullstack-Day17 或 codesandbox\nawilix 依賴注入 先問幾個問題：\n為什麼要用 awilix？　－　自動處理相依關係，不用手動建立 不用會怎樣？　－　不會怎樣，就自己建立物件，相依關系自己處理，有更大的彈性，但也很麻煩 有什麼好處？　－　自動處理相依關係、避免循環引用、設定物件的生命期間(Lifetime)、物件建立的程式碼會集中起來 使用 awilix 大致上的流程是\n建立 container ：awilix container 裡面會放所有「物件建立方法」、物件 register/load module ： 在 container 中，註冊「物件建立方法」 asClass, asFunction, asValue: 物件建立的方法，再用 container.register() 註冊在 container 中 1container.register({ 2 objName1: asClass(Class), 3 objName2: asFunction(factoryFunction), 4 objName3: asValue(value), 5}); container.loadModules(globPatterns, options)：loadModules() 會掃描資料夾，套用我們設定的「物件建立方法」 resolve(name) : 取出物件，這時才開始建立相依的物件 所以任何地方只要有能存取 container，就可以透過 resolve(name) 取出物件。\n用 awilix 建立物件關係 先安裝 awilix 1npm install awilix --save 註冊部分「物件建立方法」：兩個物件名 mongoClient 和 indexRouter 1// app.js 2const { createContainer, asClass, asValue, asFunction, Lifetime } = require(\u0026#39;awilix\u0026#39;); 3 4// 建立 awilix container 5const container = createContainer(); 6 7container.register({ 8 mongoClient: asValue(client, { lifetime: Lifetime.SINGLETON }), // 註冊為 mongoClient，且生命期為 SINGLETON (執行中只有一個物件) 9 indexRouter: asFunction(createRootRouter, { lifetime: Lifetime.SINGLETON }), // 註冊為 indexRouter，利用工廠函數 createRootRouter 建立物件 10}); 掃描 services, daos 資料夾 1// app.js 2container.loadModules([ 3 \u0026#39;daos/*.js\u0026#39;, 4 \u0026#39;services/*.js\u0026#39;, 5], { 6 formatName: \u0026#39;camelCase\u0026#39;, 7 resolverOptions: { 8 lifetime: Lifetime.SINGLETON, 9 register: asClass 10 } 11 }); 掃描到的檔案，因為是 module.exports = clsss 所以用 asClass 註冊。名稱命名規則為 camelCase ，生命期為 SINGLETON。例如：找到 MongoService 就好像用 1// app.js 2container.register({ 3 mongoService: asClass(MongoService, { lifetime: Lifetime.SINGLETON }), 4}); 註冊 取出名為 indexRouter 的物件 1// app.js 2const indexRouter = container.resolve(\u0026#39;indexRouter\u0026#39;); indexRouter 有指定用 createRootRouter(dependencies) 建立 (asFunction(createRootRouter))，它會拿 const {mongoService} = dependencies， mongoService 就會被 asClass(MongoService)建立，所以會一直建立相關的物件 1建立物件路徑: 2createRootRouter({mongoService}) -\u0026gt; mongoService -\u0026gt; mongoClient and echoDao 3 | 4 ∟ -\u0026gt; mongoClient awilix 幫助我們從\n1關注「建立物件」和「串接物件關係」 變成\n1關注「物件建立方法」 關連性透過命名串接，相依物件自動建立。\n組態化專案 程式中的 MongoDB 連線有寫死(hard code) 常數值\n1// daos/EchoDao.js 2class EchoDao { 3 ...略 4 async insert(data) { 5 const dbName = \u0026#39;myproject\u0026#39;; 6 const db = this.mongoClient.db(dbName); 7 ...略 8 } 9} 和\n1// app.js 2const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; 3const url = \u0026#39;mongodb://localhost:27017\u0026#39;; 4const client = new MongoClient(url, { useNewUrlParser: true }); 5...略 接下來要將它們抽出到一個 config.js 檔案，方便未來修改\n建立 ./configs/config.js 提出連線的常數\n1// configs/config.js 2module.exports = { 3 mongodb: { 4 url: \u0026#39;mongodb://localhost:27017\u0026#39;, 5 dbName: \u0026#39;myproject\u0026#39;, 6 } 7} 為 EchoDao 加入 config 相依 EchoDao 加入 config 相依 1// daos/EchoDao.js 2class EchoDao { 3 /** 4 * 5 * @param {object} config 6 * @param {MongoClient} mongoClient 7 */ 8 constructor({ config, mongoClient }) { 9 this.config = config; 10 this.mongoClient = mongoClient; 11 } 12 ...略 13} 加入名為 config 的物件建立設定 1// app.js 2const config = require(\u0026#39;./configs/config\u0026#39;); 3 4container.register({ 5 config: asValue(config, { lifetime: Lifetime.SINGLETON }), 6 ...略 7}); 為資料庫連線加入相依 為了套用控制反轉(Inversion of Control, IoC)，把連線過程放到 createMongoClient() 這工廠函數：\n建立 createMongoClient() 用來產生 MongoClient 物件 1// app.js 2/** 3 * 4 * @param {object} config 5 * @returns {MongoClient} 6 */ 7function createMongoClient({config}) { 8 const url = config.mongodb.url; 9 const client = new MongoClient(url, { useNewUrlParser: true }); 10 11 // 立即連線 12 client.connect() 13 .then((connectedClient) =\u0026gt; { 14 console.log(\u0026#39;mongodb is connected\u0026#39;); 15 }) 16 .catch(error =\u0026gt; { 17 console.error(error); 18 }); 19 return client; 20} 改成用工廠函數 createMongoClient() 1// app.js 2container.register({ 3 ...略 4 mongoClient: asFunction(createMongoClient, { lifetime: Lifetime.SINGLETON }), // 註冊為 mongoClient，且生命期為 SINGLETON (執行中只有一個物件) 5 ...略 6}); 預先引起建立 mongoClient，為了可以 儘早 連線 1// app.js 2// 預先引起建立 mongoClient 3const mongoClient = container.resolve(\u0026#39;mongoClient\u0026#39;); 4 5const indexRouter = container.resolve(\u0026#39;indexRouter\u0026#39;); 這樣就大工告成了，剩下的像是：相依注入、建立物件…等會由awilix 幫我們完成\n從執行外界接受參數 在 Day 12 - 二周目 - 準備起程深入後端 提過 Node.js 執行 js 檔時是單一行程、單一執行緒。有 golbals 的變數叫 process，它是指當前執行時的 process。 當我們執行 node ./bin/www 時 process 就會被建立，它是外界串連的橋樑。\n行程執行環境(process.env) 我們常常希望 node ./bin/www 可以從外部設定參數，像是 PORT 環境變數，就是會拿來設定 Web Server 會開啟的 port。你可以直接打開檔案./bin/www 會看到 process.env.PORT，\n1/** 2 * Get port from environment and store in Express. 3 */ 4 5var port = normalizePort(process.env.PORT || \u0026#39;3000\u0026#39;); 6app.set(\u0026#39;port\u0026#39;, port); 7...略 這裡的 process.env 物件是 process 執行時的環境變數(environment)。\n因此，下指令 PORT=3001 node ./bin/www，前面的 PORT 就會被設定在 process.env.PORT 中。若要更多環境變數就用「空白」區隔，例如 MONGODB_URL=http://localhost:27017 PORT=3001 node ./bin/www\n為 config.js 加入環境變數 利用 process.env 就可以從外界修改環境變數，不用動程式\n1const config = { 2 mongodb: { 3 url: process.env.MONGODB_URL || \u0026#39;mongodb://localhost:27017\u0026#39;, 4 dbName: process.env.MONGODB_DB_NAME || \u0026#39;myproject\u0026#39;, 5 } 6} 7module.exports = config; 小技巧：process.env.MONGODB_URL || 'mongodb://localhost:27017' 可以在 MONGODB_URL 沒設定值時使用預設值 'mongodb://localhost:27017'\n注意： process.env.XXX 是 undefined 或 string，所以萬一變數是其它的型態要進行轉型，如：\n1function __defaultFalse(bool) { 2 if(bool === \u0026#34;true\u0026#34;) { 3 return true; 4 } 5 if(bool === \u0026#34;false\u0026#34;) { 6 return false; 7 } 8 return false; 9} 10const enable = __defaultFalse(process.env.ENABLE); 為 VSCode debug 執行加入環境變數 若你是透過 VSCode debug 模式執行 js，一樣可以加入環境變數\n打開 .vscode/launch.json，加入 env 參數\n1{ 2 \u0026#34;configurations\u0026#34;: [ 3 { 4 \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, 5 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 6 \u0026#34;name\u0026#34;: \u0026#34;www\u0026#34;, 7 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/bin/www\u0026#34;, 8 \u0026#34;env\u0026#34;: { 9 \u0026#34;PORT\u0026#34;: \u0026#34;3001\u0026#34;, 10 } 11 } 12 ] 13} 執行參數(process.argv) process.argv 是另一個方法，它是執行參數的字串陣列\n範例直接來自官網：\n當執行\n1node process-args.js one two=three four process.argv陣列如下：\n10: /usr/local/bin/node 21: /Users/mjr/work/node/process-args.js 32: one 43: two=three 54: four 若要讓程式可以輸入參數，我推薦使用 argparse，可以做 cli (command-line interface) 做的比較完整。\n總結 今天我們介紹如何用 awilix 做依賴注入，讓我們從 關注「建立物件」和「串接物件關係」轉為關注「物件建立方法」。另外，用 process.env 來組態化專案，藉此來從外界接收設定值。\n","date":"2018-10-17","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-17-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5%E8%88%87%E7%B5%84%E6%85%8B%E5%8C%96%E5%B0%88%E6%A1%88/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 17 - 二周目 - 依賴注入與組態化專案"},{"categories":[],"content":"專案結構介紹、了解如何重構，將商務邏輯拆的更細\n回憶 昨天我們使用Node.js Driver 操作 MongoDB，寫出下面的程式\n1const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; 2 3// 建立連線 4const url = \u0026#39;mongodb://localhost:27017\u0026#39;; 5const dbName = \u0026#39;myproject\u0026#39;; 6const client = new MongoClient(url, {useNewUrlParser: true}); 7client.connect() 8 .then((connectedClient) =\u0026gt; { 9 console.log(\u0026#39;mongodb is connected\u0026#39;); 10 }) 11 .catch(error =\u0026gt; { 12 console.error(error); 13 }); 14 15// GET /api/mongo 16router.get(\u0026#39;/api/mongo\u0026#39;, function (req, res, next) { 17 // 回應 18 res.json({ 19 isConnected: client.isConnected(), 20 }); 21}); 22 23// GET /api/echo 24router.post(\u0026#39;/api/echo\u0026#39;, function (req, res, next) { 25 const body = req.body; 26 27 // 處理 28 const worker = (async function (data) { 29 const db = client.db(dbName); 30 const collection = db.collection(\u0026#39;echo\u0026#39;); 31 const result = await collection.insertOne(data); 32 console.log(result); 33 return result; 34 })(body); 35 36 // 回應 37 worker.then(() =\u0026gt; { 38 res.json(body); 39 }) 40 .catch(next); 41}); 會出現以下問題：\n萬一我們的 client，要在別的地方用怎麼辨？ 明明是 .src/router/index.js 路由的程式，為什麼會放資料庫連線邏輯？ 這種混雜的各種邏輯的程式要怎麼寫測試、維護？ 目標 要解決以上問題需要從專案結構下手，跟程式語言沒什麼關係。\n專案結構介紹 了解如何重構，將商務邏輯拆的更細 因為後端的目地、功能的見解、認知不同，每個人做出的專案結構一定會不一樣，這是正常的。\nexpress 的專案結構 打開 hello-mongo，我們先來看看 express 給我們預設的專案結構\nbin : Node.js 入口程式資料夾 www : Web Server 的入口 public : 存放靜態的檔案資料夾 routes : 路由資料夾 index.js : / 路由的根目路 users.js : 其它路由的範例程式 views : 網頁樣版 (我們的後端是 application server，不太用的到，不理它) error.hbs : 錯誤發生的網頁樣版 index.hbs : 首頁的網頁樣版 layout.hbs : 網頁的 layout app.js : 應用程式的初始化設定 express 提供基本的 Web Server 應該要有的目錄，但我們的後端顯然不夠，我們修改成以下\nbin : Node.js 入口程式資料夾 www : Web Server 的入口 public : 存放靜態的檔案資料夾 middlewares : 中間件(middleware)資料夾 routes : 跟它同義的有 controller。路由資料夾 index.js : / 路由的根目路 users.js : 其它路由的範例程式 app.js : 應用程式的初始化設定 services : 服務模組資料夾 daos : 資料存取模組資料夾 utilities : 共用工具資料夾 我們多出了，middlewares、services、daos、utilities，\nmiddlewares、services、daos、utilities 的職責概述：\nmiddlewares : 提供 router 使用的中間件 services : 提供 router 使用的模組，函數定義時常會 Web API 有關。可以使用其它 service 和 dao。 daos : data acess object，跟它同義的有 repositories / models(mongoose常用)。提供資料存取用，要跟資料庫互動。 utilities : 常用的工具庫，整個專案都有可能使用，所以應該要減少相依。常是一些小工具，像是：formatDate(date)。 我們依照職責概述重構程式\n重構 GET /api/mongo 重構過程見 ithelp-30dayfullstack-Day16 網頁版專案 codesandbox(只能看檔案，不能執行) 我們約定：\n類別為 MongoClient 時，建立的物件會取為 mongoClient，依些類推 把資料庫連線放到 app.js 1const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; 2const url = \u0026#39;mongodb://localhost:27017\u0026#39;; 3const dbName = \u0026#39;myproject\u0026#39;; 4const client = new MongoClient(url, { useNewUrlParser: true }); 5client.connect() 6 .then((connectedClient) =\u0026gt; { 7 console.log(\u0026#39;mongodb is connected\u0026#39;); 8 }) 9 .catch(error =\u0026gt; { 10 console.error(error); 11 }); 資料庫連線放在 app.js ，因為後端一啟動就一定要連上，不然就後面都不用玩了。\n./routers/index.js 控制反轉(Inversion of Control) 我們用 createRouter(dependencies) 包住整個程式碼，給外界注入相依後才建立 router 物件。\n./routers/index.js 相依的是 client，改成在 app.js 中才用 createRouter({client}) 注入\n1/** 2 * 3 * @param {MongoClient} client 4 */ 5function createRouter(dependencies) { 6 // Get dependencies 7 const {client} = dependencies; 8 if(!client) { 9 throw new Error(\u0026#39;client is empty\u0026#39;); 10 } 11 12 // Create a router 13 var router = express.Router(); 14 15 /* GET home page. */ 16 router.get(\u0026#39;/\u0026#39;, function (req, res, next) { 17 ...略 18 }); 19 20 router.get(\u0026#39;/api/sayHi\u0026#39;, function (req, res, next) { 21 ...略 22 }); 23 24 router.post(\u0026#39;/api/echo\u0026#39;, function (req, res, next) { 25 ...略 26 }); 27 28 router.get(\u0026#39;/api/mongo\u0026#39;, function (req, res, next) { 29 ...略 30 }); 31 32 const mongoose = require(\u0026#39;mongoose\u0026#39;); 33 router.get(\u0026#39;/api/mongoose\u0026#39;, function (req, res, next) { 34 ...略 35 }); 36 37 return router; 38} 39 40module.exports = { 41 createRouter 42}; 然後修改使用./routers/index.js 的 app.js\n1...略 2const indexRouter = require(\u0026#39;./routes/index\u0026#39;); 3...略 4app.use(\u0026#39;/\u0026#39;, indexRouter); 5...略 改成\n1...略 2const {createRouter: createRootRouter} = require(\u0026#39;./routes/index\u0026#39;); 3const indexRouter = createRootRouter({client}); 4...略 5app.use(\u0026#39;/\u0026#39;, indexRouter); 6...略 建立 MongoSevice class，放在 ./services/MongoSevice.js 1class MongoService { 2 /** 3 * 4 * @param {MongoClient} mongoClient 5 */ 6 constructor({mongoClient}) { 7 this.mongoClient = mongoClient; 8 } 9 10 /** 11 * 12 * @returns Promise\u0026lt;bool\u0026gt; 13 */ 14 isConnected() { 15 return Promise.resolve(this.mongoClient.isConnected()) 16 } 17} 18module.exports = MongoService; 我們把 GET /api/mongo 的實作放在 MongoService 的 isConnected()。\n./routers/index.js 使用 MongoService 物件 多增加一個 MongoService的依賴項，mongoService 是 MongoService 物件。\n1/** 2 * 3 * @param {object} dependencies 4 * @param {MongoService} dependencies.mongoService 5 * @param {MongoClient} dependencies.client 6 */ 7function createRouter(dependencies) { 8 // Get dependencies 9 const { client, mongoService } = dependencies; 10 if (!client) { 11 throw new Error(\u0026#39;client is empty\u0026#39;); 12 } 13 ...略 14} GET /api/mongo 改成使用 MongoService 物件\n1 router.get(\u0026#39;/api/mongo\u0026#39;, function (req, res, next) { 2 mongoService.isConnected() 3 .then(isConnected =\u0026gt; { 4 res.json({isConnected}); 5 }) 6 .catch(next); 7 }); 最後，在 app.js 建立 MongoService 物件並注入\n1const MongoService = require(\u0026#39;./services/MongoService\u0026#39;); 2 3const mongoService = new MongoService({mongoClient: client}); 4const {createRouter: createRootRouter} = require(\u0026#39;./routes/index\u0026#39;); 5const indexRouter = createRootRouter({client, mongoService}); 我們總結一下，我們所做的事\n建立了 MongoService 物件，router 會使用 MongoService 物件完成實作(ex: isConnected())而不是把實作留在 router，router 因該專心對付 web api的介接 所有物件的建立被我們移到了 app.js，它們的相依性如下圖(注：這不是UML class diagram，只是表達關係) 接下來我們可以更進一步重構 POST /api/echo，這樣我們就可以把 ./routers/index.js 對 client 的相依拿掉，讓它只面對 MongoService，之後的相依關係就更單純了。 重構 POST /api/echo 把 POST /api/echo 的資料庫操作移到 MongoService 的 insertEcho() 加入 insertEcho()後，移除 POST /api/echo 資料庫操作，且改成使用 MongoService 的 insertEcho()\n1class MongoService { 2 ...略 3 4 /** 5 * 6 * @param {*} data 7 * @returns Promise 8 */ 9 async insertEcho(data) { 10 const dbName = \u0026#39;myproject\u0026#39;; 11 const db = this.mongoClient.db(dbName); 12 const collection = db.collection(\u0026#39;echo\u0026#39;); 13 const result = await collection.insertOne(data); 14 console.log(result); 15 return result; 16 } 17} ./routers/index.js 的 POST /api/echo 變成\n1 router.post(\u0026#39;/api/echo\u0026#39;, function (req, res, next) { 2 const body = req.body; 3 4 mongoService.insertEcho(body) 5 .then(() =\u0026gt; { 6 res.json(body); 7 }) 8 .catch(next); 9 }); 移除 ./routers/index.js 對 client 的相依 因為 ./routers/index.js 沒有用到 client，可以移除了，且app.js中也不用注入 clinet了\n1const {createRouter: createRootRouter} = require(\u0026#39;./routes/index\u0026#39;); 2const indexRouter = createRootRouter({mongoService}); 我們完成了，得到更單純的關係 提出 DAO 我自可以更進一步重構出更底層的 DAO 出來，例如 EchoDao\n建立 EchoDao 1class EchoDao { 2 /** 3 * 4 * @param {MongoClient} mongoClient 5 */ 6 constructor({ mongoClient }) { 7 this.mongoClient = mongoClient; 8 } 9 10 insert(data) { 11 } 12} 13 14module.exports = EchoDao; 把 MongoService 的資料章操作移到 insertEcho() 1class EchoDao { 2 /** 3 * 4 * @param {MongoClient} mongoClient 5 */ 6 constructor({ mongoClient }) { 7 this.mongoClient = mongoClient; 8 } 9 10 insert(data) { 11 const dbName = \u0026#39;myproject\u0026#39;; 12 const db = this.mongoClient.db(dbName); 13 const collection = db.collection(\u0026#39;echo\u0026#39;); 14 return await collection.insertOne(data); 15 } 16} 17 18module.exports = EchoDao; MongoService 使用 EchoDao 加入相依\n1class MongoService { 2 /** 3 * 4 * @param {MongoClient} mongoClient 5 * @param {EchoDao} echoDao 6 */ 7 constructor({ mongoClient, echoDao }) { 8 this.mongoClient = mongoClient; 9 this.echoDao = echoDao; 10 } 11 ...略 12 13 /** 14 * 15 * @param {*} data 16 * @returns Promise 17 */ 18 async insertEcho(data) { 19 return this.echoDao.insert(data); 20 } 21} 22 23module.exports = MongoService; 修改 app.js 中 MongoService 的建立 加入 echoDao 的相依\n1const EchoDao = require(\u0026#39;./daos/EchoDao\u0026#39;); 2 3const echoDao = new EchoDao({mongoClient: client}); 4const mongoService = new MongoService({mongoClient: client, echoDao}); 重構總結 經過重構 GET /api/mongo 和 POST /api/echo，我們完成了最後的樣子\n這結構有什麼好處\n商業邏輯依照職責做分割，加強可維護性 易於加入新功能，例如：當使用者打 POST /api/echo 時輸入物件時要帶入 token 屬性值，才可寫入資料庫，我們就可以在 MongoService 加入這種邏輯。 1async insertEcho(data) { 2 const {token} = data; // 省略了值型別的驗証 3 if(token !== \u0026#39;hello-mongo\u0026#39;) { 4 return Promise.reject(new Error(\u0026#39;缺少 token\u0026#39;)); 5 } 6 return this.echoDao.insert(data); 7} 因為切割了更多檔案，所以容易多人合作且合併程式碼比較不會衝突 這種依賴注入的結構，更方便寫測試 但也有缺點\n過度設計(Over design)，增加程式的複雜度 合作時要學習更多的程式碼，過多的類別可能要花時間了解 更容易出現過渡函數，像是只把值 by-pass 往下送 1class EchoService { 2 constructor({ echoDao }) { 3 this.echoDao = echoDao; 4 } 5 async insertEcho(data) { 6 return this.echoDao.insert(data); 7 } 8} 但可以改成 1class EchoService { 2 constructor({ echoDao }) { 3 this.echoDao = echoDao; 4 this.insertEcho = this.echoDao.insert; 5 } 6} 總結一句話\n1當介面越多，越有彈性、但越複雜；彈性不夠，就抽一個介面 mongoose 重構的注意事項 mongoose 也可以進行這類似的重構，doa 可以直接用 model 替換，但有幾點要注意：\nconst Cat = mongoose.model('Cat', { name: String }) 是和 mongoose 註冊 model(只需執行一次就可以)，跟 mongoose 有沒有 connection 沒關西，只當送出資料庫操作(ex: .save())才會使用到 connection 要小心 resolve data 的型態。很可能是 model，有時可能要 model.toObject() 1 const Cat = mongoose.model(\u0026#39;Cat\u0026#39;, { name: String }); // 註冊 Cat model 2 router.post(\u0026#39;/api/cat\u0026#39;, function (req, res, next) { 3 const { name } = req.body; 4 const worker = (async function () { 5 const kitty = new Cat({ name }); 6 7 // 測試一 8 return await kitty.save(); // 回傳 model 型態 9 10 // 測試二 11 // const result = await kitty.save(); 12 // return result.toObject(); // 回傳 ojbect 型態 13 })(); 14 15 worker 16 .then(data =\u0026gt; { 17 data._dirty = \u0026#39;hi\u0026#39;; // 動態放髒東西 18 console.log(JSON.stringify(data)); 19 res.json(data); 20 }) 21 .catch(next); 22 }); 若把 mongoose 的 Model 當相依注入給 service 使用，service 就要認識 mongoose 的 api (指 mongoose 的類別、函數)。萬一，有人要換別的 ORM(應該不常發生拉)，就要所有 service 的實作都要換。因此，自己寫 dao 雖然麻煩，但還是有優點的。 總結 今天我們引入了專案結構，並實際重構 GET /api/mongo 和 POST /api/echo， 讓我們的程式碼更有結構性。\n","date":"2018-10-16","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-16-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E5%BC%B7%E5%8C%96%E5%BE%8C%E7%AB%AF%E5%B0%88%E6%A1%88%E7%B5%90%E6%A7%8B/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 16 - 二周目 - 強化後端專案結構"},{"categories":[],"content":"今天要來準備存放資料的地方 MongoDB 和如何存取裡面的資料。\n回憶 前二天我們花了很多時間在講 Prmoie 和 async/await，對於到處都是非同步的 Node.js 來說是很重要的，務必多多練習。\n目標 今天要來準備存放資料的地方 MongoDB 和如何存取裡面的資料。\n安裝 docker 安裝並執行 MongoDB 使用 MongoDB driver for Node.js 使用 mongoose Docker 架設 MongoDB 因為我希望二周目可以集中心力在講前後端，所以 Docker 的詳細使用會放到三周目，但我還是會保持最底限度的了解。\nDocker 它可以安裝在不同的作業系統，它關鍵的技術是 容器(container)。當容器初次建立時會載入某個映象檔(image)，映象檔打包著相關程式碼、函式庫、環境配置檔，然後容器就會執行在一個沙箱的執行環境。這技術跟模擬整個作業系統的虛擬機器不同，容器是更小的執行環境。\n上圖截取自 Docker Reference Architecture: Designing Scalable, Portable Docker Container Networks\n因為容器是執行在 Docker Engine 上，且我們在三周目也會自己做映象檔並寫執行組態檔，所以我們要安裝 Docer Desktop，它的功能比較多。\n用 docker 架設 mongodb docker 環境 依照自己作業系統安裝 灌完後執行 docker，就會有個常駐的小圖標 ，之後我們就可以用 docker 指令了 mongodb 容器執行 複製 hello-express專案(或繼續使用)改名成 hello-mongo。(若沒有 hello-express 的人可以看 Day 8 - 一周目- 開始玩轉後端(一))\n下載 mongodb 的映象檔 (mongodb 官方印像檔 也有其它版本可以下載)\n1docker pull mongo:4.1 docker images 可以列出有下載的映象檔，看看有沒有下載成功\n在 hello-mongo根目錄建立一個 data 資料夾 mkdir data。用來放 mongodb 的資料，可以讓 mongo 容器刪除時可以留下資料，下次建立容器可以繼續使用\nterminal 移到專安根目錄後，建立容器且執行 mongo 容器\n1docker run --name mongo4 -v $(pwd)/data:/data/db -d -p 27017:27017 --rm mongo:4.1 docker ps 確認容器有執行 我們用映象檔 mongo:4.1 建立了名為 mongo4 的容器，掛載 hello-mongo 根目錄下的 data 資料夾到容器內。容器在背景執行，且對外的 port 號是 27017。當容器停止後自行移除。\n確認 mongodb 資料庫有運行\n1docker exec mongo4 mongo --eval \u0026#34;print(version())\u0026#34; 若需要停止容器 (關掉 mongodb 資料庫)，請輸入\n1docker stop mongo4 就會停止容器並刪除\n到目前為止，我們完成了用 docker 架設 mongodb 資料庫\n若要部署 docker mongo，應該還要加上安全性的設定(像是帳密)，且用長駐的 docker container 執行(像是用 docker-compose 組態設定)\n在 Node.js 中使用 MongoDB 架設完 mongodb 資料庫後，我們就可以用 client 端連入資料庫使用了。\nmongodb官方提供很多程式語言的 driver (就是套件)連入資料庫，見 MongoDB Drivers and ODM。我們的 Node.js 是 MongoDB Node.JS Driver。\n用 mongo 指令連入資料庫 另外，我強力建議開發時，安裝 shell(cli) 版本的 client，可以方便我們直接下 mongo 指令連線後做練習和測試，但不同的作業系統有自己的安裝方法，請見 Install MongoDB。只是上面的安裝方法不僅安裝 shell 版還安裝伺服器版，也有只安裝 shell client 的方法，但請自己研究一下。\n針對有潔癖的人、不想在本機端安裝的人，我提供一個方法使用 mongo 指令，就是：\n1進入容器內 因為 mongo 容器中除了資料庫的執行檔還有包含 shell client，所以進入容器就可以使用 mongo 指令，也不用擔心本機端安裝的 shell clinet 版本號不合資料庫版本號。\n輸入 docker exec -it mongo4 bash，就可以進入容器內 就能用 mongo 指令，連入資料庫 不用的時候直接關 terniaml　或 ctrl + c 和 exit 就可以離開容器 mongo 指令直接下時是連到本機端 localhost 的 27017 port 的預設值\nNode.js Driver 連入 Node.js Driver 提供的非同步的函數，幾乎同時支援 callback 和 回傳 Promise，之後的例子我們儘量使用 Promise\n安裝 Node.js Driver\n1npm install mongodb --save 修改 ./router/index.js，使用 mongodb 套件，加入一個 GET /api/mongo api 來看 mongodb 是否連線成功\n注意: 下面的程式，每次打一次 API 都會建立一條連線，很浪費資源，晚一點我們會修改下面的程式碼\n1const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; 2 3router.get(\u0026#39;/api/mongo\u0026#39;, function (req, res, next) { 4 // mongodb 位置 5 const url = \u0026#39;mongodb://localhost:27017\u0026#39;; 6 7 // 資料庫名 8 const dbName = \u0026#39;myproject\u0026#39;; 9 10 // 連立一個 MongoClient 11 const client = new MongoClient(url, {useNewUrlParser: true}); 12 13 // client 開始連線 14 client.connect() 15 .then(() =\u0026gt; { 16 res.json({ 17 isConnected: true, 18 }); 19 }) 20 .catch(error =\u0026gt; { 21 console.error(error); 22 res.json({ 23 isConnected: false, 24 }); 25 }); 26}); 用 Postman 打看看GET /api/mongo，若有連上 mongodb\n1{ 2 \u0026#34;isConnected\u0026#34;: true 3} 若把 mongodb 關掉 (docker stop mongo4)，會得到\n1{ 2 \u0026#34;isConnected\u0026#34;: false 3} 重用(reuse)連線 1const client = new MongoClient(url); 2client.connect(); 會建立一條連線，一但接上，沒有手動 client.close() 或發生斷線，此連線不會釋放。因此，我們要留下已連線的 client，放在未來可以拿的到的地方\n1const MongoClient = require(\u0026#39;mongodb\u0026#39;).MongoClient; 2 3// index.js 執行就建立連線 4const url = \u0026#39;mongodb://localhost:27017\u0026#39;; 5const dbName = \u0026#39;myproject\u0026#39;; 6const client = new MongoClient(url, {useNewUrlParser: true}); 7client.connect() 8 .then((connectedClient) =\u0026gt; { 9 console.log(\u0026#39;mongodb is connected\u0026#39;); 10 }) 11 .catch(error =\u0026gt; { 12 console.error(error); 13 }); 14 15router.get(\u0026#39;/api/mongo\u0026#39;, function (req, res, next) { 16 res.json({ 17 isConnected: client.isConnected(), 18 }); 19}); Collection 的 CRUD (Create, Read, Update, Delete) 上一節我們談了建立連線，現在要來操作資料，先來了解 MongoDb 的名詞對比 MySQL\ntype data collection element MySQL(SQL) table record MongoDb(NoSQL) collection document MongoDB 的 document 有以下特性：\n物件資料：一個 collection 可放入很多 document，且 document的資料可以是 JSON 或 BSON (Binary JSON)。 物件格式：collection 不用預先定義 sechma，也就是 document 想塞什麼物件都可以。 插入資料 修改 POST /api/echo，利用 Immediately-Invoked Function Expressions (IIFE) 立刻執行 async function()，寫入完成後才回應 request\n1router.post(\u0026#39;/api/echo\u0026#39;, function (req, res, next) { 2 const body = req.body; 3 4 // 寫入 MongoDb 5 const worker = (async function (data) { 6 const db = client.db(dbName); 7 const collection = db.collection(\u0026#39;echo\u0026#39;); 8 const result = await collection.insertOne(data); 9 console.log(result); 10 return result; 11 })(body); 12 13 // 回應 14 worker.then(() =\u0026gt; { 15 res.json(body); 16 }) 17 .catch(next); // 發生 error 的話，next() 交給之後的 middleware 處理，express 有預設的處理方法 18}); 確認資料有寫入 shell 連入 mongodb 1mongo 127.0.0.1:27017/myproject 查看 echo 內的 document 1db.echo.find() 怎麼查文件 可能的操作很多，自己查文件比較有效率，所以說說我怎看文件的，提供剛學習的人一些方向\n一進入MongoDB Node.JS Driver，會看到 Reference 和 API Reference：你可能要學習使用，就選這個 Quick Start/Getting started：大部分的文件都會有這個，給想要立刻使用、體驗，不需要太多的預備知識。沒概念的人或新手就選這個玩一玩。 Tutorials: 學習一些必要知識的教學 API：你已有使用概念，但想要查函數的定義/簽章或看看還有提供什麼函數？ 還可以查函數名，輸入 insert，就可以查到 Collection類別的 inserOne 函數定義 例如：我要插入資料時\n怎麼拿到 collection？ db.collection('echo') 回傳 collection 物件，不是 promise 怎麼拿到 db：client.db(dbName)　回傳 db 物件，不是 promise 就可以插入資料 1const db = client.db(dbName); 2const collection = db.collection(\u0026#39;echo\u0026#39;); 3const result = await collection.insertOne(data); 我寫文章的當下也是在查文件、看用法、看函數的簽章，不是憑空寫的\n查文件的技巧是要練習的，也會越來越快。若沒概念就找 Quick Start/Getting started/Tutorials，或用 Google 找關鍵字看別人的用法，最後在學習查 API 文件或看官方教學文件。\n另外，有個叫 Dash(for mac, iOS)的軟本可以查文件用(和程式碼自動輸入)，也是可以用用看。我自己是用不習慣，所以我還是喜歡去官網看文件。\n接下來，我們最後介紹 object modeling 套件mongoose 做為結尾。\n使用 object modeling 套件：mongoose 有沒有發現 MongoDB Node.JS Driver 的 github 網址是 https://github.com/mongodb/node-mongodb-native？ node-mongodb-native 是官方提供操作 mongodb 用的底層套件，它提供的函數很底層，像我們之前的例子：\n1const db = client.db(dbName); 2const collection = db.collection(\u0026#39;echo\u0026#39;); 3const result = await collection.insertOne(data); 要一個個串起來使用。\n當後端肥大起來似乎沒這麼方便，為了提供更高層級的思維，就有人寫出 object modeling / ORM(Object-Relational Mapping) / ODM(Object Document Mapper) 這類的套件，甚至不同資料庫、不同的程式語言大多有。\n1為了把資料(document/record)當做是物件，當操作物件時，套件會自己使用底層套件與資料互動。 你可以想想以自己寫 SQL 的經驗，ORM套件使你從串SQL文字解脫，變成物件的操作。但也不是這麼美好，因為你又要多學一個套件，不同的 ORM 也可能有不同的用法。\n要不要用見人見智(見：Should I Or Should I Not Use ORM ?)，我是覺得要用，寫起來比較快，但也要學會用底層套件，因為當你預到效能問題或ORM 套件有bug，才有解套的可能。我的學習策略是先用底層套件 mongodb，等用一陣子才引入 mongoose，你會了解用/不用 mongoose 後的酸甜苦辣。\nQuick start 這例子來自mongoose 官方首頁， 直接表明了核心想法\n1// 建立連線 2const mongoose = require(\u0026#39;mongoose\u0026#39;); 3const dbName = \u0026#39;myproject\u0026#39;; 4mongoose.connect(`mongodb://localhost:27017/${dbName}`); // resolve with Connection value 5 6// 定義 \u0026#34;Cat\u0026#34; 的模型(也可以說是Schema)，預設的 collection 的名稱會用復數、小寫，所以是 \u0026#34;cats\u0026#34; 7const Cat = mongoose.model(\u0026#39;Cat\u0026#39;, { name: String }); 8 9// 建立物件 10const kitty = new Cat({ name: \u0026#39;Zildjian\u0026#39; }); 11 12// 存入資料庫 13kitty.save().then(() =\u0026gt; console.log(\u0026#39;meow\u0026#39;)); 有幾點要知道一下：\nmongoose 有一個預設的 connection，mongoose.connect() reolve value 是 Connectino 物件。若需要建立更多的連線可以用 mongoose.createConnection()(見：Multiple connections) CRUD 可能有型如：xxx()，xxxMany()，xxxOne() find() 是回傳的 Query，不是資料本身 Query 和 Aggregate　使用時可能會用鍊式語法，最後才用 exec() 實際送出查詢 總結 今天我們利用 Docker 架設 MongoDB，還用 Node.js Driver 連入後插入資料。最後介紹 object modeling 套件 mongoose，方便我們對 MongoDB 操作。\n","date":"2018-10-15","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-15-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E7%94%A8-docker-%E7%8E%A9%E8%BD%89-mongodb/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 15 - 二周目 - 用 Docker 玩轉 MongoDB"},{"categories":[],"content":"從 Promise 昇華到 async:await\n修正 2019-02-18 謝謝 文祥 的提醒\n此處的例子太過複雜沒有表現出 依序/順序 的重點。內文增加一些說明，如下： 回憶 昨天介紹了非同步神器 Promise 來包裝非同步函數穫得不用帶入 callback 當參數的簽章，爾後還可以使用 then().catch() 的鍊式語法\n目標 今天要來介紹\nPromise 解決了什麼問題？ asyn/await 這語法糖衣讓語法更自然 他們要怎麼選用？ 非同步 callback 的產生的 callback hell 非同步的函數通常要帶入 callback function當參數，等到結果出來才會被呼叫。若一大堆非同步串在一起就會出現 callback hell：\n下圖截自 Node 7.6 + Koa 2: asynchronous flow control made right 以昨天 Day 13 - 二周目 - 非同步神器 Promise 的例子來說： 兩個函數 fetchOrders() 和 fetchPerson()\n1function fetchOrders(person) { 2 const orders = person.orderIds.map(id =\u0026gt; ({ id })); 3 return Promise.resolve(orders); 4} 5 6function fetchPerson(name) { 7 return Promise.resolve({ 8 name, 9 orderIds: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] 10 }); 11} 可以串成\n1fetchPerson(\u0026#39;Billy\u0026#39;) 2 .then(fetchOrders) 3 .then(orders =\u0026gt; { 4 orders.forEach(order =\u0026gt; { 5 console.log(order); 6 }) 7 }) 8 .catch(console.error); 若是 callback 版本就是像\n1// callback version with arrow functions 2fetchPerson(\u0026#39;Billy\u0026#39;, (error, person) =\u0026gt; { 3 if(error) { 4 console.error(error); 5 return; 6 } 7 fetchOrders(person, (_error, orders) =\u0026gt; { 8 if(_error) { 9 console.error(_error); 10 return; 11 } 12 orders.forEach(order =\u0026gt; { 13 console.log(order); 14 }); 15 }) 16}); 為了必免混淆，我們刻意把內層的 error 改成 _error\n若沒有箭頭函數，更會使人抓狂\n1// callback version with normal functions 2fetchPerson(\u0026#39;Billy\u0026#39;, function (error, person) { 3 if(error) { 4 console.error(error); 5 return; 6 } 7 fetchOrders(person, function (_error, orders) { 8 if(_error) { 9 console.error(_error); 10 return; 11 } 12 orders.forEach(order =\u0026gt; { 13 console.log(order); 14 }); 15 }) 16}); callback 版本的的問題：\n可讀性大幅度降低 處理錯誤發生的程式都要重寫一次，就算抽出一個共用的錯誤處理函數，也是要寫呼叫錯誤處理函數 因此，Promise 的出現可以降低 callback hell 的發生 (可能從第18層地獄到第2層地獄)。\nthen()...catch() 鍊式語法的問題：非同步函數簽章需完整契合 then()...catch() 鍊式語法也不是沒有問題，我們注意看函數簽章\nfetchPerson() 的簽章：function(name: string): Promise\u0026lt;object\u0026gt; fetchPerson(name)，這裡 name 是 string，resolve value 是 object fetchOrders() 的簽章：function(person: {orderIds: array\u0026lt;string\u0026gt;}): Promise\u0026lt;array\u0026lt;object\u0026gt;\u0026gt; fetchOrders(person)，這裡 person 是 object且有一個orderIds屬性的字串陣列，resolve value 是 object 的陣列 為了更清楚表達：這裡我們偷引入JSDoc 1. A: B 用在參數時, 後面(B)是前面參數名(A) 的型態 2. function(): C 用在函數時 在後面(C)就是函數的回傳 3. Promise\u0026lt;D\u0026gt; 是指 Promise 的 resolve value 型態是 D 4. array\u0026lt;E\u0026gt; 是指型態 E 元素的陣列 5. {propertyName: F} 是指一個物件有 propertyName 屬性，且型態是 F\n為了讓 then() 可以串接，fetchPerson()　回傳的 resolve value 必需有 object且有一個orderIds屬性的字串陣列，或者說 fetchOrders()的實作要認識 fetchPerson() 的回傳才可以\n1fetchPerson(\u0026#39;Billy\u0026#39;) 2 .then(fetchOrders) 然而，實務上不太可能，因為非同步函數可能不是你寫的。\n若改成 fetchOrders(orderIds)，參數改成是字串陣列\n1function fetchOrders(orderIds) { 2 const orders = orderIds.map(id =\u0026gt; ({ id })); 3 return Promise.resolve(orders); 4} 5 6function fetchPerson(name) { 7 return Promise.resolve({ 8 name, 9 orderIds: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] 10 }); 11} 對應的鍊式就要改成\n1fetchPerson(\u0026#39;Billy\u0026#39;) 2 .then(person =\u0026gt; { 3 const {orderIds} = person; 4 return fetchOrders(orderIds); 5 }) 6// 或直接解構 7fetchPerson(\u0026#39;Billy\u0026#39;) 8 .then(({orderIds}) =\u0026gt; { 9 return fetchOrders(orderIds); 10 }) 我們只需要多一個箭頭函數就可以解構 person 的 orderIds，再往下傳。 解構的程式是少不了的，但這樣不是又多出了一個 callback function嗎？\n非同步語法糖衣 async/await async/await的出現解開了前面的麻煩，我們先看最後的樣子： 我們的目地是從名字(name) 查詢出訂單(orders)，所以命名一個函數 getOrdersFromPersonName\n1async function getOrdersFromPersonName(name) { 2 const person = await fetchPerson(name); 3 const {orderIds} = person; 4 const orders = await fetchOrders(orderIds); 5 return orders; 6} 使用如下：\n1getOrdersFromPersonName(\u0026#39;Billy\u0026#39;) 2 .then(orders =\u0026gt; { 3 orders.forEach(order =\u0026gt; { 4 console.log(order); 5 }) 6 }) 7 .catch(console.error); getOrdersFromPersonName()的實作看起來就像是同步函數，只要：\ngetOrdersFromPersonName() 定義前面加上 async 所有回傳 Promise 的非同函數前面都可以加上 await ，被加上時就會等到 resolve value 出現程式才會往下走 使用起來很簡單、自然。\n接下來，來詳細的說明 async/await\nasync function() 是回傳 Promise 定義時加入 async 的函數會變成回傳Promise，且實作中的 return 的值會被當做 resolve value。他的規則如同 Day 13 - 二周目 - 非同步神器 Promise 中 .then(callback) 的 callback 的回傳。若：\n回傳 Primitive值：如undefined, object, number, string\u0026hellip;等，async getOrdersFromPersonName() 會回傳 resolve promise 回傳 Promise：async getOrdersFromPersonName()會和回傳的 promise 同樣狀態 1async getOrdersFromPersonName() { 2 return Promise.resolve(); 3} 4getOrdersFromPersonName(); // resolve promise 1async getOrdersFromPersonName() { 2 return Promise.reject(); 3} 4getOrdersFromPersonName(); // reject promise async function() 的 reject 處理 在 getOrdersFromPersonName(name) 裡的 執行路徑上 所有 await 的 Promise 物件有任何一個 reject，則程式會 跳離 getOrdersFromPersonName()，且 getOrdersFromPersonName() 會回傳 reject promise 而且 reason 是發生 reject promise 的 reason。\n1async function getOrdersFromPersonName(name) { 2 const person = await fetchPerson(name); // 若 reject, 則 getOrdersFromPersonName() reject　且是 fetchPerson() 引起的 reason 3 const {orderIds} = person; 4 const orders = await fetchOrders(orderIds); // 若 reject, 則 getOrdersFromPersonName() reject 且是 fetchOrders() 引起的 reason 5 return orders; 6} 就好像丟出一個例外(exception)，只是不會引起例外，而是變成 reject promise.\n怎麼攔截內部的 reject reason 我們可以用 try..catch 攔截中間的 reject reason，例如：\n1async function getOrdersFromPersonName(name) { 2 let person; 3 try { 4 person = await fetchPerson(name); 5 } catch(error) { // 處理 reject reason，讓程式繼續 6 console.warn(error); 7 person = {name: \u0026#39;訪客\u0026#39;}; 8 } 9 10 const {orderIds} = person; 11 const orders = await fetchOrders(orderIds); 12 return orders; 13} fetchPerson(name) 丟出的 error reason 會被 try..catch 攔截，然後 getOrdersFromPersonName() 繼續執行。\n若都不寫 try..catch，async function getOrdersFromPersonName(name) 就像是有個超大的try..catch包著，所以 getOrdersFromPersonName(name)的執行不可能丟出例外，最多只會變成 reject prmoise。因此，async function() 可以說被保護著，但在強調一次\n1Promise 可能會發生 reject，強健的程式應該要 \u0026#34;.catch()\u0026#34; reject reason，不然就漏接了。 上圖來自A quick guide to JavaScript Promises\n可以在裡面丟出例外 你可以在 async function() 中使用 throw 丟出例外，也可以用 try...catch攔截。\n1async function foo() { 2 try { 3 throw new Error(\u0026#39;foo 1\u0026#39;); 4 } (error) { 5 console.error(error); 6 throw new Error(\u0026#39;foo 2\u0026#39;); 7 } 8} 9 10foo(); // reject promise with Error(\u0026#39;foo 2\u0026#39;) reason 這樣就會變成回傳 reject promise。\n你也可以用 return Promise.reject() 直接表明回傳的東西，如下\n1async function foo() { 2 try { 3 throw new Error(\u0026#39;foo 1\u0026#39;); 4 } (error) { 5 console.error(error); 6 return Promise.reject(new Error(\u0026#39;foo 2\u0026#39;)); 7 } 8} 9 10foo(); // reject promise with Error(\u0026#39;foo 2\u0026#39;) reason 我個人是習慣用 return Promise.reject()，因為比較好掌控自己有處理過的例外，也知道是哪產生的。若出現沒看過的reject reason 表示有潛在的例外可能會發生，而是 async function() 幫你處理了。\nasync/await VS Promise 物件用誰？它們可以互相取代嗎？ 這問題我覺得沒有一定答案？拿它們來比較有點怪，因為各有各的優、缺點和用法，找到自己的程式風格和混合使用才能有比較好的可讀性。\nPromise 適合拿來\n包裝具有 callback 的函數，以修改函數簽章 支援度，但 async/await 就算不支援也可以用轉譯的 鍊式寫起來可以用比較短的程式碼，不像 async function() 還要包裝 截斷中間的 reject promise，debug 時很好用，反觀 async function() 要用 try...catch這種產生分支的語法。 1Promise.resolve(1) 2 .then(() =\u0026gt; Promise.reject(new Error(\u0026#39;error 1\u0026#39;))) 3 .catch(error =\u0026gt; { 4 console.log(error); 5 return Promise.reject(error); 6 }) 7 .then(() =\u0026gt; Promise.resolve(2)) 8 .then(console.log) 9 .catch(console.error) async function() 適合拿來\n當一連串非同步操作都要是 resolve時，一個工作才算完成 當一個工作worker是由多個非同步(子)工作依序/順序執行 resolve，工作才能算 resolve。 下面的例子中，subworker3() 要等到 subworker2() resolve 才能決定是否執行。\n1async function worker() { 2 const resolve1 = await subworker1(); 3 const resolve2 = await subworker2(); 4 if(/* resolve2 don\u0026#39;t have something*/) { 5 return Promise.reject(new Error(\u0026#39;something miss\u0026#39;)); 6 } 7 const resolve3 = await subworker3(); 8 return computer(resolve1, resolve2, resolve3); 9} 10worker(); subworker1() -\u0026gt; subworker2() -\u0026gt; subworker3() 依序 resolve， worker 才會 resolve。\n眼尖的讀者會發現 subworker1(), subworker2() 是可以 並發 執行，而不用 依序/順序執行，這樣可以比較有效率，所以我們用 Promise.all() 增進效率。\n1async function worker() { 2 const reslut_1_2 = await　Promise.all([subworker1(), subworker2()]); 3 const resolve1 = reslut_1_2[0]; 4 const resolve2 = reslut_1_2[1]; 5 if(/* resolve2 don\u0026#39;t have something*/) { 6 return Promise.reject(new Error(\u0026#39;something miss\u0026#39;)); 7 } 8 const resolve3 = await subworker3(); 9 return computer(resolve1, resolve2, resolve3); 10} 11worker(); 若是全改用 prmoise 會很麻煩(尤其是有條件出現)\n1const workerPromise = Promise.all([subworker1(), subworker2()]) 2 .then(([resolve1, resolve2]) =\u0026gt; { 3 if(/* resolve2 don\u0026#39;t have something*/) { 4 return Promise.reject(new Error(\u0026#39;something miss\u0026#39;)); 5 } 6 return subworker3().then(resolve3 =\u0026gt; ([resolve1, resolve2, resolve3])); 7 }) 8 .then(([resolve1, resolve2, resolve3]) =\u0026gt; { 9 return computer(resolve1, resolve2, resolve3); 10 }) 11workerPromise // promise 這裡偷用了 Promise.all(promises)， promises 是一個 promise array, 所有的 promise 都要 resolve，Promise.all(promises) 才會 resolve，否則就是 reject。Promise.all(promises) 的 resolve value 是 promise array 的 resolve array。\n可讀性好，看起來像同步函數\n保護未處理到的例外，因為 asyn function() 不會丟出例外，只有 reject promise\n最後，還有一點很重要\n1Promise 和 async/await 可以執行在 Node.js 和 瀏覽器(但可能要轉譯)。 補完 Promise 的相關函數 .finally()：除了 .then() 和 .catch()外，還有一個 .finally()， 這是不論怎麼是 reject / resolve 都一定會回調，通常用在進行一些事後處理或清理用不到的資料。 bluebird：標準 Promise 提供建立 Promise 物件的建構函數只有：Promise.resolve()、Promise.reject()、Promise.all()、Promise.race()。有點不夠用，bluebird 提供更多好用的 Promise 相關函數，像是要求 map 產生的 Promise 元系依序執行 Promise.mapSeries()…等 總結 今天再深入的探討 Promise 、引入 async/await 和比較它們。它們在 Node.js 和 瀏覽器扮演很重要的角色，所以它們值得我們花兩天學習。\n","date":"2018-10-14","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-14-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E5%BE%9Epromise-%E6%98%87%E8%8F%AF%E5%88%B0-asyncawait/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 14 - 二周目 - 從Promise 昇華到 Async:await"},{"categories":[],"content":"今天要來談怎麼利用計時器(timer)函式setTimeout做出非同步執行的函數和用 Promise 包裝非同步函數。\n回憶 昨天我們提到 Node.js 非阻塞的特色，其實可以說 Node.js 到處都是非同步執行。\n目標 今天要來談怎麼利用計時器(timer)函式setTimeout做出非同步執行的函數和用 Promise 包裝非同步函數。\n自己做的非同步執行的函數：由同步轉成非同步 我們可以由同步的程式，改寫成非同步函數。\n考慮以下同步函數，addSum 是累加函數\n1// 同步 2function addSum(numbers) { 3 let sum = 0; 4 numbers.forEach(number =\u0026gt; sum = sum + number); 5 return sum; 6} 7const numbers = [1, 2]; 8console.log(addSum(numbers)); // 3 先想介面：怎麼回傳？透過一個 callback function\n1// 同步 2function addSum(numbers, callback) { 3 let sum = 0; 4 numbers.forEach(number =\u0026gt; sum = sum + number); 5 callback(sum); 6} 7const numbers = [1, 2]; 8addSum(numbers, sum =\u0026gt; { 9 console.log(sum); 10}) 11console.log(\u0026#39;done\u0026#39;); 結果：\n13 2done addSum(numbers, callback)看起來是不是有非同步的影子了阿。但他其實還是同步函數，只是在內部呼叫 callback(sum)。\n調用系統計時器 setTimeout()\n1// 非同步 2function addSum(numbers, callback) { 3 setTimeout(() =\u0026gt; { 4 let sum = 0; 5 numbers.forEach(number =\u0026gt; sum = sum + number); 6 callback(sum); 7 }, 0); 8} 9const numbers = [1, 2]; 10addSum(numbers, sum =\u0026gt; { 11 console.log(sum); 12}) 13console.log(\u0026#39;done\u0026#39;); 結果：\n1done 23 雖然我們設定 0 秒，但不是指馬上執行，setTimeout() 會把裡面的 callback 放到 event loop 中的 queue (見 Day 12 - 二周目 - 準備起程深入後端)。當 addSum() 執行完後，console.log('done')印出 done，然後 event loop 就再迴圈一次，重新執行所有 queue 中的 callback function，發現我們有送入\n1() =\u0026gt; { 2 let sum = 0; 3 numbers.forEach(number =\u0026gt; sum = sum + number); 4 callback(sum); 5} 就開始執行，callback 這變數因為箭頭函數產生閉包 (見：Day 5 - 一周目- 從VSCode debug 模式看作用域(Scope)、this、閉包(Closure))，如下圖：\ncallback有值，值是我們送入的\n1sum =\u0026gt; { 2 console.log(sum); 3} 所以 callback(sum) 最後印出 3\n這樣就完成了把同步函數 addSum(numbers) 轉成非同步函數 addSum(numbers, callback)。\n惡搞：你可以把 setTimeout() 改成 setInterval()，setInterval() 會一直在指定時間內重做(直到你 clearInterval())，我們改成 1000 ms，就會一直印出 3。 你可以想想為什麼程式停不了？因為 event loop 的 timer queue 的 callback 一直在的關係，queue 永遠非空。\n需要自己做的非同步函數的情況，我還真的比較少發生，因為這表示你用到大量的CPU計算，這時候你應該開子行程(subprocess)處理，主行程改用非同步呼叫子行程處理，這個技巧未來會提。反而，大部分是要重新包裝非同步函數，或使用別人的非同步函數。\n在 Node.js 中，也提供 nextTick, setImmediate，它們都可以用來做非同步函數，可以看以下文章 1. 詳解 setTimeout、setImmediate、process.nextTick 的區別 2. Node探秘之事件循環（2）\u0026ndash;setTimeout/setImmediate/process.nextTick的差別\n包裝非同步函數 非同步操作如下(截錄自從Promise開始的JavaScript異步生活)\n使用計時器(timer)函式: setTimeout, setInterval 特殊的函式: nextTick, setImmediate 執行I/O: 監聽網路、資料庫查詢或讀寫外部資源 訂閱事件：常用 on('event name', callback) 訂閱 1,2 常用來引起非同步，而 3,4 常用需要包裝非同步函數，使用我們的後端更有可讀性。\n包裝神器 Promise Promise 是一個物件，它遵從Promises/A+標準，下圖截錄自 Promises/A+標準定義 Promise 建立時是 pending 狀態，它可收到 value (透過resolve(value)) 就被鎖定成 fulfilled，不然就是收到 reason (透過reject(reason), reason 一般是 Error 物件)就被鎖定成 rejected。鎖定後再也動不了。\nPromise物件的建立方法如下：\n1new Promise((resolve, reject) =\u0026gt; { 2}); (resolve, reject) =\u0026gt; {} 這是 Promise 物件建立時就要立刻傳入的東西，也會立刻執行。 這裡我們可以用 resolve(value) 通知此 Promise resolve，也可以用 reject(error) 通知此 Promise reject。\n用 Promse 包裝 addSum(number, callback)：改變函數簽章 addSumPromise(numbers) 我們曾提過 Pomise 方便的地方在於可以用 then().catch() 鍊式語法，所以我們把 addSum(numbers, callback)包裝成 addSumPromise(numbers)，它回傳 Promise 物件，就可以用鍊式語法\n1// 包裝非同步回傳 Promise 2function addSum(numbers, callback) { 3 setTimeout(() =\u0026gt; { 4 let sum = 0; 5 numbers.forEach(number =\u0026gt; sum = sum + number); 6 callback(sum); 7 }, 0); 8} 9function addSumPromise(numbers) { 10 return new Promise((resolve, reject) =\u0026gt; { 11 addSum(numbers, sum =\u0026gt; { 12 resolve(sum); 13 }) 14 }); 15} 16const numbers = [1, 2]; 17addSumPromise(numbers) 18 .then(sum =\u0026gt; { 19 console.log(sum); 20 }) 21console.log(\u0026#39;done\u0026#39;); 我們利用回傳 Promise 物件，可以把 callback 參數拿掉，就可以享有鍊式語法。\n強化 addSumPromise() 參數處理 有沒有發現我們的 addSum() 很脆弱，可以加入一些判斷使它強健一點。例如我們要確保 numbers 是 Array，若不是的話就回傳的 reject promise\n1// 包裝非同步回傳 Promise 2function addSum(numbers, callback) { 3 setTimeout(() =\u0026gt; { 4 let sum = 0; 5 numbers.forEach(number =\u0026gt; sum = sum + number); 6 callback(sum); 7 }, 0); 8} 9function addSumPromise(numbers) { 10 return new Promise((resolve, reject) =\u0026gt; { 11 if(!Array.isArray(numbers)) { 12 reject(new Error(\u0026#39;numbers is not a Array\u0026#39;)); 13 return; // 這行要寫，雖然Promise 狀態不變，但下面的程式一樣會執行 14 } 15 addSum(numbers, sum =\u0026gt; { 16 resolve(sum); 17 }) 18 }); 19} 20const numbers = {}; 21addSumPromise(numbers) 22 .then(sum =\u0026gt; { 23 console.log(sum); 24 }) 25console.log(\u0026#39;done\u0026#39;); 就可以得到 addSumPromise({}) 會得到一個 reject promise。我們注意以下幾點：\nconsole.log('done') 一樣有執行，不會因為 reject promise。 新版的Node.js 現在會告訢你有一個未處理的 Promise，且這 Error 不是例外發生，不會引起程式插斷(interrupts)，執行會一直下去。因此，你不處理的話就這錯誤就不見了。 所以改成下面\n1addSumPromise(numbers) 2 .then(sum =\u0026gt; { 3 console.log(sum); 4 }) 5 .catch(error =\u0026gt; { 6 console.error(error); 7 }) 這麼一來 Promise 就處理完所有的非同步的情況了。\n小總結 我們舉了 addSum(numbers, callback)為例子，再用 Promise 包裝改成像是 addSum(number)。早期非同步函數中，常常有 callback function 當參數，callback 的簽章一般是(err, value) =\u0026gt; ...，常會利用上述方法包裝成 Promise 的版本方便使用。另外，Node.js 也提供 util.promisify() 快速轉換。\n最近的套件有時也會同時提供兩種版本(callback版或回傳Promise)，像是 Node.js MongoDB Driver API 或是 fs-extra。 fs-extra 我會拿來取代原生的 fs，它也提供好用的函數。另外，在Node.js 10 以後，fs.promises 也開始支援 Promise版。\nthen().catch() 鍊式語法：Promise 物件好用之處 then().catch() 可以說是 Promise 的核心之一，then() 和 catch()函數被 Promises/A+ 規定要回傳 Promise，他可以讓我們的非同步操作串接起來。\nthen(callback)/catch(callback)的 callback 叫起與回傳 then(callback)/catch(callback) 中的 callback 被叫起：\naPromise.then(callback)：當 aPromise resolve時，resolve value 送入 callback(value) aPromise.catch(callback)：當 aPromise reject，reject reason 送入 callback(reason) then(callback)/catch(callback) 中的 callback 可以回傳：\n回傳 Primitive值：如undefined, object, number, string\u0026hellip;等，then() 會回傳 resolve promise 1 .then(() =\u0026gt; ({name: \u0026#39;Billy\u0026#39;})) // resolve promise 回傳 Promise：then()會和回傳的 promise 同樣狀態 1 .then(() =\u0026gt; Promise.resolve()) // resolve promise 1 .then(() =\u0026gt; Promise.reject()) // reject promise 這裡的：Promise.resolve() 直接回傳 reolve promise 物件；Promise.reject() 直接回傳 reject promise 物件\n其實：then()的完整簽章是：then(resoveCallback, rejectCallback)，這個我比較少用，反而常用then(resoveCallback).catch(rejectCallback)\n一個鍊式例子 例如，我們要查詢一個人的訂單要做兩個非同步的查詢：\nfetchPerson(name)　－　查人 fetchOrders(person)　－　查此人的訂單 1// then()　鍊式 2function fetchOrders(person) { 3 const orders = person.orderIds.map(id =\u0026gt; ({ id })); 4 return Promise.resolve(orders); // 直接回傳 reolve promise 物件 5} 6 7function fetchPerson(name) { 8 // return Promise.reject(new Error(\u0026#39;name is not string\u0026#39;)); // 直接回傳 reject promise 物件 9 return Promise.resolve({ 10 name, 11 orderIds: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] 12 }); 13} 14 15fetchPerson(\u0026#39;Billy\u0026#39;) 16 .then(fetchOrders) 17 .then(orders =\u0026gt; { 18 orders.forEach(order =\u0026gt; { 19 console.log(order); 20 }) 21 }) 22 .catch(console.error); 我們利用 then() 把非同步操作串接起來，且 fetchPerson()、fetchOrders()任一個Promise 發生 reject 才會引起 .catch() 發生。若前面的任一個Promise reject，後面的 then() 都不會發生直到 catch()。（你可以把解開註解看看 // return Promise.reject(new Error('name is not string'));）\n.catch()常犯的錯：.catch(callback) 可能是回傳 resolve promise 在用鍊式時你可能會想要截斷某個reject，查看結果，常會寫以下的程式\n1Promise.resolve(1) 2 .then(() =\u0026gt; Promise.reject(new Error(\u0026#39;error 1\u0026#39;))) 3 .catch(console.error) 4 .then(() =\u0026gt; Promise.resolve(2)) 5 .then(console.log) 6 .catch(console.error) 這結果是\n1Error: error 1 22 這是因為 .catch(console.error) 寫清楚一點就是\n1function catch(error) =\u0026gt; { 2 return console.error(error); // console.error() 回傳 undefined 3} 因為回傳 undefined，所以 .catch() 的回傳是 resolve promise，這使下一行的 .then(() =\u0026gt; Promise.resolve(2))執行。因此，你若要保持 reject 往下傳，要用 Promise.reject()\n1Promise.resolve(1) 2 .then(() =\u0026gt; Promise.reject(new Error(\u0026#39;error 1\u0026#39;))) 3 .catch(error =\u0026gt; { 4 console.error(error); 5 return Promise.reject(error); 6 }) 7 .then(() =\u0026gt; Promise.resolve(2)) 8 .then(console.log) 9 .catch(console.error) 才會得到\n1Error: error 1 2Error: error 1 Promise 的例發發生會導致 reject 一但進入 Promise後在內部的執行不論在哪丟出例外都會導致 promise reject\n1// Promise 的例外發生 2function somePromise() { 3 return new Promise((resolve, reject) =\u0026gt; { 4 // throw new Error(\u0026#39;constructor error\u0026#39;); 5 resolve(); 6 }); 7} 8somePromise() 9 .then(sum =\u0026gt; { 10 // throw new Error(\u0026#39;resolve error\u0026#39;); 11 console.log(\u0026#39;done\u0026#39;); 12 }) 13 .catch(error =\u0026gt; { 14 console.error(error); 15 }); 你可以解開註解看看，都是會產生 reject promise。\n這事實可以看成是，Promise 幫我們包住了所有例外，某方面降低了程式當掉的可能。\n總結 今天如何利用 setTimeout() 做非同步函數，還用 Promise 包裝它，且介紹 then().catch()鍊式語法。\n","date":"2018-10-13","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-13-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%A5%9E%E5%99%A8-promise/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 13 - 二周目 - 非同步神器 Promise"},{"categories":[],"content":"在一周目最後，用非同步 request 串接前後端做為一周目的收尾。\n回憶 恭喜你!! 完成了龐大一周目，我們在一周目11天內介紹了很多東西、工具，像是\n下指令、Markdown 開專案 draw.io VSCode Chrome devTools Postman 也寫了簡單的前後端\nhello-express hello-react 在一周目最後，用非同步 request 串接前後端做為一周目的收尾。\n二周目的進行方法 完成一周目的你已經掌握了我們在Day 1 - 前言／開發環境準備中提到的一周目目標：快速了解前後端在串什麼東西。原則上前面的知識已經可以開始開發自己的前後端，只是會覺得東缺西缺、不方便、效能不好或寫程式一直重覆程式碼，一但出現上述問題，恭喜你!有進步機會了!\n接下來二周目要更深了解前後端，以主題式的方式進行，每篇應該都可以獨立看，可以自行選擇需要的看。\n我覺得比起講如何套用，動機比較重要，所以我可能會花些時間在那，舉些什麼情況導致我們引入新的概念。這也跟學習過程經驗相近，遭遇困難、引入新東西、解決它。\n前後端開發前的準備工作 軟體開發流程或方法論有很多種，且會因為公司、時間、人有所不同(見 軟體開發流程是什麼？PM與UX Designer的區別？)，但從開發者的角度來看，以下工作多少都出現：\n企畫/需求分析：程式的目地性？有沒有意義？怎麼整合之前的軟體？ 軟體架構規畫：資料要存哪？資料如何串接？串接介面為何？要開幾個伺服器？效能好不好？有沒有彈性？需要認証機制？ 前端開發：畫面草稿(UI markup)？使用者操作感受如何(UX)？如何切版成HTML/CSS？怎麼串後端資料？ 後端後端：資料怎麼連線存取？認証機制怎麼實作？效能能否改善？程式能不能重用、模組化？ 發佈、測試：怎麼發佈前後端的程式？要發佈在哪個主機、雲端？需要申請DNS、SSL嗎？如何開防火牆？怎麼測試？上線後怎麼維運、監控？ 上述種種問題全端工師都可能要面對，甚至有我沒有列舉到的。每個環節都息息相關，不論你是想學前端還是後端，多了解都是有幫助的。\n這文章很有趣：App / Web 開發工程師的三大錯覺，搞懂了就能成為大師，提出有趣的錯覺： 1. 錯覺一：「寫 app 專注在前端 (front-end) 就好了，不需要懂後端 (back-end)。」 2. 錯覺二：「只要寫 React native 就不用碰到 iOS / Android 的 code。」 3. 錯覺三：「這個 bug 我只要一個小時就能搞定。」\n問題很多，但先從寫後端商業邏輯 (當碼農)，是個不錯開始 寫後端商業邏輯你會直接碰到需求並實作，會考慮：\n需求如何實現？　－　商業邏輯就是需求，用程式碼實現。 資料怎麼存？ －　資料可以存在記憶體、本地端硬碟還是資料庫，資料庫又可以讓各個後端連線、共享資料。 寫完的商業邏輯如何提供服務？　－　採用Web API讓外界與你的後端互動，並告訢前端要打什麼API。 怎麼發佈？　－　最簡單的方法就是在背景執行npm run start 開始深入Node.js 接下來，看看看 Node.js 的特色\nNode.js 是單執行緒(single thread) 執行緒(Thread), 行程(Process)\u0026hellip;!! 沒學過作業系統嗎？沒關西，這不是作業系統的課，了解概念就好。\n首先，一隻程式是在執行時會把程式碼載入記憶體中等待 CUP 執行，這在記憶體中的實體就叫 Process。為了更有效率的使用 CPU，人們發明了更小執行單位，Thread，它是CUP最小的執行單位。\n一般而言，一個 Process 可以有多個 Thread，以達到 CPU 多工， 而 Node.js 有一個很重要的事實\n1它只有一個執行緒(thread) 也就是 Node.js 在執行的時候，只產生一個 Process，且裡面只有一個 Thread。\n有人會問：是不是說他的效率不好呢？也不是這麼說。不論一個 Process 內有多少Thread，都還是會受到 CUP 實際可以運算的數量(ex: 四核、八核)限制。太多的Thread會反而會造成排程(scheduling)的系統負擔。反觀，單執行緒就只佔一個CPU運算單位，執行幾個 Node.js 程式就可以利用多少CPU。那…能不能說 Node.js 效能比其它語言好？我想是不能的，因為還要考慮程式碼的複雜程度、CPU的排程…等。\n下圖是執行 hello-express 的結果 關於有Process/Thread興趣的人可以看看： Program/Process/Thread 差異\n非阻塞 還記得我們在 Day 11 - 一周目- 開始玩轉前端(二)提到的非同步概念嗎？在 Node.js 中因為大量的使用非同步函數，所以產生非阻塞的特色。\n用官方的讀檔例子 來說，檔案相關的模組 fs，大部分同時提供非同步和同步函數，像是讀檔就有兩個 fs.readFile()　fs.readFileSync()：\n1const fs = require(\u0026#39;fs\u0026#39;); 2const data = fs.readFileSync(\u0026#39;/file.md\u0026#39;); // blocks here until file is read 3console.log(data); 4moreWork(); // will run after console.log 上面的例子，moreWork(); 會等到 fs.readFileSync() 讀檔完成才執行。\n改成非同步的版本\n1const fs = require(\u0026#39;fs\u0026#39;); 2fs.readFile(\u0026#39;/file.md\u0026#39;, (err, data) =\u0026gt; { 3 if (err) throw err; 4 console.log(data); 5}); 6moreWork(); // will run before console.log moreWork() 會在還沒讀檔完成前就會執行。\n非阻塞的特色在處理 request 的 web server 很有幫助，一個 request 來的時後很多時候都要到資料庫讀取資料(I/O)。若讀取資料的操作是同步時，我們要等到資料庫回傳資料程式才能往下執行，這時其它的 request 都要等之前 request 結束才能換它們處理。然而，若讀取資料的操作是非同步時，我們就可以用等資料庫回傳前的時間來處理其它 request。\n我們可以做個實驗，hello-express之前做了兩個 API， GET /api/sayHi、POST /api/echo，把 GET /api/sayHi 內的 res.sned('hi') 註解，就假設我們做的非同步的I/O，一直沒給回應。若這時用 Postman 打他 Postman不會給回應，因為我們一直不送出結果(除非 request timeout)。\n若馬上發出 POST /api/echo 會發現，一樣可以馬上回應，就算前一個 request 還沒完成，Node.js 還是可以回應其它的 request。\nNode.js適合 I/O bound 的工作，不適合 CPU bound 的工作 Node.js 是單執行緒，若你的程式是計算型的程式，需要大量的 CPU 運算 (CPU bound)，其它的工作會因為計算而卡住。因為 Node.js 預期你的程式可以並發(Concurrency)，只留下非同步的callback，等別人完成(ex: 資料庫回應，或I/O 結束)再來繼續執行。這非阻塞的特色，使得等待可以被覆蓋(或者說同時等待)進而提高吞吐量(throughput)\nEvent Loop 實現非阻塞 Event Loop 是實現非阻塞操作的關鍵技術，不過我沒打算太詳細的說它，因為先了解運作、寫寫程式，抓到感覺再去深入也不遲。有基本的了解就足以應付大部分的情形了。\nEvent Loop，大致上長的像\n1 ┌───────────────────────────┐ 2┌─\u0026gt;│ timers │ 3│ └─────────────┬─────────────┘ 4│ ┌─────────────┴─────────────┐ 5│ │ pending callbacks │ 6│ └─────────────┬─────────────┘ 7│ ┌─────────────┴─────────────┐ 8│ │ idle, prepare │ 9│ └─────────────┬─────────────┘ ┌───────────────┐ 10│ ┌─────────────┴─────────────┐ │ incoming: │ 11│ │ poll │\u0026lt;─────┤ connections, │ 12│ └─────────────┬─────────────┘ │ data, etc. │ 13│ ┌─────────────┴─────────────┐ └───────────────┘ 14│ │ check │ 15│ └─────────────┬─────────────┘ 16│ ┌─────────────┴─────────────┐ 17└──┤ close callbacks │ 18 └───────────────────────────┘ 圖片的串起來的每個區塊都是 queue，裡面放著一堆等待被執行的 callback fucntion ，queue 中的執行順序是 先進先出(First In First Out, FIFO)，區塊由上到下執行，直到所有的 queue 都空了，執行就會結束，關掉 process。\n看下面的程式：\n1const a = \u0026#39;hi\u0026#39;; 2setTimeout(() =\u0026gt; { 3 console.log(\u0026#39;bye\u0026#39;); 4}, 1000); // 1秒後執行 callback() 5console.log(\u0026#39;done\u0026#39;); 過程如下：\n當執行到 setTimeout(callback)，會把 callback 放到 timers 中。 console.log('done') 執行完，理當要結束的，但因為 timers 裡面還有東西，所以就一直等(loop的檢查每一個 queue) 直到時間到，callback 執行完， timers 也空了 當所有的 queue 都空，程式就結束了 我只提了大概的運作，這也足夠應付大部分的情形，有更多的細節請看 The Node.js Event Loop, Timers, and process.nextTick()。若你注重效能、寫底層的套件、遭遇callback/Promise太多導致記憶體不足的人，我覺得一定要看。\n這文章 setTimeout async promise執行順序總結 的例子可以自己猜猜看結果。不過正常人應該不會寫出這種程式： async/await, setTimeout, Promise並發(Concurrency)，又要管 console.log 的順序\n總結 今天提了全端工程師可能遭遇的問題。此外，也提點了 Node.js 的特性：\n單執行緒 非阻塞 Node.js適合 I/O bound 的工作 Event Loop 實現非阻塞 題外話：我希望可以用白話的說法解釋概念，所以今天的文字有點多。\n","date":"2018-10-12","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-12-%E4%BA%8C%E5%91%A8%E7%9B%AE-%E6%BA%96%E5%82%99%E8%B5%B7%E7%A8%8B%E6%B7%B1%E5%85%A5%E5%BE%8C%E7%AB%AF/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 12 - 二周目 - 準備起程深入後端"},{"categories":[],"content":"發出一個非同步 request 串接後端\n回憶 昨天介紹了 React 和完成用 create-react-app 建立了第一個 React app\n目標 發出一個非同步 request 串接後端 在開始前，我們先來談談「非同步」\n非同步函數是什麼？ 來看看一個同步的例子： 打開 hello-react，在 public 資料夾建立一個檔案 ayncRequest.html：內容如下 1\u0026lt;!-- ayncRequest.html --\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;body\u0026gt; 4 \u0026lt;div\u0026gt;before script\u0026lt;/div\u0026gt; 5 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 6 console.log(\u0026#39;hi\u0026#39;); // 在 Console 印出 \u0026#34;hi\u0026#34; 7 \u0026lt;/script\u0026gt; 8 \u0026lt;div\u0026gt;after script\u0026lt;/div\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; 執行 npm run start 開啟Chrome 再開 devTools，並選擇 Console 頁籤，打開 http://localhost:3000/ayncRequest.html 剛剛的頁面 會看到以下的結果 console.log() 會印出訊息在 Console 中 瀏覽器頁面渲染到一半，一看到 \u0026lt;script/\u0026gt; 就會立刻執行裡面的 javascript，也就是說 console.log() 立刻被執行\n1對於頁面渲染，console.log() 是同步地被執行。 試試看：你可以用 debug 模式証實它真的有停在那裡。若不會操作，可以看 Day 10- 一周目- 開始玩轉前端(一) 一個非同步的例子： 修改 ayncRequest.html 加入 setTimeout()\n1\u0026lt;!-- ayncRequest.html --\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;body\u0026gt; 4 \u0026lt;div\u0026gt;before script\u0026lt;/div\u0026gt; 5 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 6 console.log(\u0026#39;hi\u0026#39;); // 在 Console 印出 \u0026#34;hi\u0026#34; 7 setTimeout(() =\u0026gt; { 8 console.log(\u0026#39;time up\u0026#39;); // 兩秒後印出 \u0026#34;time up\u0026#34; 9 }, 2000); 10 \u0026lt;/script\u0026gt; 11 \u0026lt;div\u0026gt;after script\u0026lt;/div\u0026gt; 12\u0026lt;/body\u0026gt; 13\u0026lt;/html\u0026gt; 再次刷新頁面 我們發現瀏覽器頁面渲染完後，等二秒後才會執行 console.log('time up')。\n瀏覽器在執行渲染時， 下面的箭頭函\n1() =\u0026gt; { 2 console.log(\u0026#39;time up\u0026#39;); // 兩秒後印出 \u0026#34;time up\u0026#34; 3} 被 setTimeout() 存在某個地方後，頁面渲染結束後(看到 before script / after script)，等個兩秒，箭頭函數才被執行。此時的箭頭函數叫 callback function。\n1對於頁面渲染，console.log() 是非同步地被執行。因為箭頭函數的執行不是透過「頁面渲染」執行的。 下面的專案很有趣 loupe by Philip Roberts，可以看到瀏覽器非同步執行過程。\n所以…結論是？ 很有趣的是，我找不到有人給出非同步函數正式定義，因為非同步函數無法單獨定義，它是由行為所導致結果，如：「頁面渲染」因為 setTimeout()導致「頁面渲染」是非同步的執行(見：Node.js Asynchronous Function Definition Ask Question)。\n本節最後，我說說我對非同步函數的看法是：\n當一函數無法立刻得到執行函數的目地，就是非同步函數。一般利用 callback function 回傳結果。\n所以未來看到一個函數參數有定義 callback function 大部分都是非同步函數。\n以後在二周目我們將會看到如何做出非同步執行的函數：\n利用 setTimeout()…系列 Promise async/await 串接後端 上章提出了「非同步」的概念，現在來使用非同步函數，來發出非同步 request 的與伺服溝通。\n準備環境 打開並執行 hello-react前端開發網頁伺服器 打開 Day 9 - 一周目- 開始玩轉後端(二) 建的 hello-express，它有 POST /api/echo API 因為前端占用 3000 prot，後端要更改 port，修改 package.json 1\u0026#34;scripts\u0026#34;: { 2 \u0026#34;start\u0026#34;: \u0026#34;PORT=3001 node ./bin/www\u0026#34; 3}, PORT是環境變數，port 換成 3001 處理 Cross-origin resource sharing (CORS)問題。因為我們把前後端分開，在前端網頁會打非同步api(request)到不同主機的位置，瀏覽器 基於安全性會拒絕 request，且會出現下圖： 後端安裝套件 npm install cors --save 後端修改 ./app.js 1// 加在前面 2var cors = require(\u0026#39;cors\u0026#39;); 3 4// 加在　var app = express(); 之後 5app.use(cors()); // 加入一個 middleware 此 middleware 加入後，express 會在 response header 回應加入一些訊息，讓瀏覽器辯識前端網站是否可以打到後端伺服器。為了方便，我們先不做任何設定，如此一來，後端會 無條件地允許 任何來源的前端網站發出 request(正常發佈時不應該讓任何人都可以打，未來會給出解決方法)。 執行 npm run start 前端主機是 http://localhost:3000 後端主機是 http://localhost:3001\n你可以用瀏覽器試試是否有正常運作或用 Postman\n發出一個非同步 request 主要有兩個方法\nXMLHttpRequest 物件 fetch() 函數 XMLHttpRequest XMLHttpRequest 是比較是很早期就出現的東西，用起來有點麻煩。使用前要建立 XMLHttpRequest 物件，再設定一些 callback，才送出 request。\n開啟前端 ./src/App.js，加入 componentDidMount()成員函數 1class App extends Component { 2 componentDidMount() { 3 // 送到後端的資料 4 const data = { 5 name: \u0026#39;Billy\u0026#39; 6 }; 7 8 // 用 XMLHttpRequest 發起一個非同步的 request 9 const xhr = new XMLHttpRequest(); 10 xhr.onreadystatechange = () =\u0026gt; { 11 if (xhr.readyState === 4) { // readyState == 4 為 request 完成 12 const contentType = xhr.getResponseHeader(\u0026#39;content-type\u0026#39;); 13 if (xhr.status === 200 \u0026amp;\u0026amp; contentType \u0026amp;\u0026amp; contentType.indexOf(\u0026#39;application/json\u0026#39;) \u0026gt; -1) {　// 依回應的資料格式處理，我們只處理 200 \u0026amp;\u0026amp; application/json 14 try { 15 var result = JSON.parse(xhr.responseText); 16 console.log(result) 17 } catch(e) { 18 console.error(e); 19 } 20 } else { 21 console.error(new Error(\u0026#39;無法得到資料\u0026#39;), xhr.responseText); 22 } 23 } 24 } 25 xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;http://localhost:3001/api/echo\u0026#34;); // 開啟連線 26 xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); // 設定 header 27 xhr.send(JSON.stringify(data)); // 以文字字串送出JSON資料 28 } 29 30 render() { 31 ... 32 } 33} 得到結果 這裡 componentDidMount() 是當 component 的渲染結果(html)插入 DOM tree 中就會呼叫。\n使用 XMLHttpRequest 物件，以文字字串送出(send()) JSON 資料。因為有設定 Content-Type: application/json;charset=UTF-8，所以後端可以解讀。\n每次 request 狀態改變，onreadystatechange 就會被呼叫，當 readyState 等於 4 就是 request 完成(不論成功還是失敗)。更多狀態見：AJAX - onreadystatechange 事件\nfetch() fetch() 是比較新的函數，支援度也不錯，更重要的是，它可以當函數直接用，回傳 Promise 物件。 Promise 可以說是 javascript 最重要的物件，它包裝非同步操作，只要用 then(resolveCallback).catch(rejectCallback)，就可以接收非同步的結果。我們在二周目會再次見到它。\n把上 使用 XMLHttpRequest 物件的　componentDidMount()，全部註解掉，貼上下面程式，也會得到一樣的結果\n1componentDidMount() { 2 // 送到後端的資料 3 const data = { 4 name: \u0026#39;Billy\u0026#39; 5 }; 6 7 // 用 fetch() 發起一個非同步的 request 8 fetch(\u0026#34;http://localhost:3001/api/echo\u0026#34;, { 9 method: \u0026#34;POST\u0026#34;, 10 headers: { 11 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json; charset=utf-8\u0026#34;, 12 }, 13 body: JSON.stringify(data), 14 }) 15 .then(response =\u0026gt; response.json()) // 取出 JSON 資料，並還原成 Object。response.json()　一樣回傳 Promise 物件 16 .then(data =\u0026gt; { 17 console.log(data); 18 }) 19 .catch(e =\u0026gt; { 20 console.error(e); 21 }); 22 } fetch() 是不是用起來比較自然一點了，可讀性增加了。fetch().then(resolveCallback1).then(resolveCallback2).catch(rejectCallback) 是一種鏈式語法，就是一直串下去要做的事。\n流程如下：(你先不要看解釋，看程式就大概可以猜到過程了)\nfetch() 一但成功取得資料，假設叫 request，就會把request往下一個 then()裡面的 callback 傳，就如同執行 resolveCallback1(request)。 resolveCallback1(request) 回傳一個由response.json() 產生的 Promise 物件，也會繼續如同之前一樣。 response.json() 成功時取得資料，假設叫 data，就會往下一個 then()裡面的 callback 傳，就如同執行 resolveCallback2(data)。 最後 catch(rejectCallback)中的 rejectCallback什麼時後被叫呢？就是 fetch() 、 resolveCallback1() 或 resolveCallback2 有任何失敗或產生例外。 then(resolveCallback).catch(rejectCallback)用起來有點像 try...catch，但強多了，配合 async/await 這語法糖衣，又可以拆掉鍊式語法得到像同步的程式碼。我只寫出結果，看看它利害的地方，以後我們再談它們\n1componentDidMount() { 2 // 送到後端的資料 3 const data = { 4 name: \u0026#39;Billy\u0026#39; 5 }; 6 7 const workerPromise = (async () =\u0026gt; { 8 // 用 fetch() 發起一個非同步的 request，等待回傳結果 9 const response = await fetch(\u0026#34;http://localhost:3001/api/echo\u0026#34;, { 10 method: \u0026#34;POST\u0026#34;, 11 headers: { 12 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json; charset=utf-8\u0026#34;, 13 }, 14 body: JSON.stringify(data), 15 }) 16 17 // 等待 response.json() 回傳的 JSON 物件 18 const resultData = await response.json(); 19 return resultData; 20 })(); 21 22 workerPromise 23 .then(data =\u0026gt; { 24 console.log(data); 25 }) 26 .catch(e =\u0026gt; { 27 console.error(e); 28 }); 29 } 把結果顯示在網頁上 接下來，後端的結果顯示在網頁上。\n加入 App　的成員變數 state，用來記錄 App component 的內部狀態 1state = { 2 name: \u0026#39;\u0026#39;, 3} 在 console.log(data) 後面加入 1this.setState({ 2 name: data.name, 3}); setState() 會更新的 state 內的值，並引起 App component 重新渲染 render()。 使用內部狀態 state，修改 render()， 1render() { 2 return ( 3 \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; 4 Hello React: {this.state.name} 5 \u0026lt;/div \u0026gt; 6 ); 7} 完整的 App component 如下：\n1class App extends Component { 2 state = { 3 name: \u0026#39;\u0026#39;, 4 } 5 6 componentDidMount() { 7 // 送到後端的資料 8 const data = { 9 name: \u0026#39;Billy\u0026#39; 10 }; 11 12 // 用 fetch() 發起一個非同步的 request 13 fetch(\u0026#34;http://localhost:3001/api/echo\u0026#34;, { 14 method: \u0026#34;POST\u0026#34;, 15 headers: { 16 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json; charset=utf-8\u0026#34;, 17 }, 18 body: JSON.stringify(data), 19 }) 20 .then(response =\u0026gt; response.json()) // 取出 JSON 資料，並還原成 Object。response.json()　一樣回傳 Promise 物件 21 .then(data =\u0026gt; { 22 console.log(data); 23 24 // 更新的 state 內的值，並再一次引起渲染 render() 25 this.setState({ 26 name: data.name, 27 }); 28 }) 29 .catch(e =\u0026gt; { 30 console.error(e); 31 }); 32 } 33 34 render() { 35 return ( 36 \u0026lt;div className=\u0026#34;App\u0026#34; \u0026gt; 37 Hello React: {this.state.name} 38 \u0026lt;/div \u0026gt; 39 ); 40 } 41} 得到結果\n總結 今天引進了非同步的概念，並利用 XMLHttpRequest 物件 和 fetch() 函數引發一個 非同步的 request，得到結果後重新渲染畫面。\n","date":"2018-10-11","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-11-%E4%B8%80%E5%91%A8%E7%9B%AE-%E9%96%8B%E5%A7%8B%E7%8E%A9%E8%BD%89%E5%89%8D%E7%AB%AF%E4%BA%8C/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 11 - 一周目- 開始玩轉前端(二)"},{"categories":[],"content":"介紹 React、用create-react-app 建立，我們第一個前端網頁\n回憶 昨天後端完成了二隻apiGET /api/asyHi 和 POST /api/echo，以及用 POSTMAN 發出 request 到後端並得到回應。 同時，也提到可以用 Chrome devTools 來監控網路 request。\n目標 介紹 React 用create-react-app 建立，我們第一個前端網頁 React 是什麼？ React 是 Facebook 所開發的一個專案，現在能如此風行有很大的原因是開放社群，開發出以React 為基礎/相關的套件，然而之前有暴出 license 的問題，使人想要退出 React。2017/09/25 正式的改成 MIT license，license 的問題得到了解決(參考：為什麼Facebook更改了React.js的授權？、五種開源授權規範的比較 (BSD, Apache, GPL, LGPL, MIT) )\nReact 是用來建立使用者介面(UI, user interface)的 javascript 程式庫/套件，它讓我們可以用 Component 組成復雜的 UI。看以下官方例子：\n1class ShoppingList extends React.Component { 2 render() { 3 return ( 4 \u0026lt;div className=\u0026#34;shopping-list\u0026#34;\u0026gt; 5 \u0026lt;h1\u0026gt;Shopping List for {this.props.name}\u0026lt;/h1\u0026gt; 6 \u0026lt;ul\u0026gt; 7 \u0026lt;li\u0026gt;Instagram\u0026lt;/li\u0026gt; 8 \u0026lt;li\u0026gt;WhatsApp\u0026lt;/li\u0026gt; 9 \u0026lt;li\u0026gt;Oculus\u0026lt;/li\u0026gt; 10 \u0026lt;/ul\u0026gt; 11 \u0026lt;/div\u0026gt; 12 ); 13 } 14} 15 16// Example usage: \u0026lt;ShoppingList name=\u0026#34;Mark\u0026#34; /\u0026gt; 用JSX 語法建立 Component 首先，\u0026lt;ShoppingList/\u0026gt; 就是一個 Component，他是由「像是」 html tag 的 \u0026lt;div/\u0026gt;、\u0026lt;hi/\u0026gt;、\u0026lt;ul/\u0026gt;、\u0026lt;li/\u0026gt; 組成的。怎麼說「像是」，有注意嗎？我們 不是 寫文字的 \u0026quot;\u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt;\u0026quot;，反是直接寫 \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; 這類 XML-like，這就是 JSX語法，它是個語法糖衣(Syntatic Sugar)，它會被轉譯器(transpiler)轉成 javascript\n1class ShoppingList extends React.Component { 2 render() { 3 return React.createElement( 4 \u0026#34;div\u0026#34;, 5 { className: \u0026#34;shopping-list\u0026#34; }, 6 React.createElement( 7 \u0026#34;h1\u0026#34;, 8 null, 9 \u0026#34;Shopping List for \u0026#34;, 10 props.name 11 ), 12 React.createElement( 13 \u0026#34;ul\u0026#34;, 14 null, 15 React.createElement( 16 \u0026#34;li\u0026#34;, 17 null, 18 \u0026#34;Instagram\u0026#34; 19 ), 20 React.createElement( 21 \u0026#34;li\u0026#34;, 22 null, 23 \u0026#34;WhatsApp\u0026#34; 24 ), 25 React.createElement( 26 \u0026#34;li\u0026#34;, 27 null, 28 \u0026#34;Oculus\u0026#34; 29 ) 30 ) 31 ); 32 } 33} React.createElement() 會回傳 React element，它們是組成 React app 最小的區塊，在 React 會維護自己的虛擬 DOM (React DOM)，可以想像成如同 HTML DOM tree 一樣，然後 React DOM 會比較 tree 的差異，進而更新 HTML DOM。\nReact 沒有規定一定要用 JSX 語法，只是推薦使用，畢竟最後還是轉成 javascript React.createElement()。\nShoppingList component 類別 接下來，ShoppingList 他是一個 Class，他繼承 React.Component，所以就享有 Component 的功能，像是、Props、State 和 生命周期(Lifecycle)。\n建立 instance(即 React element) 不是用直接 new ShoppingList()，而是透過 JSX 語法建立：\n1\u0026lt;ShoppingList name=\u0026#34;Mark\u0026#34; /\u0026gt;; 將會轉譯\n1React.createElement(ShoppingList, { name: \u0026#34;Mark\u0026#34; }); 他會把 ShoppingList class 送入，交給 React 建立 ShoppingList instance 和遞迴地建立 render() 裡面的所有 \u0026lt;XXX /\u0026gt;。\n誰是入口點？ 最後的問題是：誰來用 \u0026lt;ShoppingList name=\u0026quot;Mark\u0026quot; /\u0026gt;？誰是 React app 的入口點？\n在網頁讀取完後，一般會立刻執行 ReactDOM.render()，引發進入 React app 的渲染(render)，而更新 HTML DOM。 類似下面\n1\u0026lt;html\u0026gt; 2\u0026lt;body\u0026gt; 3 \u0026lt;div id=\u0026#39;root\u0026#39;\u0026gt;\u0026lt;/div\u0026gt; 4 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 5 const element = \u0026lt;ShoppingList name=\u0026#34;Mark\u0026#34; /\u0026gt;; 6 ReactDOM.render(element, document.getElementById(\u0026#39;root\u0026#39;)); 7 \u0026lt;/script\u0026gt; 8\u0026lt;/body\u0026gt; 9\u0026lt;/html\u0026gt; ReactDOM.render() 會渲染 react element 進 HTML DOM 中的 \u0026lt;div id='root' \u0026gt; 容器內，把 React app 和 HTML DOM 串連起來。\n誰來轉譯 JSX? 轉譯器有很多（見 Transpilers ），較常見的是 babel，它可以把 JSX 語法轉成 javascript。\n先等等，為什麼 babel 會知道 \u0026lt;ShoppingList name=\u0026quot;Mark\u0026quot; /\u0026gt; 轉成 React.createElement(ShoppingList, { name: \u0026quot;Mark\u0026quot; })，React.createElement() 是哪設定的，以後有 MIT.createElement() 可不可以？這是因為在轉譯前有設定 babel 的 preset，見下圖 preset 選擇 react ，所以 babel 才知道要怎麼轉譯。再存細看一下，還有看到其它的 preset, es20XX 之類的，這表示 babel 可以認得的語法更多更新，都可以轉成更廣範使用/更低階/更原生的 javascript 語法，像是我們用的 ES6 語法中的 Class，可以用 babel 轉換成 更原生 javascript 這表示 在當代瀏覽器就算沒支援太新的語法，還是可以透過轉譯器轉換成當代支援的 javascript。早期 ES6 語法未被瀏覽器支援前就是如此，開發者使用較方便的語法開發，再轉換成可以支援javascript。\n轉譯器也可以說是 編譯器(compiler)，因為它的行為就是從一個語言換成另一個語言，就像 C++ 的編譯器一樣把原始碼轉轉二進碼。\n第一個前端 React 網頁 經過前一章的解釋有沒有發現，建立一個 React app 很不容易？要準備 component 原始碼、轉譯器、還要連結 React 和 DOM…等，一堆設定會使人怯步。\n拜很多大神所賜，我們現在開發 React app 只要專注在 component，其它的有人會幫你設好。我們採用 create-react-app，這也是 Facebook 的專案，使得 React app 的建立更方便。\n用 create-react-app 建立 hello-react 安裝 create-react-app 指令\n1sudo npm install -g create-react-app 開一個 hello-react 的資料夾，並移入\n1mkdir hello-react 2cd hello-react 建立 hello-react 的 React app 專案\n1create-react-app . 會建立以下的檔案 這就是 Node.js 的專案，src 資料夾放的就是前端的 React 程式碼。\n執行開發用伺服器\n1npm start 這時開啟開發伺服器，自動開啟一個網頁 http://localhost:3000/ 會看到這結果，就是一個 React app。\ncreate-react-app 幫我們設定了什麼？ 除了基本的 React app 專案的設定，還設定了一些開發時實用的東西\n開發用網頁伺服器 程式碼異動監控 語法檢查 網頁除錯模式 測試模式 發佈靜態檔案 脫離 create-react-app 提供的開發環境 開發用網頁伺服器 當執行 npm start 就可以執行開發伺服器。因為單單只有網頁原始碥是沒法在網頁看到結果，所以執行開發伺服器會進行之前所提的轉譯…等，並自動的開啟 React app 的網頁。\n程式碼異動監控 不只如此，當程式碼發生異動時，還會自動重讀網頁\n把 .src/App.js 改成如下：\n1import React, { Component } from \u0026#39;react\u0026#39;; 2import \u0026#39;./App.css\u0026#39;; 3 4class App extends Component { 5 render() { 6 const foo = \u0026#39;foo\u0026#39;; 7 return ( 8 \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; 9 Hello React 10 \u0026lt;/div\u0026gt; 11 ); 12 } 13} 14 15export default App; 存檔後回到網頁上看，網頁會自動重新整理\n語法檢查 也設定了 ESLint，就如同我們在 Day 6 - 一周目- 程式碼品質工具ESLint，照顧程式碼風格 中設定 Node.js 專案的程式碼品質監控。\n只是把 ESLint 組態設定放在 package.json 裡的 eslintConfig。這裡 ESLint 也可以找的到組態設定。 網頁除錯模式 它也幫我們設定可以在 Chrome devTools 裡進行除錯。\n打開 Chrome devTools 後，選 Source 頁籤，按下 command + p (Mac) / ctrl + p(windows)，輸入 App 過濾找到 App.js 源始碼。接下來你就可以像 VSCode debug 模式一樣下中斷點除錯。記得下完中斷點要重讀網頁才會觸發網頁 javascript 重新執行。\n測試模式 另開啟一個 ternimal 執行 npm run test ，就可以開啟測試監控。它會掃描專案中的所有測式檔案並執行測試，當程式異動時它還會自動重新執行測試。未來我們會在二周目再做說明。\n發佈靜態檔案 寫好的 React app 透過 npm run build，就會把原始碼轉譯、打包成少數js檔案，產生 build 資料夾，裡面就是純前端網頁的所有靜態檔案，把它們放在任何網頁伺服器(ex: nginx) 就可以透過瀏覽器讀取。\n脫離 create-react-app 提供的開發環境 不喜歡它提供的開發環境嗎？ npm run eject 脫離他的開發環境。 會專案會變成 這就是他的開發環境本來的面貌：用到 Webpack, Babel, ESLint, Jest，和腳本…等。所有的工具都是要安裝、設定才能用在開發環境，對於新手來說超不友善，所以 create-react-app 幫我們省去了不少麻煩，專心開發 React app。\n本主題不會脫離 create-react-app 的開發環境，所以不需要執行npm run eject。\n這過程是不可還原的，所以用之前確認清楚。\n我自己測試時發現，create-react-app 在建立 React app 時有開 local git repository，如果沒 commit 的異動檔案，npm run eject 不能運作。 總結 今天我們介紹了 React 和使用在裡面的 JSX 語法，也用 create-react-app 建立了第一個 React app並說明他提供的開發環境。\n","date":"2018-10-10","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-10-%E4%B8%80%E5%91%A8%E7%9B%AE-%E9%96%8B%E5%A7%8B%E7%8E%A9%E8%BD%89%E5%89%8D%E7%AB%AF%E4%B8%80/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 10- 一周目- 開始玩轉前端(一)"},{"categories":[],"content":"做第一隻API、requests工具\n回顧 昨日建立我們的一個後端伺服器，今天來做第一隻API\n目標 自己的第一隻API 使用 Chrome devTool 查看 requests POSTMAN 手動發出 requests 你的第一個api 我們曾在 Day 8 - 一周目- 開始玩轉後端(一) 提及基於 http(s)協定下的Web API (Application Programming Interface)。Web API 常用來：\n系統間的介面：不同的系統間用 Web API 來串接，例如：現在很火的 chat bot (Line Messaging API)　的 webhook，由你的系統提供 Web API (即 webhook)，當有訊息時，Line 的系統會送 request 給你。 前後端溝通介面：前後端架構中，後端會定義API，提供給前端網頁用非同步的request，查詢後端API。後端API會集中心力在處理商業邏輯和資料，而前端會集中心力在做畫面和使用者體驗。 API 怎麼帶資料傳送 我們不會涉及太深入的 http(s)協定，只需要基本的了解就可以了。 從瀏覽器的角度看，有兩個訊息會傳送和接收：Request Message 和 Response Message。 他們都有 header 和 body 區塊。header 會記錄一些 Metadata；而 body 是主要要傳送的資料。\nHTTP Request Message Format(From: The TCP/IP Guide) 是發起查詢的人送出的訊息，像是瀏覽器 送出headers，內容包含： http(s)/API 的查詢方法(如GET/POST )、客戶端能了解的資料格式(如圖中 Accept: text/html, text/plain) 送出body：送給接收端(後端)的資料，通常會加入 content-type header，讓接收端了解資料的格式 HTTP Response Message Format(From: The TCP/IP Guide) 是接收端收到 request message 後做出的回應，像是後端伺服器對API的查詢結果做出回應 訊息要包含狀態代碼(status code)，表示API 的查詢狀態代碼，如：大名鼎鼎的 404，找不到網頁/資源。這狀態代碼後端想傳什麼都可以，但有些狀態代碼有被加入規範中，儘量不要重覆到，因為瀏覽器可能會依照代碼給錯誤訊息。通常 200 是指 request 成功得到正常的 response 跟 request 一樣，通常會加入 content-type header，使送訊息者(前端)了解 body 的格式 以下是從 Chrome devtools 截下來的實例： 實際上，不單只有資料，雙方送出的 header 會更多，互動的行為才會更強健(robust)。\nbody 資料像什麼？ 上面我們的知道了 content-type header，會用來告訢接收端資料的格式，方便接收端解讀資料。它可能的值見 Multipurpose Internet Mail Extensions (MIME) type。\n我們的前後端架構中，希望後端只送「純」資料給前端，而前端自己才產生HTML，所以我們採用 JSON 格式，它是以易於閱讀的 文字 為基礎，來傳送資料。JSON 的官方定義 MIME 為 application/json。如下圖： 除了MIME 外，還用 charset 指明文件的編碼。\n很幸運地，javascript 由原始型別(Primitives)，像是 string, number, null, boolean, Array, Object， 組成的 object，剛好符合JSON格式。如：\n1const person = { 2 id: \u0026#39;001\u0026#39;, 3 name: \u0026#39;Billy\u0026#39;, 4 married: false, 5 friendIds: [\u0026#39;002\u0026#39;, \u0026#39;003\u0026#39;], 6 accessories: [{ 7 name: \u0026#39;眼鏡\u0026#39;, 8 brand: null, 9 price: undefined, // 這裡偷放了 `price: undefined`，序列化會自動過濾。 10 }], 11}; 因為object中都是用原始型別組成的 ，所以它們可以正常轉成文串，也就是JSON 可序列化(JSON serializable)\n1console.log(JSON.stringify(person)); // {\u0026#34;id\u0026#34;:\u0026#34;001\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Billy\u0026#34;,\u0026#34;married\u0026#34;:false,\u0026#34;friendIds\u0026#34;:[\u0026#34;002\u0026#34;,\u0026#34;003\u0026#34;],\u0026#34;accessories\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;眼鏡\u0026#34;,\u0026#34;brand\u0026#34;:null}]} 來吧！建立第一個API 打開昨天建的hello-express 打 ./router/index.js檔案 建立第一隻 GET API 1var express = require(\u0026#39;express\u0026#39;); 2var router = express.Router(); 3 4/* GET home page. */ 5router.get(\u0026#39;/\u0026#39;, function(req, res, next) { 6 res.render(\u0026#39;index\u0026#39;, { title: \u0026#39;Express\u0026#39; }); 7}); 8 9router.get(\u0026#39;/api/sayHi\u0026#39;, function(req, res, next) { 10 res.send(\u0026#39;hi\u0026#39;); 11}); 12 13module.exports = router; router.get 表示接受來自 GET 的 request，其它的以些類推 (ex: router.post, router.delete\u0026hellip;) 執行伺服器 npm run start 或用 debug 模式執行 ./bin/www 都可以 開啟瀏覽器，進入 http://localhost:3000/api/sayHi，就會出現下圖 瀏覽器其實是發出一個 GET request，接下來我們驗証看看。\n從Chrome 瀏覽器看 request 開啟瀏覽器，進入 http://localhost:3000/api/sayHi，就會出現下圖 開 devTools 後，選 Network 頁籤 在空白處右建 或按鍵盤F12，就可以開啟 是空的! 別怕只要刷新再開一次就好，因為開啟 devTools 後才會記錄 出現一堆 request，哪個才是我們的呢？ 你的可能會會跟我不一樣，有些 Chrome 的插件(extension)在開新頁面時也會發出 request\n過濾 request：在上面有個小框框，輸入 api 就可以過濾 點擊 sayHi 的 request，可以看到 request 的訊息，像是requst/response/header/body\u0026hellip;.等。 所以我們發現一件事：用瀏覽器開一個網址其實就是打一個 GET request 到伺服器\n如果我們想要發出 POST request 怎麼辨？\n如何手動發出 requests? 發出 requests 的工具很多，像是 Advanced REST client, POSTMAN…等，上 google 很容易找到一堆。\n我們要使用的是 POSTMAN，他早期也是 google extension 上的一個 app，之後變成一個獨立的程式了，也出現訂閱服務。 但我覺得免費版就夠用了，免費可以\n模擬一個 request，設定 header, body…等 儲存每個 request，也可以命名、加 Markdown 描述，甚至是存下回應後的結果 有送出 request 的歷史清單 request 打包成 collection(可想成是一個資料夾放一群 request) 匯入/出collection 環境變數 {{host}} 是環境變數，可以在 POSTMAN 中任意切換套用環境組態 同步request資料在連結的 Google 帳號中 使用 POSTMAN 發送 GET request 下載 POSTMAN 建立一個 request，按 + 號 輸入 http://localhost:3000/api/sayHi，按送出 就得到和瀏覽器一樣的結果 跟 Chrome 一樣可以看到 request/response 的資料 最後回答問題：怎麼發出 POST request呢？ 就…換 request method JSON 格式交互資料 之前說，我們要傳遞資料的格式是 JSON ，後端要如何送出 JSON 呢？ Express 提供方便的函數 res.json()，幫我們送出 JSON資料的回應資料。\n後端再加一個 POST API：回應 JSON 資料 打 ./router/index.js檔案，加入下面 POST API\n1router.post(\u0026#39;/api/echo\u0026#39;, function(req, res, next) { 2 const body = req.body; 3 res.json(body); 4}); 這隻 API 做的事情很單純：把 request 的 body 資料，再以 JSON 格式回應回去。\n用 res.json() 回應時，Express會自動在 response header 中加入 content-type: application/json，不同於res.send()送出content-type: text/html，你可以自行驗証看看。\n前端打 POST API：送出帶有 JSON 資料 我們利用 POSTMAN 送出 JSON 資料，在 Body 裡要設定使用 JSON 送出，這時 Headers 就會被設定 下圖是完整操作 (注意： object 的屬性要用 \u0026quot; 要包住，字串也是)，送出後，伺服器會回應一樣訊息 你可以觀察到， request 和 response 都有設定 content-type: application/json 告之對方資料的格式，以便解讀。 用 debug 模式驗証伺服器真有收到 JSON 資料 怎麼看後端真的有解讀/了解 JSON 資料呢？\n設定 VSCode debug 執行 ./bin/www，修改 launch.json 1\u0026#34;configurations\u0026#34;: [ 2 { 3 \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, 4 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 5 \u0026#34;name\u0026#34;: \u0026#34;Launch Program\u0026#34;, 6 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/bin/www\u0026#34; 7 } 8] 下中斷點，再用 POSTMAN 再送出一次 POST /api/echo，後端就會執行 API 的動作，然後停在中斷點 body 的型態真的是 Object! 其實，Express 可以解讀 JSON 文字轉成 javascript 的 Object，是因為有套用解讀 json 中間件(middleware) express.json() 的原因： 你可以註解掉看看，body 就得不到 JSON object 了。中間件(middleware) 會在二周目介紹它，目前只要了解 app.use() 會使所有 request 經過 middleware 處理。\n總結 今天我們大概說明 request/response 訊息的格式並建立了 APIs，還用 Chrome 監看網路行為(ex:查看 GET request)，也用 POSTMAN 手動發出 request (ex: 送出 JSON 資料的 POST request)。\n","date":"2018-10-09","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-9-%E4%B8%80%E5%91%A8%E7%9B%AE-%E9%96%8B%E5%A7%8B%E7%8E%A9%E8%BD%89%E5%BE%8C%E7%AB%AF%E4%BA%8C/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 9 - 一周目- 開始玩轉後端(二)"},{"categories":[],"content":"了解前後端的職責、架構，建立第一個後端應用程式\n回顧 昨天，我列出了ES6常用的語法，接下來我們開始玩玩後端了\n目標 了解前後端的職責、架構 建立第一個後端應用程式：hello-express 前後端架構 軟體架構對不同的人可能有不同的解釋，請用開放的心態，不需要強求別人\n軟體架構常見的有：Centralized computing，peer-to-peer architecture, Client–server model…等。而本主題採的 前後端架構，是屬於 Client–server model。　Client 指的是終端用戶的網頁瀏覽器，Server 指的是提供實際資料或計算的主機。\n後端(backend)：儲存資料、計算資料、提供資料、提供服務(商業邏輯)的區塊，雖然圖片看起來很得簡單，但實際上的它們可能是叢集的方式存在，或依照能功性被切割(ex: 微服務(Microservices)) 資料庫(database)：用儲存、計算、提供資料，常見的資料庫關聯式(Relational database) 像是： MySQL/MSSQL 和 NoSQL 資料庫：MongoDB，Apache Cassandra 和 Redis。我們將會選擇用 MongoDB 來當作資料庫 應用程式伺服器(application server)：提供商業邏輯服務、與前端串接的入口/介面、系統間互相串連。伺服器可能以各種程式語言撰寫，但為了與外界串接(提供服務)，需要使用指定網路傳輸協定(Communications Protocol)，兩個串接的系統才能有同樣的二元資料(0/1)解讀規則。常見的如：http(s), websocket, ftp(s)…等。 因為 http(s)介面也會用於網頁瀏覽器，所以也稱做是 Web API (Application Programming Interface) 。 基於 http(s) 所定義的請求方法(Request methods)，如：GET/POST/DELETE/PATCH/PUT，把它們當做是對某URL(ex: http://api/account)的動作，就形成了所謂的 REST(ful) API，它不是標準而是「API設計風格」。 用來架設http(s)伺服器的程式框架就叫作 Web Framework，像是我們採用 Express.js 也是其中之一，也有人把提供API的伺服器的框架叫 API Framework。不論是叫什麼，反正都是為了架設 http(s)的 應用層網路傳輸協定 伺服器 前端(frontend)：提供給客戶端(client)圖形化使用者介面(GUI)的資料，像是把HTML/Javascript/CSS資料送給瀏覽器。另外，Mobile APP(iOS/Adroid)也有人說是前端。 網頁伺服器(web server)：這雖然也是基於 http(s) 的伺服器，但這主要是提供一些靜態的網頁/檔案/圖片給瀏覽器，比較不會多太多的商業邏輯、運算在裡面。常用 Nginx/Apache/IIS 架設，安裝後通常就可以使用。 因為這個網頁伺服器常常代表客戶端/瀏覽器向隱藏在背後的應用程式伺服器送出要求(request)，這行為就叫做 反向代理，它需要知道 request 要送給誰？所以它會存有 路由(routing) 資訊，就如同 路由器 一樣。 網頁瀏覽器(web browser)：瀏覽器(chrome/safari/firefox)收到 HTML/Javascript/CSS資料，便會開始執行並繪製圖形在瀏覽器上，就是我們看的畫面。 就如同 Markdown一樣，Markdown reader 的實作會導致些微的差異，瀏覽器也是一樣，各家最後生成的畫面有可能會不太一樣，這就是也是前端工師需要花時間的地方。 網頁畫面主要是由 HTML 組成，當 HTML 是在 非 網頁瀏覽器(ex: 後端)組成，再送到網頁瀏覽器，這技術叫 Server-Side Rendering。 反之，完全在網頁瀏覽器中透過 Javascript 執行而產生 HTML，這技術叫 Single Page Application(SPA) 。當產生 HTML 的工作移到在瀏覽器上執行的 Javascript 時，常常需要 前端框架 (Frontend Framework) 來有條理地寫 Javascript 程式碼，目前常見有 Vue.js、Angular 或我們要使用的 React 我們利用前後架構圖，終於把他們的職責說完了，其實每個名詞都有它們值得深入學習的地方，不同的技術也有各自的優缺點。\n接下來，我們開始建立第一個後端應用程式。\n第一個後端應用程式：hello-express 我們將使用 Express 這個 Web Framework 來架設我們的後端應用程式。因為也是網頁伺服器，所以架完後可以值接從瀏覽器送出 http(s) 的要求(request)。\n很幸運，Express提供方便的指令幫我們產生一個專案。\n建立執行 hello-express 安裝express-generator：隨便開一個 terminal 後安裝全域指令\n1npm install -g express-generator 這裡因為有檔案寫入權限的問題，所以需要用 sudo\n使用express 指令：用 express 指令產生一個 Express 框架的 Node.js 專案\n開一個Node.js 專案：建立一個名為 hello-exprss 的資料夾，並以此專案為根目錄\n1mkdir hello-exprss 2cd hello-exprss 產生一個 Express 框架\n1express --view hbs . 會自動產生整個 Express 專案(Node.js 專案)的結構 這裡看到 --view 選項，這是在設定Express 樣版引擎 要用哪一個？ 我選擇用 handlebars。 樣版引擎 是拿來寫 HTML 樣版(template)用的，把 HTML 寫好，留下資料要填入的欄位，當 request 來的時候就可以把字串填入，例：\n1\u0026lt;html\u0026gt; 2\u0026lt;body\u0026gt; 3 \u0026lt;div\u0026gt; 4 Hi! {{username}} 5 \u0026lt;/div\u0026gt; 6\u0026lt;/body\u0026gt; 7\u0026lt;/html\u0026gt; {{username}} 就是未來要填入的字串，樣版引擎可以幫我們把字串填入(ex: const html = template({username: 'billy'});)，就會產生最後的 HTML，就可以回傳了。\n可以輸入 express --help 查看更多 安裝相依套件：在專案根目錄的 terminal 下執行\n1npm inatall 執行 express：在專案根目錄的 terminal 下執行\n1DEBUG=hello-exprss:* npm start 這行做兩個件事\n設定 DEBUG 這環境變數，伺服器執行時可以在主行程(main process)中透過 process.env['DEBUG'] 抓到值 hello-exprss:*，之後會好好的來介紹它。 npm start 也是 npm run start，從 package.json 中看出 1\u0026#34;scripts\u0026#34;: { 2 \u0026#34;start\u0026#34;: \u0026#34;node ./bin/www\u0026#34; 3}, 就是在執行 node ./bin/www 查看是否安裝成功 打開瀏覽器，到 http://localhost:3000/，看到下圖就表是成功了 若查看 terminal，可以看到從瀏覽器送出的 requests 停止 hello-express 停止很簡單，在執行 express的 terminal 中，用按鍵\n1ctl + c 會看到 ^C 終止執行 背景執行伺服器 伺服器的執行應該要能在背景運作，不能因為關閉 terminal 就無法運作。這裡只先列出來，未來有機會再說明\n\u0026amp;：執行一個背景執行的指令。停止要用 kill 指令，刪除行程 systemctl：設定一個 linux 的 service，用 systemctl start \u0026lt;service\u0026gt;，執行服務 screen：screen工具，可以背景開啟多個shell，伺服器指令執行在裡面 pm2: pm2 是 Node.js 的行程管理器，不只可以在背景執行，還可以以叢集的方法執行伺服器 docker 容器：本主題想要介紹的方法，用 docker 執行一個載有伺服器映象檔的容器 總結 今天我們提到前後端架構及他們的職責，也粗略地點出各種技術的名詞。最後，利用 express-generator 快速地建立第一個後端伺服器，也用瀏覽器訪問它。\niT邦幫忙工具列置底 寫了幾天的文章，我真的受不了工具欄一直在上面，上傳圖片超不方便，所以寫了簡單的 javascript，把工具欄置底\n以下用 Chrome 示範：\n在書籤加入一個新的書籤 填入 Name, URL Name: iT邦幫忙工具列置底 URL：下面的 javascript貼上\n1javascript: (function () { function cssText(obj) { return Object.keys(obj).map(key =\u0026gt; `${key}: ${obj[key]};`).join(\u0026#39; \u0026#39;); } var doms = window.document.getElementsByClassName(\u0026#39;editor-toolbar\u0026#39;); var dom = doms.length \u0026gt; 0 ? doms[0] : undefined; if(!dom) return; var style = dom.style || {}; style.bottom = \u0026#39;10px\u0026#39;; style.right = \u0026#39;0px\u0026#39;; style.position = \u0026#39;fixed\u0026#39;; style.zIndex = \u0026#39;10\u0026#39;; })(); 之後就在編輯模式時，點這書籤就好了。\n","date":"2018-10-08","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-8-%E4%B8%80%E5%91%A8%E7%9B%AE-%E9%96%8B%E5%A7%8B%E7%8E%A9%E8%BD%89%E5%BE%8C%E7%AB%AF%E4%B8%80/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 8 - 一周目- 開始玩轉後端(一)"},{"categories":[],"content":"ES6 有些讓人欲罷不能的語法\n回顧 昨天用ESLint，照顧程式碼風格，今天真的要來寫程式了\n目標 ES6 有些讓人欲罷不能的語法，它們超超超…常用，不能不會：\n模組(module) / 套件(package)的使用 箭頭函數(Arrow function) 解構賦值 (Destructuring Assignment) 擴展語法(Spread syntax) 類別(Class) JSON 物件：序列化(serialization)物件 讓人欲罷不能的語法 模組(module) / 套件(package)的使用 在 Day 3 - 一周目- 建立 第一個Node.js 專案 我們安裝了人生第一個套件 lodash，在我們的程式中要怎麼用呢？\n不幸的，javascript 程式碼是否能正常執行是由執行環境境決定的，所以不同的環境語法可能有些微的不同。Node.js 和多數瀏覽器用的ES6 有不同的模組引入方法\n總結如下：(截錄自exports、module.exports和export、export default到底是怎回事)\nrequire: Node.js 和 ES6 都支援的引入 export / import : 只有ES6 支援的導出引入 module.exports / exports: 只有 Node.js 支援的導出 從環境的角度：\nNode.js 模組引入 require 1 const _ = require(\u0026#39;lodash\u0026#39;); 模組導出 module.exports / exports 1module.exports = { 2 myFun: ()=\u0026gt;{} 3} ES6 模組引入require / import 1import _ from \u0026#39;lodash\u0026#39;; // 或 const _ = rquire(\u0026#39;lodash\u0026#39;); 模組導出 export 1export default { 2 myFun: ()=\u0026gt;{} 3}; Node.js雖然是CommonJS規範, 但不久的將來也可以用 import 了，見Node.js v10.11.0 - ECMAScript Modules\n下面可以看到完整的範例：\nNode.js module usage：可以在裡面開一個terminal，輸入 node ./src/index.js，看到結果 ES6 module usage：可以看 Console 頁籤看到結果 箭頭函數(Arrow function) 這曾在Day 5 - 一周目- 從VSCode debug 模式看作用域(Scope)、this、閉包(Closure)介紹過，他的外型如同他名字有箭頭 () =\u0026gt; {}\n常用在哪 不用命名的函數/暱名函數：有些時候命名函數是多此一舉的事\n1const names = [\u0026#39;billy\u0026#39;, \u0026#39;may\u0026#39;]; 2const persons = names.map(name =\u0026gt; { 3 return {name: name}; 4}); 這裡的箭頭函數表明了把字串(ex: 'billy') 轉成物件(ex: {name: 'billy'})，函數命名是多些一舉的\n簡化表達式： 除了 function 字拿掉了，若回傳值可以用一行程式碼表達，連 {…} 和 return 也可以拿掉\n1const names = [\u0026#39;billy\u0026#39;, \u0026#39;may\u0026#39;]; 2const persons = names.map(name =\u0026gt; ({name: name})); 是不是更簡化了阿～ 注意，因為回傳是物件，但物件的 {…} 會和函數的{…}區塊弄混，所以要用 (…) 包起來\n清楚的函數表達作用：常出現在 Functional programming 中，像是 Ramda文件中經常會出現用來表達作用。 我們舉線性函數例子，你覺得哪個清楚表達作用呢？\n1// Statements - 一般函數版本 2function plus(b, x) { 3 return x + b; 4} 5function mult(a, x) { 6 return a * x; 7} 8function linear(a, b, x) { 9 return plus(b, mult(a, x)); 10} 11console.log(linear(2, 1, 3)); 12 13// Declarative programming　－　箭頭函數版本 14const linearGen = a =\u0026gt; b =\u0026gt; x =\u0026gt; a * x + b; 15const linear21 = linearGen(2)(1); 16console.log(linear21(3)); 17 18// linearGen 用一般函數就像下面 19function _linearGen(a) { 20 return function (b) { 21 return function (x) { 22 return a * x + b; 23 }; 24 }; 25} 26console.log(_linearGen(2)(1)(3)); 其實 一般的函數和箭頭函數還是有些微的不同，可以見 Arrow function vs function declaration / expressions: Are they equivalent / exchangeable?。通常是發生在 this 被動態修改時就會出現差異(像是：call, apply …之類的)。\n解構賦值 (Destructuring Assignment) Destructuring Assignment 我覺得是 ES6 最酷的語法(我目前只在 ES6 看到，其它語言沒見過)，一行程式碼做兩件事(以物件為例)：\n解構：取出值 1const person = {name: \u0026#39;Billy\u0026#39;}; 2const name = person.name // 取出值 賦值：沒值就預設 1const person = {name: \u0026#39;Billy\u0026#39;}; 2const id = person.id || \u0026#39;No ID\u0026#39; 用 Destructuring Assignment 就是\n1const person = {name: \u0026#39;Billy\u0026#39;}; 2const {name, id = \u0026#39;No ID\u0026#39;} = person; 若 name 已被宣告過可以換變數名字，用 : 符號\n1const person = {name: \u0026#39;Billy\u0026#39;}; 2const {name: nickname, id = \u0026#39;No ID\u0026#39;} = person; 3console.log(nickname, id); // Billy, No ID Destructuring Assignment 可以對 Array 或 Object 使用，文件 Destructuring Assignment 舉了很多用法，我只列我常用的\n物件解構 Object destructuring 一般用法 1const person = {name: \u0026#39;Billy\u0026#39;, gender: \u0026#39;man\u0026#39;}; 2const {name: nickname, id = \u0026#39;No ID\u0026#39;} = person; 保留剩餘：取出要處理的部分，剩下的可以留下做之後的事 1const person = {name: \u0026#39;Billy\u0026#39;, gender: \u0026#39;man\u0026#39;}; 2const {name, ...others} = person; 3console.log(others); // { gender: \u0026#39;man\u0026#39; } 函數簽章參數解構：用於顯式的指明函數簽章(Signature) 1const person = {name: \u0026#39;Billy\u0026#39;, gender: \u0026#39;man\u0026#39;}; 2function welcomePerson({name = \u0026#39;guest\u0026#39;} = {}) { 3 console.log(`Hi! ${name}`); 4} 5welcomePerson(person); // Hi! Billy 6welcomePerson(); // Hi! guest 這裡 welcomePerson({name = 'guest'} = {}) 中的 = {}，是函數參數若沒傳就是空物件 {} 函數物件參數解構：用物件當參數，未來可以任意的放入新的屬性，而不用改呼叫者(caller)，例如：函數簽章 f(a, b) 改成 f(obj)。經常被用在 options 1const options = {type: \u0026#39;type1\u0026#39;}; 2function welcomePrefix(options = {}) { 3 const {type} = options; 4 return type === \u0026#39;type1\u0026#39; ? \u0026#39;Hi! \u0026#39; : \u0026#39;Hello! \u0026#39;; 5} 6console.log(welcomePrefix(options) + \u0026#39;Billy\u0026#39;); 函數回傳解構 1 function getPerson() { 2 const person = {name: \u0026#39;Billy\u0026#39;}; 3 return type === \u0026#39;type1\u0026#39; ? \u0026#39;Hi! \u0026#39; : \u0026#39;Hello! \u0026#39;; 4 } 5 const {name} = getPerson(); 6 console.log(name); // Billy 陣列解構 Array destructuring 陣列解構依於 順序 ，我反而少用\n1function getPair() { 2 return [\u0026#39;a\u0026#39;, 1]; 3} 4const [word, number] = getPair(); 5console.log(word, number); // a 1 擴展語法(Spread syntax) ... Spread syntax 也是 ES6 必用的語法。可以用在 React component 中，把值「展開」送到 component中，例如：假設 props = {name: 'Name', price: 1}，放到 \u0026lt;MyComonent/\u0026gt; 中 \u0026lt;MyComonent title='Title' {...props} /\u0026gt;， 相當於 \u0026lt;MyComonent title=\u0026quot;Title\u0026quot; name=\u0026quot;Name\u0026quot; price=1 /\u0026gt;。\n以下是我常用的情況\n保留剩餘：「物件解構-保留剩餘」中的 const {name, ...others} = person 就是用到 Spread syntax\n用建立新陣列/物件\n1// object 2const options = {type: \u0026#39;type1\u0026#39;, auto: true}; 3const newOptions1 = {enable: true, ...options}; 4const newOptions2 = {enable: true, ...options, auto: false}; 5console.log(newOptions1); // { enable: true, type: \u0026#39;type1\u0026#39;, auto: true } 6console.log(newOptions2); // { enable: true, type: \u0026#39;type1\u0026#39;, auto: false }，這裡後出現的 auto 會蓋住前面的 7 8// array 9const words = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; 10const allWords = [\u0026#39;a\u0026#39;, ...words, \u0026#39;d\u0026#39;]; 11console.log(allWords); 注意：Object 的同名屬性可能是被後面的覆蓋\n不定長度參參數呼叫： 有沒有發現 console.log 可以輸入不同長度的參數？\n1console.log(\u0026#39;a\u0026#39;); // a 2console.log(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); // a b 可以利用 Spread syntax，把陣列展開\n1const words = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]; 2 3// 送入一整個陣列 4console.log(words); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39; ] 5 6// 展開元素，這等價於 console.log(words[0], words[1]) 7console.log(...words); // a b 所以，words的長度改變，console.log(...words) 也不用修改了\nBonus：製做非固定長度的函數 - arguments 是存在於一般函數(非箭頭函數)的區域變數(local variable)，它是 array-like(可以用 arguments[0] 取值，但沒有 Array 的所有函數)，可以來定義非固定長度的函數，像是 console.log\n1function mylog() { 2 // const badPrefixArgs = arguments.map(arg =\u0026gt; \u0026#39;=\u0026gt;\u0026#39; + arg); // 這拿掉會丟出錯誤：TypeError: arguments.map is not a function 3 4 // 這裡呼叫空陣列[]的 map函數，把 this 換成 arguments 5 const prefixArgs = [].map.call(arguments, arg =\u0026gt; \u0026#39;=\u0026gt;\u0026#39; + arg); 6 console.log(...prefixArgs); 7 8 // 或用 lodash 9 //const _ = require(\u0026#39;lodash\u0026#39;); 10 //const prefixArgs = _.map(arguments, arg =\u0026gt; \u0026#39;=\u0026gt;\u0026#39; + arg); 11} 12mylog(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); // =\u0026gt;a =\u0026gt;b 類別(Class) 這是大家常用的物件編程語法，更多內容可以看 ECMAScript 6 入門\n1class MyError extends Error { 2 constructor() { 3 super(...arguments); 4 } 5 6 toJson() { 7 return { 8 message: this.message 9 } 10 } 11} 12 13const error = new MyError(\u0026#39;my error\u0026#39;); 14console.log(error.toString()); 15console.log(error.toJson()); JSON 物件：序列化(serialization)物件 JSON 這內建物件，不用 new 就可以直接使用，在序列化(serialization)物件和還原物件很好用\nJSON.stringify 和 JSON.parse 分別是序列化和還原，其中序列化的對像是 objects、arrays、numbers、strings、booleans, 和 null的值。\n它們執行失敗時可能會丟例外(exception)，一個穩健(robust)的程式應該要處理它們。\n1const person = {name: \u0026#39;billy\u0026#39;, orderIds: [\u0026#39;0A\u0026#39;, \u0026#39;0B\u0026#39;]} 2 3let serializedPerson = \u0026#39;\u0026#39;; 4try { 5 serializedPerson = JSON.stringify(person); 6 console.log(serializedPerson); // {\u0026#34;name\u0026#34;:\u0026#34;billy\u0026#34;,\u0026#34;orderIds\u0026#34;:[\u0026#34;0A\u0026#34;,\u0026#34;0B\u0026#34;]} 7} catch(e) { // TypeError exception 8 console.error(e); 9} 10 11let newPerson = {}; 12try { 13 newPerson = JSON.parse(serializedPerson); 14 console.log(newPerson); // Object {name: \u0026#34;billy\u0026#34;, orderIds: Array(2)} 15} catch(e) { // SyntaxError exception 16 console.error(e); 17} 總結 今天提的所有語法，在未來一定會一直出現，尤其是 模組使用 、 箭頭函數、 解構賦值 會一直陪伴著你。\n參考連結 模組化 Node中沒搞明白require和import，你會被坑的很慘 exports、module.exports和export、export default到底是怎回事 ","date":"2018-10-07","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-7-%E4%B8%80%E5%91%A8%E7%9B%AE-es6-%E8%AE%93%E4%BA%BA%E6%AC%B2%E7%BD%B7%E4%B8%8D%E8%83%BD%E7%9A%84%E8%AA%9E%E6%B3%95/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 7 - 一周目- ES6 讓人欲罷不能的語法"},{"categories":[],"content":"安裝程式碼品質工具、修改檢查規則組態檔\n回顧 昨天我們介紹了作用域(Scope)、this、閉包(Closure)如何影響 VSCode debut 模式。終於可以寫程式了，但在開始寫程式前先來決定程式風格。\n目標 安裝程式碼品質工具 - ESLint 修改檢查規則組態檔 程式碼品質工具 - ESLint 為什麼要用 程式碼品質工具 ? javascript 的語法很鬆散，可以任意放空白行或是多放空白字元、換行，沒有一個統一的寫法風格\n1// badcode.js 2const hiString = \u0026#39;hi\u0026#39;; 3 4const a=\u0026#39;hi\u0026#39; 5 6if(a ===hiString) { 7 console.log(\u0026#39;true\u0026#39;); 8} else 9{ 10console.log(\u0026#39;false\u0026#39;); 11} 上面程式是真的可以執行，但看的很痛苦吧？若是多人協作，真的是使人抓狂，就算是單人開發也會希望有統一的風格。\n程式碼品質工具有很多 ESLint、 JSLint、JSHint, Standard，但我也只用過 ESLint。\nESLint 可以做什麼？ 可以有統一的風格：像縮排幾個空白、空白行最多多少、換行、物件宣告的風格\u0026hellip;等等。見ESLint rules 動態程式碼檢查：可能的語法錯誤、潛在的危險，像是從來不被改的變數沒設 const，if 沒有所有路徑都有回傳、變數型別有誤、存取可能不存在的屬性 語法建議：宣告了一個從來不使的變數、可以用三元運算ternary operation 簡化 if 自動修改程試碼符合風格：eslint --fix 客制化風格：你可以設定專屬風格，像是縮排用 Tab 還是 空白 怎麼安裝ESLint？ ESLint 它也是一隻程式，可以透過指令執行。\n指令模式 安裝指令：我們選擇全域安裝，terminal 就可以使用 eslint 指令 1npm install -g eslint 設定組態檔：移到專案根目錄(可以繼續用 hello-es6專案)，初始化 eslint 組態檔 .eslintrc.js ，裡面就會放風格設定 1eslint --init 之後會跑出提示，可以選要使用的規則。為了方便學習你可以照我選的，也可以自設，甚至使用Airbnb/Standard/Google這些流行的風格。通常讓人困擾的問題是： ES6 與 ECMAScript 2015 的關係 選完後就會產生一個 .eslintrc.js 檔案 執行程式碼檢查：把上面的 badcode.js 存下來，用 eslint badcode.js 執行檢查 badcode.js 看看 它報出一堆問題，你就可以手動修正或自動修正 自動修正：執行 eslint badcode.js --fix 後，程式碼變 1const hiString = \u0026#39;hi\u0026#39;; 2 3const a=\u0026#39;hi\u0026#39;; 4 5if(a ===hiString) { 6 console.log(\u0026#39;true\u0026#39;); 7} else 8{ 9 console.log(\u0026#39;false\u0026#39;); 10} 有進步!只剩兩個 error，程式也變漂亮了 另外，有哪些可以自動修正的規則？請見 rules 的扳手圖案 ESLint 也可以安裝在專案裡面 npm install eslint --save-dev，此時執行檔在 ./node_modules/bin/eslint.js裡\nVSCode Extenstion 前一節用指令檢查一個檔案，總不能每次寫完程式就執行一次吧？所以大部分的編輯器(VSCode, Atom, WebStorm, Sublime)都可以安裝 ESLint Extension，把 Eslint 整合進編輯器。\n進入 Extensions 頁 找esint，後安裝eslint 再 Reload 回到程式碼就會「看」到出問題的地方 設定 ESLint 組態檔 程式碼我們還留下 console.log() 的 error，可以做以下的事\n刪除報錯的程式碼不用 關掉檢查項目 弱化警告等級(level) 在修改前，先來談談組態檔規則\n組態檔規則 打開 .eslintrc.js 看到除了 eslint:recommended 裡預設的規則，rules 還自設了幾個規則\n1{ 2 \u0026#34;extends\u0026#34;: \u0026#34;eslint:recommended\u0026#34;, 3 \u0026#34;rules\u0026#34;: { 4 \u0026#34;indent\u0026#34;: [ 5 \u0026#34;error\u0026#34;, 6 4 7 ], 8 \u0026#34;linebreak-style\u0026#34;: [ 9 \u0026#34;error\u0026#34;, 10 \u0026#34;unix\u0026#34; 11 ], 12 \u0026#34;quotes\u0026#34;: [ 13 \u0026#34;error\u0026#34;, 14 \u0026#34;single\u0026#34; 15 ], 16 \u0026#34;semi\u0026#34;: [ 17 \u0026#34;error\u0026#34;, 18 \u0026#34;always\u0026#34; 19 ] 20 } 21}; rules 裡面的元素，使用格式如下：\n1\u0026lt;rule name\u0026gt;: [\u0026lt;error level\u0026gt;, \u0026lt;...options for the rule\u0026gt;] 所以 \u0026quot;quotes\u0026quot;: [\u0026quot;error\u0026quot;, \u0026quot;single\u0026quot;], 是指字串套用 quotes 規則，而用 單引號(single)，不合格的錯誤等級為 error。\n弱化 console.log 的錯誤等級訊息 到 rules頁，找到 no-console這個role，確認有這個規則存在 加入 \u0026quot;no-console\u0026quot;:[\u0026quot;warn\u0026quot;] 到 rules 裡面 變成警告的樣子，而不是嚇人的紅線了 完整的修正 badcode.js：採用 Airbnb 風格 安裝本地ESLint，用本地程式設定組態 1npm i eslint --save-dev 2./node_modules/eslint/bin/eslint.js --init 我使用 Airbnb 風格，安裝完後重開 VSCode 自動修正 1./node_modules/eslint/bin/eslint.js badcode.js --fix 修正完變的更漂亮了 1const hiString = \u0026#39;hi\u0026#39;; 2 3const a = \u0026#39;hi\u0026#39;; 4 5if (a === hiString) { 6 console.log(\u0026#39;true\u0026#39;); 7} else { 8 console.log(\u0026#39;false\u0026#39;); 9} 總結 今天用 ESLint 來確保程式碼品質，透過 .eslintrc.js 裡面設定規則 ESLint 就可以進行檢查。為了方便檢查，安裝 VSCode 的 ESLint extension 幫助我們做到 即時 的檢查。最後，採用流行的風格來修正程式碼。\n","date":"2018-10-06","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-6-%E4%B8%80%E5%91%A8%E7%9B%AE-%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%93%81%E8%B3%AA%E5%B7%A5%E5%85%B7eslint%E7%85%A7%E9%A1%A7%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%A2%A8%E6%A0%BC/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 6 - 一周目- 程式碼品質工具ESLint，照顧程式碼風格"},{"categories":[],"content":"以 VSCode dubug 模式來看，經典的觀念：作用域(Scope)、this、閉包(Closure)\n回憶 昨天提到了用 debug 模式玩ES6的基本語法。\n目標 以 VSCode dubug 模式來看，經典的觀念：作用域(Scope)、this、閉包(Closure)\n函數(function) 函數可看成一群程式碼的集合，可以幫我們包裝 routine 的工作 (可以重複呼叫)，命名後可以增加程式碼可讀性。 函數也引發了變數作用域、閉包、this 的問題。\n基本宣告 有兩種方法可以宣告函數\n函數物件 1function sayHi() { 2 console.log(\u0026#39;Hi!)\u0026#39;); 3} 箭頭函數arrow function 1const sayHi = () =\u0026gt; { 2 console.log(\u0026#39;Hi!\u0026#39;); 3} var/let/const 作用域(Scope): 變數生存的空間 接下來會用 debug 模式，觀察 var/let 的特性。\n在 ES6 出來以前只有 var 可以用，這是指在宣告在函數內的變數，在這函數的執行過程中會一直在，不管包幾層區塊。\n在區塊 ({…}) 內宣告的變數可以在區塊外使用嗎？ 我們觀察以下程式碼：\n1// var/let in global 2const runIf = true; 3if(runIf) { 4 var ifVar = \u0026#39;ifVar\u0026#39;; // if 執行完會留下 5 let ifLet = \u0026#39;ifLet\u0026#39;; 6} 7console.log(ifVar); // 執行到這行，可存取到 ifVar，因為 ifVar 是在主程式函數中宣告的 8// console.log(ifLet); // ReferenceError: ifLet is not defined 9 10 11// var/let in function 12function fun1() { 13 var innerVar = \u0026#39;fun1Let\u0026#39;; // fun1()執行完不會留下 14 let innerLet = \u0026#39;fun1Let\u0026#39;; // fun1()執行完不會留下 15} 16fun1(); 17// console.log(innerVar);　// ReferenceError: innerVar is not defined 18// console.log(innerLet); // ReferenceError: innerLet is not defined 19console.log(\u0026#39;bye\u0026#39;); 在第2,5,13,19行下中斷點，執行 debug，如下圖： 停在第2行後，看看 CALL STACK ，目前執行在匿名函數中 (anonymous function)中，也就是，當程式執行時，我們可以假想它們被包在某個函數中且立刻被執行，像是：\n1(anonymousFunction() { 2 // …上面程式碼… 3})() 此外， VARIABLES-\u0026gt;Local 中有在函數內可以存取的變數，但會發現 沒有 ifLet ，也就是第8行不能讀到ifLet的原因。\n再往下執行到第5行， 多出 VARIABLES-\u0026gt;Block ，裡面有ifLet，而 VARIABLES-\u0026gt;Local 還留著。\n再往下執行到第13行， CALL STACK 現在進入到 fun1 中， CALL STACK 自然就只剩下 innerLet 和 innerVar ( this 晚點說)\n再往下執行到第19行， 離開 fun1() 後 innerLet 和 innerVar就會被消毀，當再次回到「進來前的函數空間」， innerLet 和 innerVar 當然就存取不到了，也就是第17,18行不能讀到他們。\n可以試試把第 8, 17, 18註解拿掉，會丟出例外\n我們整理結論：\nvar 是屬於函數作用域(function scope)，活在函數中，出現在 VARIABLES-\u0026gt;Local 中 let 是屬於區塊作用域(block scope)，活在 {…} (curly brackets)，出現在 VARIABLES-\u0026gt;Block 中 那…const 呢？ 它跟 let 一樣，只是變數不能再次被賦值(=)。 所以結論：\nvar 是屬於函數作用域(function scope)，活在函數中，出現在 VARIABLES-\u0026gt;Local 中 let/const 是屬於區塊作用域(block scope)，活在 {…} (curly brackets)，出現在 VARIABLES-\u0026gt;Block 中 要怎麼選用它們？ 我的做法是變儘量限制它們的 scope，以降低無法預期的效果，像是：var 變數生存太久佔用記憶體、本應該是常數的東西不小心執行時被改到、存取到本不應該存在的變數…等\n能用 const 儘量用 可能要改值，就用 let 最後才用 var this：呼叫函數的人 this 在OO(物件導向)技術被用來當做實例(instance)的代理變數。在 javascript 也有類似的功用，但 this 是可以被我們動態替換的，所以可以做的更多，見：JavaScript - call，apply，bind。現階段只要了解：this就是呼叫函數的人\n看以下的程式，下中斷點觀察\n1const funA = () =\u0026gt; { 2 console.log(this); 3}; 4function funF () { 5 console.log(this); 6}; 7 8const obj = { 9 funA: funA, 10 funF: funF, 11} 12 13funA(); 14funF(); 15 16obj.funA(); 17obj.funF(); 下面這張圖，程式是從第14行進入至第3行，呼就叫的人是誰？因為沒有指明人，就會拿最上層的人(物件)，所以就叫 global，此時 this 是 global 下面這張圖，程式是從第17行進入至第3行，呼就叫的人是誰？是 obj，所以 this 是 obj 且它的型別是 Object，打開來看看真的是它 閉包(Closure)：把外面的變數關在函數中使用 我們考慮以下問題：\n函數外宣告的變數，能不能在函數內使用？ 函數內如何使用外部變數的值？ 閉包域中的外部變數值可以被修改嗎？ 回答這些問題\n可以，每個建立一個函數物件時，會會有一個閉包域產生。當函數物件執行時可以存取外部變數 一般有兩個方法 用參數，把值傳入 1const outer = \u0026#39;outer\u0026#39;; 2function fun(a){ 3 console.log(a); 4} 5fun(outer); 透過閉包，把外部變數包入閉包域 1const outer = \u0026#39;outer\u0026#39;; 2function fun(){ 3 console.log(outer); // 引用到外部變數，所以會放到 fun()函數中的閉包域 4} 5fun(); 可以，因為閉包域中的變數和外部變數是相同的記憶體位置，所以可以被修改。見下面說明。 執行以下程式，並下中斷點，為了看的更清楚我們很刻意的放到 main() 中執行，\n1function main() { 2 let outer = \u0026#39;outer\u0026#39;; // 外部變數 3 function funA() { 4 console.log(outer);　// 讀取到外部變數 5 }; 6 7 function funB() { 8 const inner = outer;　// 內部變數，指向 outer 的值 9 outer = outer + \u0026#39;-fix\u0026#39;; // 修改 outer 的值 10 console.log(inner, outer); 11 }; 12 13 funA(); 14 funB(); // outer 值被修改 15 funA(); 16}; 17 18main(); 下圖中，outer 放入 VARIABLES-\u0026gt;Closure 閉包域中，使我們可以存取它的值。 下圖中，因為宣告了 const inner，它是屬於 VARIABLES-\u0026gt;Local ，並設定成outer的值，所以 inner = 'outer'。然而，outer = outer + '-fix'，把 outer 改成了 outer-fix的值。此外，outer 也被放入 VARIABLES-\u0026gt;Closure 閉包域中。 用記憶體圖示來說，就會很清楚了，白正方形是記憶體空間，裡面會放字串值。 最後在呼叫一次 funA()，得到 outer 被修改後的結果。 什麼時候用？ 可以用閉包包入定值，但很煩，ES6 引入的 let 可以簡化不少。\n1// i, j loop 完，變成定值 2let funs = []; 3for (var i = 0; i \u0026lt; 3; i++) { 4 var j = i; 5 funs.push(function () { 6 console.log(i, j); // loop 完才用到 i, j 7 }); 8} 9funs.forEach(fun =\u0026gt; fun()); 10 11// 用閉包 12funs = []; 13for (var i = 0; i \u0026lt; 3; i++) { 14 (function () { 15 var j = i; // 把值存入一個匿名函數的閉包 16 funs.push(function () { 17 console.log(i, j); 18 }); 19 })(); 20} 21funs.forEach(fun =\u0026gt; fun()); 22 23// 用 let 24funs = []; 25for (var i = 0; i \u0026lt; 3; i++) { 26 let j = i; 27 funs.push(function () { 28 console.log(i, j); 29 }); 30} 31funs.forEach(fun =\u0026gt; fun()); 結果：\n13 2 23 2 33 2 43 0 53 1 63 2 73 0 83 1 93 2 只有後面兩種寫法會正確。\n復雜習題 可以猜看看下面的結果：\n1const funs = []; 2for (var i = 0; i \u0026lt; 3; i++) { 3 const j = i; 4 funs.push(function () { 5 const inner = i; 6 console.log(inner, i, j); 7 }); 8} 9 10funs.forEach(fun =\u0026gt; fun()); 總結 今天用 debug 模式，觀察作用域(Scope)、this、閉包(Closure)的例子，並發現下面的關連性。 VARIABLES-\u0026gt;Local - var VARIABLES-\u0026gt;Block - let/const VARIABLES-\u0026gt;Closure - 閉包\n參考連結 The Difference Between Function and Block Scope in JavaScript) 用9種辦法解決 JS 閉包經典面試題之 for 循環取 i ","date":"2018-10-05","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-5-%E4%B8%80%E5%91%A8%E7%9B%AE-%E5%BE%9Evscode-debug-%E6%A8%A1%E5%BC%8F%E7%9C%8B%E4%BD%9C%E7%94%A8%E5%9F%9Fscopethis%E9%96%89%E5%8C%85closure/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 5 - 一周目- 從VSCode Debug 模式看作用域(Scope)、this、閉包(Closure)"},{"categories":[],"content":"昨天介紹了用VSCode執行debug模式，今天要來看debug模式可以做什麼？\n回憶 昨天介紹了用VSCode執行debug模式，今天要來看debug模式可以做什麼？\n目標 debug模式更細部說明 程式在debug模式下觀察程式 基本ES6：變數、內建物件、邏輯、迴圈、條件 VSCode 偵錯(debug) 模式 大部的程式執行環境都可以透過編輯器或整合開發環境 IDE 支援debug模式。 Node.js 支援 debug模式，我們可以使用 VSCode 方便介面的操作，對執行的程式debug。\ndebug 模式 debug 模式就是可查看程式的執行歷程，進而進行干涉。\ndebug 模式可以做什麼？ 觀察程式執行路徑，下中斷點(breakpoint)、操作Step over/Step in/Step out、看執行函式堆疊 觀察/修改變數的值 準備偵錯模式的遊樂場(Playground) 建立hello-es6 專案，因為資料夾就是一個專案，所以可以直接把昨天的 hello-nodejs 資料夾拷貝一份再改名為 hello-es6，就完成了。順手改 package.json 內的專案名稱 name 把 index.js內容改成 1function fool(a) { 2 console.log(\u0026#39;a is:\u0026#39; + a + \u0026#39; in fool()\u0026#39;); 3} 4 5const a = 1; 6console.log(\u0026#39;a is:\u0026#39; + a); 7fool(a); 執行debug模式：選 Debug 裡的 Start Debugging　或選好執行 index.js 的執行組態再按綠色箭頭 看到執行結果 玩轉 deubg 在第2, 7行下中斷點 執行debug模式，看看發生什麼事？ 沒錯!程式停下來了、停在第2行~莫慌，我們接下去 按下 Contiune (往右的箭頭) 按第一下 Contiune，就停在第7行，再按一次才會執行完並印出完整的結果 debug 模式常用功能區塊 第一小節，我們看到 中斷點 可以使程式停在這位置，而 Contiune(往右的箭頭) 繼續執行直到下一個中斷點或執行結束。\n接下來，我們來看看常用功能區塊 VARIABLES：變數值 執行時可以存取到的變數和他們的值。你甚至可以連點兩下修改他們，進而影響後續執行。 WATCH：自定義程式表達式(expression) 圖中：a+1 會被執行出結果，常用於查看特定的值，像是物件的屬性值object1.property1。 CALL STACK：函數的執行堆疊(stack) 圖中程式執行到第二行，所以會看到最上面是fool() 2:5，表示現在正在 fool() 函數中，第 二 行第 五 個字。你可以點擊第二個 (anonymous function) 會看到是從哪進來的，且會 VARIABLES 是進來前的狀態。 BREAKPOINTS：中斷點的位置 勾勾可以開關它們並保留下它們。 DEBUG CONSOLE：condoel.log() 印出的結果。 condoel.log()印到標準輸出stdout 程式流程控制儀表板(panel)：依次是 Contiune, Step Over, Step In, Step Out, Restart, Stop Contiune：繼續執行 Step Over：不離開當前執行函數，單步執行到下一行 Step In：單步執行到下一行。若有函數就進入 Step Out：離開當前函數後，停留在下一行 Restart：整個 deubg 重新執行 Stop：終止整個 deubg 模式 EVALUATE EXPRESSION: 執行程式碼片斷 這名字我是從 WebStorm 來的，你可以在這直接寫程式執行。把下面這行貼入按Enter執行 1function sayHi(a) { 2 console.log(\u0026#39;Hi! a is \u0026#39; + a + \u0026#39; in syhHi()\u0026#39;); 3} 4sayHi(a); 你可以多玩玩程式流程控制儀表板和 VARIABLES和 WATCH 區塊，這對於除錯有莫大的幫助\n我發現動態的改值或執行程式碼片斷，可能會導致 VARIABLES 和 WATCH 的值殘留舊值。不過，在我的除錯經驗中，真的很少改值。\nES6 (ECMAScript6) 快速學習 上一章，我們已學會用 VSCode 在 debug 模式下運行，這不僅是用來除錯，還可以拿來習學用的。\nES6 是 ECMAScript6的簡稱，它只是個 規格(specification) ，而 javascript 就是實現他的語言。\n然而，ES6 的特性不一定 javascript會實現，更重要是能不能在 Node.js 或瀏覽器使用\nNode.js 可以見官方文件ECMAScript 2015 (ES6) and beyond 瀏覽器就有點麻煩了，有瀏覽器要怎麼查？可以用Can I use?查網頁技術的支援程度 我覺得不管在什麼環境，你跑跑看就知道了。好消息是 ES6 常用的語法，大部分的環境都支援了。\n變數(Variable)：用來存取值的名稱 變數是程式存取值的名稱，例如：\n1const a = 1; 這行看來簡單，其實有很多小細節在裡面：\n宣告：程式在執行前要先配置記體憶空間 (實際上，在{. . . }內所有宣告的變數都會在此區塊被執行前一起配置) 變數範圍/範籌/作用域(Variable Scope)：這個變數被修飾為 const ，就是一但賦值後「變數的值」再也不能被修改。Scope 還有：let、var、const。 賦值： = 是賦值符號 基本型別/原始型別 (Primitives)：有哪些類型的值？ Boolean - true / false 1const a = true; Null - \u0026ldquo;沒有值\u0026quot;的值 1const a = null; Undefined - 被宣告過的變數，但沒有設定值 1const a = undefined; Number - 數字，像：整數、浮點數 1const a = 1; 2const a = 1.1; String - 字元陣例 1const a = \u0026#39;hello\u0026#39;; Symbol - 全局執行過程中唯一的值，不可能有一樣的 1const a = Symbol(\u0026#39;foo\u0026#39;); 2const b = Symbol(\u0026#39;foo\u0026#39;); 3a === b // false 這是 ES6 才引入，用途見 ES6 In Depth: Symbols，但我們不會用到 除了上述之外，其它值的都是 Object 型別。 常用的內建物件型別：Object, Array, String, Date, Error 這些怎麼用去 google 都可以查的到，所以我只列出常用的操作，想知道有哪函操作可以查看 Standard built-in objects。\n假如我打開 Object.keys()，會看到如下： 文件中會先給簡述，再來是Demo，也可以立刻執行玩看看，之後才是語法或更詳細的說明。先執行程式看看效果，對於學習是很有幫助的，有興趣的人再去深入查看。\n接下來的內容看起來很無聊，也沒有必要學會每個函數、更不用背它們，當要用的時候在上 google 查就好了。儘量保持問問題的想法，像是：\nQ: 怎麼串連子串陣列？A: ['a', 'b', 'c'].join(',') Q: Java 的字串有 split 方法，那 javascript 有沒有？A: 'a,b,c'.split(',') 這樣學起來有趣多了。\nArray 1// 宣告 2const words = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; 3 4// 設定值 5words[0] = \u0026#39;d\u0026#39;; 6 7// 取值 8console.log(words[0]); 9 10// 轉換 11words.map(word =\u0026gt; words + \u0026#39;-\u0026gt;\u0026#39;);　// a-\u0026gt;b-\u0026gt;c-\u0026gt; Object 1// 宣告 2const person = { 3 name: \u0026#39;May\u0026#39; 4}; 5 6// 設定值 7person.name = \u0026#39;Billy\u0026#39;; 8 9// 取值 10console.log(person.name); 11 12// 動態塞key-value 13person.fax = \u0026#39;0000000000\u0026#39; 14console.log(person.fax); 15 16// 取keys 17Object.keys(person); 18 19// 取value 20Object.values(person); String 1// 宣告 2const msg = \u0026#39;hi!\u0026#39;; 3 4// 串接 string 5const msg = msg + \u0026#39; May.\u0026#39;; 6 7// 樣版字串(Template literals) 8const msg2 = `${msg} Bye!` 9 10// 宣告(含特殊字元) 11const msg3 = \u0026#34;Hi!\\nMay\u0026#34; Date 1// 現在時間 2const now = new Date(); 雖然有內建的 Date ，但實務上用 moment 套件比好用。\nError 1// 宣告 2const e = new Error(\u0026#39;wrong password\u0026#39;); 3 4// 拋出例外(exception) 5throw e; 還有其它像：Promise，我想獨立出來說。\n邏輯運算 邏輯運算有 ==, !=, ===, !==, \u0026amp;\u0026amp;, ||\n這裡我們需要 == 和 === 是不同的，直接看例子\n1console.log(1 == \u0026#39;1\u0026#39;); // true 2console.log(1 === \u0026#39;1\u0026#39;); // false javascript 是會 type coercion(會自動的隱式轉型)，所以 === 就是不做隱式轉型，型別也要一樣。建議使用 ===, !== 有較強的比較結果，避免隱式轉型造成的不可預測的情況。\n迴圈(loop) 1// 陣列 2const a = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; 3for (let i = 0; i \u0026lt; a.length; i++) { 4 console.log(a[i]); 5} 6a.forEach(element =\u0026gt; { 7 console.log(element); 8}); 9for (const element of a) { 10 console.log(element); 11} 12for (const key in a) { 13 console.log(key, a[key]); 14} 15 16// 物件 17const object = {first: 1, second: 2}; 18for (const key in object) { 19 console.log(key, object[key]); 20} 21for (const key of Object.keys(object)) { 22 console.log(key, object[key]); 23} 24 25// 另外還有 while loop，可以自己查看看 是不是被 for in、for of、forEach 弄的很亂阿？可以使用 lodash forEach 統一寫法\n1const _ = require(\u0026#39;lodash\u0026#39;); 2_.forEach([1, 2], (value) =\u0026gt; { 3 console.log(value); 4}); 5 6_.forEach({ \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2 }, (value, key) =\u0026gt; { 7 console.log(key); 8}); 條件符(condition) 有 if, switch, ()?X:Y(三元運算ternary operation)\n1const a = \u0026#39;1\u0026#39;; 2if(a === \u0026#39;1\u0026#39;) { 3 console.log(\u0026#39;euqal\u0026#39;); 4} 5 6switch(a){ 7 case \u0026#39;1\u0026#39;: 8 case \u0026#39;2\u0026#39;: { 9 console.log(\u0026#39;a\u0026#39;); 10 break; 11 } 12 case \u0026#39;3\u0026#39;: { 13 console.log(\u0026#39;b\u0026#39;); 14 break; 15 } 16 default: { 17 console.log(\u0026#39;default\u0026#39;); 18 break; 19 } 20} 21 22console.log(a === \u0026#39;1\u0026#39; ? \u0026#39;equal\u0026#39;: \u0026#39;not equal\u0026#39;); 利用 \u0026amp;\u0026amp; 和 || 可做到類似條件運算，這技巧在渲染react component 很好用，可以少寫判斷程式碼\n1// || 直到有值 2const a1 = undefined; 3const b1 = null; 4const c1 = a1 || b1 || \u0026#39;default c1\u0026#39;; 5console.log(c1); // default c1 6 7const a2 = undefined; 8const b2 = \u0026#39;b2\u0026#39;; 9const c2 = a2 || b2|| \u0026#39;default c2\u0026#39;; 10console.log(c2); // b2 11 12// \u0026amp;\u0026amp; 前面是 true，才會設後面的值，否則是false 13const a = true; 14const b = a \u0026amp;\u0026amp; \u0026#39;set b\u0026#39;; 15const c = !a \u0026amp;\u0026amp; \u0026#39;set c\u0026#39;; 16console.log(b, c); // set b, false 關於 javascript 的觀察 變數宣告不用指明 變數型態， 不用像 C++ int a = 1;，反而 Scope 的修飾更為重要 特別小心 type coercion, 否則會出現有趣的情況(見What the f*ck JavaScript?)，typeof只有少許可能的回傳值，這函數不是真的回傳型態 1const a = []; 2console.log(typeof a); // object lodash 也提供方便的查型態函數，但還是有可能有無法預期的結果，使用前一定要測測看 回顧 介紹了VSCode debug 模式和操作，幫助我們學習 javascript 語言。同時，了解到javascript有很多因為 type coercion 產生的好笑的情況。\n參考連結 JavaScript Essentials: Types \u0026amp; Data Structures ","date":"2018-10-04","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-4-%E4%B8%80%E5%91%A8%E7%9B%AE-%E7%94%A8vscode-debug-%E6%A8%A1%E5%BC%8F%E7%8E%A9%E7%8E%A9-es6-%E5%B8%B8%E7%94%A8%E8%AA%9E%E6%B3%95/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 4 - 一周目- 用VSCode Debug 模式，玩玩 ES6 常用語法"},{"categories":[],"content":"今天我們要正式使用 VSCode 來建立 Node.js 專案，未來的前後端專案都是用Node.js 專案建立的。\n回憶 昨天介紹指令的使用和用Markdown 做筆記、draw.io 畫圖，這些技能可以發揮在所有專案\n目標 今天我們要正式使用 VSCode 來建立 Node.js 專案，未來的前後端專案都是用Node.js 專案建立的。\n建立Node.js 專案及了解package.json 安裝其它套件 執行腳本 VSCode 執行組態 Node.js 是什麼 Node.js官方網站說：\nNode.js® is a JavaScript runtime built on Chrome\u0026rsquo;s V8 JavaScript engine.\nNode.js 只是一個基於 Chrome 的 V8 engine 的 JavaScript 執行環境。程式碼寫的就是 JavaScript，也就是大部分瀏覽器執行的程式語言。因此，有了 Node.js 就也可以開發後端程式，也因為用同樣的語言，所以「某些程度上」可以共用程式，像是常用來操作資料的 lodash，就是前後端都可以使用的套件。\n準備 Node.js 執行環境 https://nodejs.org/en/，下載 Node.js 一進去會看到 LTS (Long Term Support) 是長時間的維護，點擊 Long Term Support (LTS) schedule 可以查看維護時間表。想安裝哪個都可以，因為本主題用的都是精典的 Node.js 模組。我的話會選10版的，因為N-API (C++編譯出的執行程式在Node.js環境中使用，且與Node.js版本無關)正式支援，多學點不錯阿！若你考慮到長期維護可以選8版的。 安裝完成後，來看看你安裝的版本。開啟 hello-nodejs 的 VSCode 專案資料夾，再開打開 terminal(需要幫助的人可以看Day 1 - 前言／開發環境準備)，輸入 node --version 我的版本是 9.7.1。若昨天有看Day 2 - 一輩子受用的工具的人會發現這裡的 node 就是指令，--version就是選項(options)。 題外話：Node.js 的版本釋出真快，一不小心就被超過了QQ。為了可以確保程式可以在新版執行，建議平時寫好測試保護\n建立第一個 Node.js 專案 準備好環境後，就可以來建 Node.js 專案\n什麼是Node.js 專案？ Node.js 的專案是一個資料夾，內部可以放很多檔案，像是程式、文件…等，放什麼都可以，但在根目錄一定有一個叫 package.json 的檔案，它記錄專案的基本資訊，如專案名，專案版本、專案相依的套件…等(更多的訊息見package.json)，常見 package.json 如下：\n1{ 2 \u0026#34;name\u0026#34;: \u0026#34;hello-nodejs\u0026#34;, 3 \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, 4 \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, 5 \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, 6 \u0026#34;scripts\u0026#34;: { 7 \u0026#34;start\u0026#34;: \u0026#34;node index.js\u0026#34; 8 }, 9 \u0026#34;author\u0026#34;: \u0026#34;eugenechen\u0026#34;, 10 \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, 11 \u0026#34;dependencies\u0026#34;: { 12 \u0026#34;lodash\u0026#34;: \u0026#34;^4.17.5\u0026#34; 13 }, 14 \u0026#34;devDependencies\u0026#34;: { 15 \u0026#34;jest\u0026#34;: \u0026#34;^22.4.2\u0026#34; 16 } 17} package.json 參數說明如下：\nname： 專案名 version：專案版本 scription：專案描述 main：專案/套件程式入口 scripts： shell 腳本。透過 npm run \u0026lt;腳本名\u0026gt; 執行 dependencies：相依的套件。以上面的例子來說，hello-nodejs 有用到一個相依的套件 lodash， ^4.17.5 指的是 hello-nodejs 需要 4.17.5 以上的版本且只支援到主版本 4.X.X , 5.0.0 以上不支援。更多版本號的語義見The semantic versioner for npm devDependencies：開發時的相依的套件，對於 hello-nodejs 專案執行來說無關。以上面的例子來說， jest 是測試框架套件，本身跟 hello-nodejs 執行無關。版號規則跟上面一樣。 快速建立 Node.js 專案 package.json 有一堆參數，每次都要自己來嗎？不用。只要在terminal輸入\n1npm init 指令就會出現初始化專案的設定提示。 完成後就會自動產生 package.json。\nnpm 這個指令會隨著安裝 Node.js 一併安裝，npm 是 Node.js 的 套件管理員，可以為你的專案安裝其它套件，也可以拿來初始化專案…等。還想知道更多嗎？快輸入npm --help 可以看到指令訊息。\n套件(package)安裝 在 Node.js 的生態系中別人寫好的程式打包起來，就是所謂的套件，在別的程式語言可能有別的名稱，像C++中會叫程式庫(library)。套件可以廣為傳送給別人使用，使我們少寫不少程式。當你學的套件越多就可能做的越快，甚至可以做出自己套件(未來我們會談談怎麼用verdaccio建立自己的私有庫。\n安裝你的第一個套件 lodash 在terminal輸入\n1npm install lodash --save npm 會從 npmjs registry下載套件，你會發現多出 package-lock.json 和 node_modules 資料夾。 package-lock.json 用來記錄各套件的相依版本號記錄；而 node_modules 就是存放套件程式碼的資料夾，所以打開後你可以看到 lodash 套件的所有程式碼。 很多吧! 自己寫不知道要寫多久。\n除了上面多出的檔案和資料夾，package.json 也被修改了，多出\n1\u0026#34;dependencies\u0026#34;: { 2 \u0026#34;lodash\u0026#34;: \u0026#34;^4.17.11\u0026#34; 3} 表示我們的專案有一個相依的庫 lodash\n指令 npm install lodash --save 是什麼意思？ 指令 npm install lodash --save 其實有兩個意思\ninstall lodash的部份是指下載安裝 lodash (不指定版號就是最新版)到 node_modules --save 的部份加入相依資訊到 package.json 的 dependencies 中 npm install 可以做什麼？ 初始化專案的所有相依套件 若是 npm install 不加 lodash --save，就會安裝 package.json 中 dependencies 和 devDependencies 裡面的所有套件。當拿到別人的 Node.js專案 第一件事就是 npm install 安裝所有套件 重新下載 package.json 的相依套件 你也可以手動打dependencies 和 devDependencies 裡面的資訊，再npm install重新下載套件 npm install 還有什麼祕密？ 簡寫 install 成 i ，如：npm install 改成 npm i 安裝新的shell指令 npm install jest -g 可以安裝 jest 指令，我們就有 jest指令，下 jest 指令 就會找所有測試程式執行測試 安裝開發時相依套件 npm install jest --save-dev 會安裝jest且加入 package.json 中 devDependencies中 在 VSCode 執行 hello nodejs 前面終於安裝好相依套件，我們要執行我們的第一隻程式\n建立第一隻程式：index.js 建立名為 index.js 的檔案 輸入以下內容 1console.log(\u0026#39;Hello Node.js\u0026#39;); // 在terminal 印出 Hello Node.js 執行 index.js 我們介紹三種執行它的方法\n用 node index.js 指令執行 透過 npm 腳本執行 加入一個名為 start 的腳本 1\u0026#34;scripts\u0026#34;: { 2 \u0026#34;start\u0026#34;: \u0026#34;node index.js\u0026#34; 3}, 接下來執行 npm run start 用 VSCode 執行 開啟 debug 頁籤 建立 VSCode 執行組態 執行debug VSCode 執行組態 我們之前用VSCode 執行後，會發現專案資料夾多個一個資料夾 .vscode 且裡面多出一個 launch.json 檔案。\nNode.js 執行組態 還記得我之前說的嗎？ VSCode的一個專案就是一個資料夾，然而 .vscode 裡面就會放 VSCode 專案的設定檔。如果你是用WebStorm編輯器，編輯器的設定檔會放在.idea裡。\nlaunch.json 裡面會放可以執行的組態，按小綠箭頭便會執行所選的組態。下圖 就是有一個執行組態，名為 Launch Program，執行類型是node ，執行 ${workspaceFolder}/index.js 的程式，這裡 ${workspaceFolder} 是VSCode的變數(Variable substitution)，指向專案根目錄。更多屬性設定見Launch configurations。\n加入新的組態：透過 npm 執行腳本 VSCode 可以幫我們快速加入一個組態 多出一個透過 npm 執行debug腳本的組態\n1{ 2 \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, 3 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 4 \u0026#34;name\u0026#34;: \u0026#34;Launch via NPM\u0026#34;, 5 \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;npm\u0026#34;, 6 \u0026#34;runtimeArgs\u0026#34;: [ 7 \u0026#34;run-script\u0026#34;, 8 \u0026#34;debug\u0026#34; 9 ], 10 \u0026#34;port\u0026#34;: 9229 11} 可以改成我們之前設定的start腳本\n1{ 2 \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, 3 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 4 \u0026#34;name\u0026#34;: \u0026#34;Launch via NPM\u0026#34;, 5 \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;npm\u0026#34;, 6 \u0026#34;runtimeArgs\u0026#34;: [ 7 \u0026#34;run\u0026#34;, 8 \u0026#34;start\u0026#34; 9 ], 10 \u0026#34;port\u0026#34;: 9229 11} 接下來，執行 Start Without Debugging，相當於在terminal執行 npm run start 我們沒辨法用 Start Debugging，因為npm 沒有支援debug功能。\n總結 今天介紹了 Node.js 專案，還有如何執行 .js 程式碼。透過VSCode的執行組態我們可以更靈活、方便的執行程式，也可以用來執行特殊的工作。\n","date":"2018-10-03","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-3-%E4%B8%80%E5%91%A8%E7%9B%AE-%E5%BB%BA%E7%AB%8B-%E7%AC%AC%E4%B8%80%E5%80%8Bnode.js-%E5%B0%88%E6%A1%88/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 3 - 一周目- 建立第一個Node.js 專案"},{"categories":[],"content":"昨天我們示範了touch指令來建立空檔案，今天我們來看看有什麼常用的指令。此外，介紹常用來打文件的 Markdown 語法和畫圖用的 draw.io。\n回憶 昨天我們示範了touch指令來建立空檔案，今天我們來看看有什麼常用的指令。此外，介紹常用來打文件的 Markdown 語法和畫圖用的 draw.io。\n指令 為什麼要學指令？ 指令是很強大的，就只要一行指令，就可以執行常用的操作，像是建立資料夾、預先編輯程式碼、背景執行程式…等，甚至可以集合起來成一聯串的腳本，如：linux .sh 或 windows .cmd。未來我們會透過腳本，打造自己的發佈腳本、備份腳本、執行腳本。\n指令怎麼執行？ Shell shell 是一個存取作業系統服務的使用者介面，如：windowns 有命令提示字元，linux有bash\u0026hellip;等。我們說的 指令 通常是指 command-line interface (CLI)，指令文字會打在終端機中(terminal/命令提示字元)。\n下面列出一定要認識的指令 cd - 移動當前資料夾 mkdir - 建立資料夾 cp - 拷貝檔案 mv - 移動檔案 rm - 刪除檔案 pwd - 印出當前資料夾 ls/ll(ls -l) - 印出當前資料夾的檔案/資料夾 chmod - 改變檔案/資料夾權限，操作可以看鳥哥的 Linux 私房菜-如何改變檔案屬性與權限 chown - 改變檔案/資料夾擁有者，操作可以看鳥哥的 Linux 私房菜-如何改變檔案屬性與權限 動手做 接下來你可以操作看看，過程只是玩玩看指令，沒有特別的目地。\n我們開啟一個VScode專案，並執行一個terminal 輸入 pwd 可以知道當前資料夾是在哪，指令的預設目錄是這裡 mkdir src 就會建立src資料夾 touch README.md 建立空的README.md cp README.md src 拷貝README.md到src資料夾 cd src 移動當前資料夾到src，你可以再輸入pwd看看當前資料夾是不是變了 rm README.md 刪除README.md cd .. 回到上一層資料夾。這裡的相對路徑中，.. 指上一層資料夾，.指當前資料夾 ls -l 指令要背嗎？ 不用刻意背，上網查或指令說明查詢，一般指令都可以查使用說明，常見\n1# `rm` 是要查的指令 2rm --help 3rm help 4rm -h 5man rm 上面都有可能可以查看用法，要看製作指令的人怎麼寫。\ncmd 常見格式: -- - -- 或 - 一般指指令選項(options), --常會搭配選項全名, -常會搭配參數簡稱，如下圖的 --version 和-v 指令小抄 下面我常用指令\n1# 確保build資料夾存在 2mkdir -p build 3 4# 拷貝resource資料夾(包含裡面的所有檔案/資料夾) 5cp -R ./resource .src/ 6 7# 刪除build資料夾(包含裡面的所檔案/資料夾) 8rm -rf build 9 10# 重新命名並移動 11mv ./README.md ./src/README.bak.md cheatsheet這網站我很推薦，可以查常用的指令或程式碼的小抄，也可能拿來學一些沒用過的指令或程式碼。\nMarkdown 前面提到 cheatsheet，那是別人整理好的小抄，你也可以寫屬於自己小抄。不僅如此，Markdown也常被用來寫文章、文件、筆記。\nMarkdown是用文字和格式來做排版，如下：\n1# 第一章 2## 第一節 3* item 4* item 透過Markdown reader 就會變成 為什麼用Markdown？ 文字排版，方便複製、貼上 文字容易傳送、儲存，也可以像程式碼一樣放入版本管理(version control)工具Git/SVN 文字資料只須少量的檔案大小 常用語法 我發現 iT幫邦-Markdown說明整理的東西很常用，我只例出必學的。\nMarkdown 文字： 檢視結果如下： Markdown的限制 Markdown 只是文字，不是即可見的，所以要搭配檢視軟體(reader)才能看 不同的檢視軟體有自己檢視結果，所以會有些許的不同，像是風格、大小 也因為受於檢視軟體的解讀差異，Markdown 格式語法風格會有差，像是不同縮排或語法中空白的數量，都可能在不同檢視軟體有不同結果或不能正常顯示 格式語法風格不容易統一 圖片/檔案資源一般不會放在文件內，要用外部資源，以圖片為例：![圖片無法顯示時文字](URI資源)。不過，還是可以用base64 image文字，把圖片轉成文字再鑲入文件中，但你不會想這麼做的，下面就是一張圖片： 。此外，檢視軟體能不能解讀又是另一回事，我用的筆記軟體 Quiver和 VSCode - Markdown All in One 剛好都可以解讀。 1![c word](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAA0CAYAAACHO2h8AAAKB2lDQ1BJQ0MgUHJvZmlsZQAASImFlndYFNcaxs/M9kZbWHrvvcMC0nuTXkVhWWCp67JUERsSVCCiiIiAIkioCkZDjQURxUIQUMCCBiQIKDFYABWVDJDEJPc+937znOf8nnfOeeebM3/MCwDJjcHhxMN8ACSwk7nejjYygUHBMrhnAA2wAA/EgQ6DmcSx9vR0A0j9Of+zFkcAtDrf01z1+s/7/7P4IyKTmABAngjTmRxuMsL7EfZNS+as8hjCglykKYTnV5m1xjB6lcPXWWRtja+3LcIaAODJDAaXBQCRjugyqUwW4kMMRFiHHRHDRnjV34IZzYhA+CbCGlHxKekIv1tdk5CwFdFJCgirhP/Nk/UP//C//BkM1l+cEJ/C/OO9Vk+EHMn280FmMWRIgCigBeJBCkgHMoADuGArosQgSiRy9v99H31tny2ykgO2ITtiAAtEg2Rkv8PfvHzWnJJBGmAgayIRxQ25bFe/47rlW9qaK0S7/VVL7ALAJBcRWV81hjwAHc8BoC5+1eTfIO0cAuDSADOFm7qurR49wAAi4AWCQBRIAXmgAjSBHjACZsAK2AMX4AF8QRDYAphIvwlIV2kgE+wBOSAPHAJHQSmoAKdBHTgLzoM2cBFcBTfAHTAAhsFjMA6mwEswDxbBMgRBOIgCUSFRSBpShNQhPYgOWUD2kBvkDQVBYRALYkMpUCa0F8qDCqFSqBKqh76HOqCr0C1oEHoITUCz0BvoI4yCybAgLAkrwdowHbaGXWFfeDPMghPhDDgbPgiXwFXwGbgVvgrfgYfhcfglvIACKBKKhpJFaaLoKFuUByoYFYXionaiclHFqCpUE6oT1Yu6hxpHzaE+oLFoKloGrYk2Qzuh/dBMdCJ6JzofXYquQ7eie9D30BPoefQXDAUjgVHHmGKcMYEYFiYNk4MpxtRgWjDXMcOYKcwiFoulYZWxxlgnbBA2Frsdm489gW3GdmEHsZPYBRwOJ4pTx5njPHAMXDIuB3ccdwZ3BTeEm8K9x5Pw0ng9vAM+GM/GZ+GL8Q34y/gh/DR+mcBHUCSYEjwIEYRthAJCNaGTcJcwRVgm8hOVieZEX2IscQ+xhNhEvE4cI74lkUhyJBOSFymGtJtUQjpHukmaIH0gC5DVyLbkEHIK+SC5ltxFfkh+S6FQlChWlGBKMuUgpZ5yjfKU8p6HyqPF48wTwbOLp4ynlWeI5xUvgVeR15p3C28GbzHvBd67vHN8BD4lPls+Bt9OvjK+Dr5RvgV+Kr8uvwd/An8+fwP/Lf4ZAZyAkoC9QIRAtsBpgWsCk1QUVZ5qS2VS91KrqdepU4JYQWVBZ8FYwTzBs4L9gvNCAkIGQv5C6UJlQpeExmkomhLNmRZPK6Cdp43QPgpLClsLRwofEG4SHhJeEhEXsRKJFMkVaRYZFvkoKiNqLxoneli0TfSJGFpMTcxLLE3spNh1sTlxQXEzcaZ4rvh58UcSsISahLfEdonTEn0SC5JSko6SHMnjktck56RoUlZSsVJFUpelZqWp0hbSMdJF0lekX8gIyVjLxMuUyPTIzMtKyDrJpshWyvbLLsspy/nJZck1yz2RJ8rT5aPki+S75ecVpBXcFTIVGhUeKRIU6YrRiscUexWXlJSVApT2KbUpzSiLKDsrZyg3Ko+pUFQsVRJVqlTuq2JV6apxqidUB9RgNUO1aLUytbvqsLqReoz6CfVBDYyGiQZbo0pjVJOsaa2ZqtmoOaFF03LTytJq03qlraAdrH1Yu1f7i46hTrxOtc5jXQFdF90s3U7dN3pqeky9Mr37+hR9B/1d+u36rw3UDSINTho8MKQauhvuM+w2/GxkbMQ1ajKaNVYwDjMuNx6lC9I96fn0myYYExuTXSYXTT6YGpkmm543/c1M0yzOrMFsZoPyhsgN1RsmzeXMGeaV5uMWMhZhFqcsxi1lLRmWVZbPrOStIqxqrKatVa1jrc9Yv7LRseHatNgs2Zra7rDtskPZOdrl2vXbC9j72ZfaP3WQc2A5NDrMOxo6bnfscsI4uToddhp1lnRmOtc7z7sYu+xw6XElu/q4lro+c1Nz47p1usPuLu5H3Mc2Km5kb2zzAB7OHkc8nngqeyZ6/uiF9fL0KvN67q3rnend60P1CfVp8Fn0tfEt8H3sp+KX4tftz+sf4l/vvxRgF1AYMB6oHbgj8E6QWFBMUHswLtg/uCZ4YZP9pqObpkIMQ3JCRjYrb07ffGuL2Jb4LZdCeUMZoRfCMGEBYQ1hnxgejCrGQrhzeHn4PNOWeYz5MsIqoihiNtI8sjByOso8qjBqhmXOOsKajbaMLo6ei7GNKY15HesUWxG7FOcRVxu3Eh8Q35yATwhL6GALsOPYPVultqZvHeSoc3I444mmiUcT57mu3JokKGlzUnuyIPLz7EtRSfkmZSLVIrUs9X2af9qFdP50dnrfNrVtB7ZNZzhkfLcdvZ25vTtTNnNP5sQO6x2VO6Gd4Tu7d8nvyt41tdtxd90e4p64PT9l6WQVZr3bG7C3M1sye3f25DeO3zTm8ORwc0b3me2r2I/eH7O//4D+geMHvuRG5N7O08krzvuUz8y//a3utyXfrhyMOthfYFRw8hD2EPvQyGHLw3WF/IUZhZNH3I+0FskU5Ra9Oxp69FaxQXHFMeKxlGPjJW4l7ccVjh86/qk0unS4zKasuVyi/ED50omIE0MnrU42VUhW5FV8PBVz6kGlY2VrlVJV8Wns6dTTz6v9q3u/o39XXyNWk1fzuZZdO17nXddTb1xf3yDRUNAIN6Y0zp4JOTNw1u5se5NmU2UzrTnvHDiXcu7F92Hfj5x3Pd99gX6h6QfFH8pbqC25rVDrttb5tui28fag9sEOl47uTrPOlh+1fqy9KHux7JLQpYLLxMvZl1euZFxZ6OJ0zV1lXZ3sDu1+fC3w2v0er57+667Xb95wuHGt17r3yk3zmxdvmd7quE2/3XbH6E5rn2Ffy0+GP7X0G/W33jW+2z5gMtA5uGHw8pDl0NV7dvdu3He+f2d44/DgiN/Ig9GQ0fEHEQ9mHsY/fP0o9dHy491jmLHcJ3xPip9KPK36WfXn5nGj8UsTdhN9z3yePZ5kTr78JemXT1PZzynPi6elp+tn9GYuzjrMDrzY9GLqJefl8lzOr/y/lr9SefXDb1a/9c0Hzk+95r5eeZP/VvRt7TuDd90LngtPFxMWl5dy34u+r/tA/9D7MeDj9HLaJ9ynks+qnzu/uH4ZW0lYWeEwuIy1KIBCBhwVBcCbWgAoQUh2GECy0Kb1zPVHnoH+lmz+ZNCv95VLQ9dz2VoZAVBrBYDfbgDckIxyEhmKCJOReTUi+loBWF//r/FHJUXp660/g8xFosn7lZW3kgDgOgH4zF1ZWT6xsvK5Gmn2IQBdif+3t3/xeh5cLSySkk9pr9LA1Cvw7/odVO2+40A3ezUAAAAJcEhZcwAAFiUAABYlAUlSJPAAAAGbaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE4PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjUyPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CsngFRYAAAAcaURPVAAAAAIAAAAAAAAAGgAAACgAAAAaAAAAGgAAAKWrcuGaAAAAcUlEQVRIDWL8DwQMVACMowYRDMWhEkZ/nzFMSy9lOMPAjuKln98YGGLbZjB4KLChiIM42L327SZDkl00wyUM5QwMBYv2M8Ro8WLIYDfo102GfKtohqMYykcNggfJaBjBgwLIGE1HiNAYzWvQsBjILAIAAAD//xH+VfsAAABoSURBVGP8DwQM6ODXTYZ8q2iGo+jiQH7Bov0MMVq8GDKMowbBw2Q0jKBBMZqO4GkCyBhCWSQJmPsvIbsdyiYxZd9nqLEKZdiBxaCylccYwpTZMGSwhxGGMsICowaNhhHhECCsgmrpCAAfj6N0qqWW5wAAAABJRU5ErkJggg==) Markdown 怎麼在VSCode中檢視? 前面提到Markdown需要搭配檢視軟體，幸運地 VSCode 的擴展(Extension)有套件可以使用。\n開啟 VSCode 的 Extension的頁簽 搜尋 markdown，你會看到一堆可以選，基本上有Preview的都可以用 我是選擇下載人數多的 Markdown All in One 在Markdown文件中，開啟Priview draw.io draw.io我很推薦的工具之一，就是用來畫圖，可以釐清自己的想法或和別人溝通。 你可以很容易的畫出UML、心智圖(Mind Map)、架構圖…等。例如下面的UML 活動圖： draw.io 有什麼過人之處嗎？ 免費 可以直接儲存在google drive, dropbox\u0026hellip;等雲端空間，也可以本地儲存 可以匯入匯出，轉存圖檔、PDF，也支援SVG 支援鍵盤的複製貼上或拖拉，圖片也可以 共同編輯 可輸入中文、客製化風格 元件可群組、快速排版、多選元件設定屬性 多頁籤 內件大量元件、也可以自製元件 總結 今天我們介紹常用指令和小抄bash cheatsheet，讀者可以透過Markdown寫自己的專屬小抄、文件。最後，用 draw.io 製圖為文件增加更多色彩。\n","date":"2018-10-02","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-2-%E4%B8%80%E8%BC%A9%E5%AD%90%E5%8F%97%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 2 - 一輩子受用的工具"},{"categories":[],"content":"最近剛好在做自己的個人網站，整理自己的技能樹，想要透過「iT邦幫忙鐵人賽」整理自己的開發經驗。\n題目由來 最近剛好在做自己的個人網站，整理自己的技能樹，想要透過「iT邦幫忙鐵人賽」整理自己的開發經驗。\n題目目標 新手工程師，應該可以本主題學到不少前後端開發經驗，我會盡量用直白說法解釋內容 提供比較全面的技能介紹，以提供有興趣的人躦研 適合想看看後端開發在做什麼的人 因為我想要儘量包含我所知道的，但這幾天我打草稿後發現不太可能，所以我只能抓取我覺得重要的內容，若有覺得講的不好的地方或缺少的內容，請跟我說yujichen0514@gmail.com，或直接討論。\n學習心態 本篇叫「用js成為老闆心中的全端工程師」，我想老闆都希望可以快速完成工作，剛好我比較主張 用學相長(邊用邊學)，畢竟時間有限，但我不是指只要寫程式就好，(使)用 是讓自己抓到直覺和感受別人的設計最快的方法， 學(習) 可以有更深的體悟、也記得久，更能融會貫通，用學相長 是一種知識上的演進。\n幾乎每天的文章內容都可以有自己動手做的部分，有興趣的人可以自己玩看看。\n文章概觀 本目題打算進行三周目，大致上是先開發、發佈，再維運。主要使用 javascript / nodejs 為開發語言, 利用 docker 準備開發環境，進而發佈，最後引入程式維運。不得不說 docker 的出現使得開發者學習上有很大幫助。\n前言/一輩子受用的工具：常用的工具：shell常用指令、markdown、draw.io，學會使用就一輩子受用 一周目：以極精簡程式一次串完前後端，快速了解前後端在串什麼東西 二周目：更深入了解前後端，不得不了解的概念或技術 三周目：利用 docker 發佈自己的程式，架設維運所需的相關服務 開發環境準備 若怕用髒自己的電腦環境、可以用 Virtual Machine，來安裝一個虛擬的作業系統。 Windows的使用者可以用VirtualBox，Mac可以用Parallels Desktop Lite。不過我們也只會安裝 NodeJS、docker/ docker-compose, Visual Studio Code, Vegeta。\n雖然我的作業系統是Mac OS，我所以下的指令大多相容 linux, 就算是windows應該都有相對應的指令。\n首先，我們要建立開發環境，先安裝Visual Studio Code，這是程式碼編輯程式，同時也整合了發開現代網頁和後端應用程式的工具。\nVisual Studio Code 怎麼開一個專案 第一個重要的事就是：\n一個專案就是一個資料夾\n所有跟專案有關的程式/檔案都會放在同一個資料夾裡。\n那麼有人會問，不同專案共用程式碼怎麼辨，可以用 程式庫 決解，不會放在專案，所有專案都可以下載到的地方。未來就會提到怎麼建立自己的私有庫。\n隨便開一個資料夾後，打開Visual Studio Code，選擇你建立的資料夾 圖中Day1就是一個專案。 結束，你學會了用Visual Studio Code開啟一個專案 建立專案中第一個檔案 開 terminal 就可以直接下指命 這裡 touch README.md 就會建立一個名為README.md的檔案 一但開啟一個 terminal，預設工作目錄就會在專案資料夾，所以下達touch README.md就會在專案根目錄建立檔案。\n回顧 學習怎麼用 Visual Studio Code 開一個專案 用 terminal下達一個指令 (附錄)題目可能包含的內容 下面是可能包含的內容，可能會隨著文章更改內容\n前言 一輩子受用的工具 shell常用指令 markdown - 打筆記 draw.io - 畫圖 一周目 - 一次串完所有的服務 js/nodejs project js 速成 - es6語法、模組化 eslint - 程式碼品質工具 quick backend Postman - api 測式工具 quick frontend 二周目 開發流程 後端 基本知識 awilix - 依賴注入 process.env middleware / router / request / response 建立與連線 MongoDB 後端多工/ 叢集/child process Auth: token - JWT 常用庫: lodash, monent, mongoose 可研究方向: GraphQL, websocket, redis, server-side rending, Oauth 測試 基本知識 - 依賴注入 單元測試、整合測試 替身 常用庫 sinon.createFakeServer() unexpected/ unexpected react 前端 基本知識 - 打包, sass, rwd(mdiea query, boostrip) tooles: chrome extension google devtools snadbox - codesandbox React - pure/container, Fragments, lifecycle, Context, loop/condition expression, lifecycle sandbox, loop key strategy Redux - flux RxJs - 非同步action material-ui - UI元件庫 可研究方向: PWA, functional programing 串連前後端 串接api 單元測試、整合測試(puppeteer) nginx, single page application(spa) 設定 三周目 - 發佈、維運 發佈 Docker, Docker-compose: volumn, ps, image, network 打包 image, shell script verdaccio - 建立自己的私有庫 維運 ELK Zabbix - email, slask vegeta - 壓測工具 MongoDb 備份 ","date":"2018-10-01","img":"","largeImg":"","permalink":"https://eugenechen0514.github.io/blog/series/2019-ithome-ironman/day-1-%E5%89%8D%E8%A8%80%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/","series":["2019-iThome-Ironman"],"smallImg":"","tags":["2019 iT 邦幫忙鐵人賽","用js成為老闆心中的全端工程師"],"title":"Day 1 - 前言／開發環境準備"}]